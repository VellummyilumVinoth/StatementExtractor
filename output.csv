actualNode,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
normalizedActualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
actualNodeLines,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
node,SyntaxNode node;
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
t,err:Syntax|Token? t = advance(tok, k, lines);
lc,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
src,string src = lines[lc[0] - 1];
tStart,int tStart = lc[1];
tStr,string tStr = tokenToString(t);
srcAtPos,string srcAtPos = src.substring(tStart, tStart + tStr.length());
e,err:Syntax? e = tok.advance();
all,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
invalidCases,int invalidCases = all.length();
valid,map<ParserTestCase> valid = check readParserTests();
sources,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
tests,map<TokenizerTestCase> tests = {};
testData,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
expected,string[] expected;
subject,string subject = s[2];
subjectLines,string[] subjectLines = splitIntoLines(subject);
rule,string rule = s[1];
testFiles,var testFiles = check file:readDir("modules/front.syntax/tests/data");
path,string path = f.absPath;
base,string base = check file:basename(path);
parentDir,string parentDir = check file:parentPath(path);
canonFile,string canonFile = check file:joinPath(parentDir, canonFileName(base));
baseParts,[Kind, string] baseParts = check splitTestName(base);
len,int len = base.length();
kindPos,int kindPos = base.indexOf("-") ?: 0;
kind,string kind = base.substring(0, kindPos);
afterKindPos,int afterKindPos = min(kindPos + 1, len);
rulePos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
lines,string[] lines = check io:fileReadLines(path);
caseLines,string[] caseLines = [];
inCase,boolean inCase = false;
indented,int indented = 0;
trimLine,string trimLine = line.trim();
sansExt,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
