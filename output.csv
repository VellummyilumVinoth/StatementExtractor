actualNode,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
normalizedActualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
actualNodeLines,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
node,SyntaxNode node;
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
t,err:Syntax|Token? t = advance(tok, k, lines);
lc,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
src,string src = lines[lc[0] - 1];
tStart,int tStart = lc[1];
tStr,string tStr = tokenToString(t);
srcAtPos,string srcAtPos = src.substring(tStart, tStart + tStr.length());
e,err:Syntax? e = tok.advance();
all,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
invalidCases,int invalidCases = all.length();
valid,map<ParserTestCase> valid = check readParserTests();
sources,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
tests,map<TokenizerTestCase> tests = {};
tests,map<ParserTestCase> tests = {};
testData,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
expected,string[] expected;
subject,string subject = s[2];
subjectLines,string[] subjectLines = splitIntoLines(subject);
rule,string rule = s[1];
testFiles,var testFiles = check file:readDir("modules/front.syntax/tests/data");
path,string path = f.absPath;
base,string base = check file:basename(path);
src,string[] src = check readCase(path);
parentDir,string parentDir = check file:parentPath(path);
canonFile,string canonFile = check file:joinPath(parentDir, canonFileName(base));
expected,string[] expected;
baseParts,[Kind, string] baseParts = check splitTestName(base);
rule,string rule = baseParts[1];
len,int len = base.length();
kindPos,int kindPos = base.indexOf("-") ?: 0;
kind,string kind = base.substring(0, kindPos);
afterKindPos,int afterKindPos = min(kindPos + 1, len);
rulePos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
rule,string rule = base.substring(afterKindPos, rulePos);
lines,string[] lines = check io:fileReadLines(path);
caseLines,string[] caseLines = [];
inCase,boolean inCase = false;
indented,int indented = 0;
trimLine,string trimLine = line.trim();
sansExt,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
baseTestDir,string baseTestDir = check file:joinPath(baseDir, testDir);
transformedTestDir,string transformedTestDir = check file:joinPath(transformedDir, testDir);
skipped,TestDiffResult[] skipped = [];
changed,TestDiffResult[] changed = [];
unchanged,TestDiffResult[] unchanged = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
baseTestFile,string baseTestFile = check file:joinPath(baseTestDir, test);
transformedTestFile,string transformedTestFile = check file:joinPath(transformedTestDir, test);
baseTests,TestCase[] baseTests = check parseTests(baseTestFile);
transformedTests,TestCase[] transformedTests = check parseTests(transformedTestFile);
lines,string[] lines = check io:fileReadLines(path);
content,string[] content = [];
description,string description = "";
tests,TestCase[] tests = [];
s,State s = CONTENT;
baseIndex,int baseIndex = 0;
transformedIndex,int transformedIndex = 0;
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
baseDescription,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
baseContent,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
transformedDescription,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
transformedContent,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
body,string[] body = [];
currentPath,string currentPath = "";
path,string path = diff.base.path;
currentPath,string currentPath = "";
path,string path = diff.base.path;
parts,string[] parts = check file:splitPath(absPath);
skipList,string? skipList = opts.skipList;
skipLabels,string[][] skipLabels = skipList != () ? check parseSkipList(skipList) : [];
skipped,int skipped = 0;
total,int total = 0;
tests,BaltTestCase[] tests = check parseTest(path);
parts,string[] parts = check file:splitPath(path);
filename,string filename = parts[parts.length() - 1];
dir,string dir = parts[parts.length() - 2];
testCases,BaltTestCase[] testCases = [];
lines,string[] lines = check io:fileReadLines(path);
header,string[] header = [];
labels,string[] labels = [];
content,string[] content = [];
useIoLib,boolean useIoLib = false;
s,State s = BOF;
fBody,var [_, fBody] = parseField(line);
contentLine,var [contentLine, newLabels] = transformContent(line);
newLabels,var [contentLine, newLabels] = transformContent(line);
newContent,string[] newContent = ["import ballerina/io;"];
newLabels,string[] newLabels = [];
initFunc,string initFunc = "function init()";
newLine,string newLine;
starIndex,int? starIndex = line.indexOf("{");
endIndex,int? endIndex = line.indexOf("}");
targetIndex,int targetIndex = <int>line.indexOf("?;");
i,int? i = s.indexOf(":");
fieldName,string fieldName = s.substring(0, i);
fieldValue,string fieldValue = s.substring(i + 1);
labels,string[] labels = [];
content,string[] content = [];
body,string[] body = [];
skipped,int skipped = 0;
index,int index = 0;
skipIndices,int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];
skipTest,boolean skipTest = false;
outputFileName,string outputFileName = string `./tests/${dir}/${filename}`;
invalid,boolean invalid = true;
tc,t:Context tc = mod.getTypeContext();
numBlocks,int numBlocks = self.blocks.length();
vc,VerifyContext vc = new(mod, defn);
entry,Label entry = 0;
cx,VerifyCodeContext cx = check vc.verifyCodeContext(code);
params,RegSet params = check verifyParamRegs(vc, code.registers);
block,BasicBlock block = cx.blocks[current];
term,Insn term = check blockTerminator(cx, block, predPos);
termPos,Position termPos = term.pos;
onPanic,Label? onPanic = block.onPanic;
cycle,boolean cycle = cx.preds[child];
fid,int fid = cx.fwdInDegrees[child];
i,int i = 0;
insns,Insn[] insns = cx.blocks[i].insns;
paramRegs,RegSet paramRegs = [];
afterParams,boolean afterParams = false;
block,BasicBlock block = cx.blocks[current];
flows,RegFlow[] flows = cx.blocksFlows[current];
regs,RegSet regs = mergeFlows(flows);
afterMerge,boolean afterMerge = false;
operands,| var { args: operands }
onPanic,Label? onPanic = block.onPanic;
term,Insn term = check blockTerminator(cx, block, viaPos);
termPos,Position termPos = term.pos;
trueRegs,RegSet trueRegs = regs.clone();
falseRegs,RegSet falseRegs = regs;
numFlows,int numFlows = flows.length();
i,int i = 0;
flow,RegFlow? flow = flowOriginating(flows, pred);
insns,Insn[] insns = block.insns;
insnsLen,int insnsLen = insns.length();
result,RegSet result = [];
numReg,int numReg = flow[0].regs.length();
conj,boolean conj = true;
name,string name = insn.name;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.result);
union,t:SemType union = t:NEVER;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.operand);
func,FunctionRef func = <FunctionRef>insn.func;
sig,FunctionSignature sig = func.signature;
nSuppliedArgs,int nSuppliedArgs = insn.args.length();
nExpectedArgs,int nExpectedArgs = sig.paramTypes.length();
name,string name = vc.symbolToString(func.symbol);
ty,t:SemType ty = insn.result.semType;
lat,t:ListAtomicType? lat = t:listAtomicType(vc.typeContext(), ty);
operands,Operand[] operands = insn.operands;
ty,t:SemType ty = insn.result.semType;
mat,t:MappingAtomicType? mat = t:mappingAtomicType(vc.typeContext(), ty);
indexOperand,IntOperand indexOperand = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, indexOperand.semType);
i,IntOperand i = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, insn.operands[1].semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInner(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
lhs,Operand lhs = insn.operands[0];
rhs,Operand rhs = insn.operands[1];
label,int label = code.blocks.length();
bb,BasicBlock bb = { label, name };
r,VarRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,FinalRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,NarrowRegister r = { number: code.registers.length(), underlying, semType, pos };
r,ParamRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,TmpRegister r = { number: code.registers.length(), semType, pos, name };
r,AssignTmpRegister r = { number: code.registers.length(), semType, pos, name };
isNamed,boolean isNamed = ty.name != ();
elementTypes,Type[] elementTypes = ty.elementTypes;
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
words,string[] words = [];
operand,string operand = concat(...words);
structBody,string[] structBody = [];
elemTypes,Type[] elemTypes = [];
element,final Value element = elements[i];
structTy,Type structTy = structType(elemTypes);
ty,ArrayType ty = arrayType(elementType, values.length());
body,string[] body = ["["];
element,final ConstValue element = values[i];
ty,ArrayType ty = arrayType("i8", bytes.length());
val,ConstValue val = new(ty, charArray(bytes));
words,string[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self);
words,string[] words = [];
words,string[] words = [];
structName,string structName = "%" + escapeIdent(name);
ty,StructType ty = { elementTypes: [], name: structName };
tyName,string? tyName = namedStructTy.name;
valRep,string valRep;
data,var data = entry[1];
words,string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)];
tyName,string? tyName = ty.name;
data,var data = self.namedStructTypes[tyName];
dIBuilder,DIBuilder dIBuilder = new(self, self.context);
metadata,Metadata metadata = self.addMetadata();
preambleWords,string[] preambleWords = [];
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDefn fn = new (self.context, fnName, fnType);
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDecl fn = new(self.context, fnName, fnType);
fnExisting,FunctionDecl? fnExisting = <FunctionDecl?>self.globals[name];
fnExisting,boolean fnExisting = self.globals[name] != ();
fn,FunctionDecl fn = new(self.context, "llvm." + name, fnType);
varName,string varName = self.escapeGlobalIdent(name);
ptrType,PointerType ptrType = pointerType(ty, props.addressSpace);
val,ConstPointerValue val = new ConstPointerValue(ptrType, "@" + varName);
aliasName,string aliasName = self.escapeGlobalIdent(name);
alias,ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);
varName,string varName = escapeIdent(name);
out,Output out = new;
out,Output out = new;
words,string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];
line,string[] line = [alias.operand, "="];
words,string[] words = [];
initializer,var initializer = prop.initializer;
metadata,Metadata metadata = new(self.genMetadataLabel());
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
paramType,final Type paramType = functionType.paramTypes[i];
register,string register = "%" + i.toString();
arg,Value arg = new (paramType, register);
isFirst,boolean isFirst = true;
bbName,string|Unnamed bbName = self.genName(name);
bb,BasicBlock bb = new (self.context, bbName, self);
varName,string varName = name;
count,int count = self.variableNames.get(varName);
newName,string newName = varName + "." + count.toString();
varName,int varName = self.unnamedLabelCount;
reg,string|Unnamed reg = self.genName(name);
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
newLabel,string newLabel = self.nameCounter.toString();
newName,string newName = "%" + self.nameCounter.toString();
newName,string newName = self.nameTranslation[name];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];
name,string? name = props.name;
alignInBits,Alignment? alignInBits = props.alignInBits;
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
encodingToString,string encodingToString = "DW_ATE_" + props.encoding;
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
align,int? align = props.alignInBits;
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
scope,Metadata? scope = props.scope;
file,Metadata? file = props.file;
ty,Metadata? ty = props.ty;
flags,string[] flags = [];
retainedNodes,Metadata retainedNodes = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
typeNode,Metadata typeNode = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "!", "DILocation", "("];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ptrTy,PointerType ptrTy = pointerType(ty);
bb,BasicBlock bb = self.bb();
ty,Type ty = ptr.ty.pointsTo;
reg,string|Unnamed reg = bb.func.genReg(name);
ty,Type ty = ptr.ty.pointsTo;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntegralType ty = sameIntegralType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg, "="];
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valueType,Type valueType = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
insnWords,(string|Unnamed)[] insnWords;
retType,RetType retType;
bb,BasicBlock bb = self.bb();
fnTy,Type fnTy = fn.ty.pointsTo;
fnName,var fnName = fn.operand;
functionName,string functionName = "@" + fn.functionName;
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg];
insnWords,(string|Unnamed)[] insnWords = [];
arg,final Value arg = args[i];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
elementType,Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);
bb,BasicBlock bb = self.bb();
condTy,Type condTy = condition.ty;
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
tem,BasicBlock? tem = self.currentBlock;
chunks,(string|Unnamed)[] chunks = [];
currentChunk,string[] currentChunk = [];
newLines,(string|Unnamed)[][] newLines = [];
newLine,(string|Unnamed)[] newLine = [];
newLine,string[] newLine = [];
outputLine,string outputLine = createLine([concat(...newLine)], INDENT);
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
tyName,string? tyName = ty.name;
elementTypes,Type[] elementTypes = ty.elementTypes;
typeStringBody,string[] typeStringBody = [];
elementType,final Type elementType = elementTypes[i];
typeStringBody,string[] typeStringBody = [];
typeStringBody,string[] typeStringBody = [];
paramType,final Type paramType = ty.paramTypes[i];
elementTypes,Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);
words,string[] words = [];
metadata,Metadata? metadata = fn.metadata;
ty,final Type ty = fn.functionType.paramTypes[i];
parts,string[] parts = [];
lastTail,string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";
head,string head = word.length() > 0 ? word.substring(0, 1) : "";
escaped,string escaped = "\"";
cp,int cp = ch.toCodePointInt();
bytes,byte[] bytes = ch.toBytes();
result,string result = "";
hex,string hex = cp.toHexString().toUpperAscii();
ptrTy,Type ptrTy = ptr.ty;
resultType,Type resultType = ptr.ty;
resultAddressSpace,int resultAddressSpace = 0;
i,int i;
indexTy,Type indexTy = index.ty;
result,string result = "c\"";
hex,string hex = b.toHexString().toUpperAscii();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g,ConstPointerValue g = m.addGlobal("i64", "g", initializer=context.constInt("i64", 5), addressSpace=1, linkage="internal");
a,ConstPointerValue a = m.addAlias("i64", g, "a", addressSpace=1);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
retVal,Value retVal = builder.load(a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: ["i8"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
a,Value a = foo.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,Value const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
const2,Value const2 = context.constStruct([context.constInt("i64", 3), context.constInt("i64", 4)]);
const2Ty,Type const2Ty = structType(["i64", "i64"]);
const3,Value const3 = context.constStruct([const1, const2]);
const3Ty,Type const3Ty = structType([const1Ty, const2Ty]);
testTy,FunctionType testTy = {returnType: const1Ty, paramTypes: []};
test,FunctionDefn test = m.addFunctionDefn("test", testTy);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
test2,FunctionDefn test2 = m.addFunctionDefn("test2", {returnType: const3Ty, paramTypes: []});
initBlock2,BasicBlock initBlock2 = test2.appendBasicBlock();
constFnStruct,Value constFnStruct = context.constStruct([test]);
constFnStructTy,Type constFnStructTy = structType([pointerType(testTy)]);
test3,FunctionDefn test3 = m.addFunctionDefn("test3", {returnType:constFnStructTy, paramTypes: []});
bb,BasicBlock bb = test3.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
sub,FunctionDecl sub = m.getIntrinsicDeclaration("ssub.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(sub, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
fnTy,FunctionType fnTy = functionType(structTy, [structTy, "i64"]);
notUsed,StructType notUsed = context.structCreateNamed("notUsed");
g,ConstPointerValue g = m.addGlobal(structTy, "g");
foo,FunctionDefn foo = m.addFunctionDefn("foo", { returnType: structTy, paramTypes: [] });
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", { returnType: "void", paramTypes: [structTy] });
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
p2,Value p2 = test.getParam(2);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
temp1,Value temp1 = builder.iArithmeticWrap("add",p0, p1);
temp2,Value temp2 = builder.iArithmeticWrap("add",temp1, p2);
test2,FunctionDecl test2 = m.addFunctionDecl("test2", {returnType:"i64", paramTypes:["i64", "i64", "i64"]});
context,Context context = new;
m,Module m = context.createModule();
fnTy,FunctionType fnTy = functionType("i64", ["i8", "i64"]);
otherFnTy,FunctionType otherFnTy = functionType("i8", ["i64"]);
otherFnPtrTy,PointerType otherFnPtrTy = pointerType(otherFnTy, 0);
fn,FunctionDecl fn = m.addFunctionDecl("otherFn", otherFnTy);
fnPointerTy,PointerType fnPointerTy = pointerType(fnTy, 0);
structTy,StructType structTy = structType(["i32", fnPointerTy]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bar,FunctionDecl bar = m.addFunctionDecl("bar",{returnType:"i64", paramTypes:["i64"]});
barVoid,FunctionDecl barVoid = m.addFunctionDecl("barVoid", {returnType:"void", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R_1,Value? R_1 = builder.call(bar, [context.constInt("i64", 0)]);
R1,Value R1;
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
g1Ty,StructType g1Ty = structType(["i64", "i32", "i8"]);
g1,ConstPointerValue g1 = m.addGlobal(g1Ty, "g1", isConstant=true);
init,ConstValue init = context.constGetElementPtr(g1, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
g2,ConstPointerValue g2 = m.addGlobal(pointerType("i64", 0), "g2", initializer=init);
init2,ConstValue init2 = context.constBitCast(g2, pointerType("i32", 0));
g4,ConstPointerValue g4 = m.addGlobal(pointerType("i32", 0), "g4", isConstant=true);
init3,ConstValue init3 = context.constAddrSpaceCast(g4, pointerType("i32", 1));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64",paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
m,Module m = basicMain();
output,Output output = new ();
outputPath,string outputPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", "tmp.ll");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: ["i64"]});
foo1BB,BasicBlock foo1BB = foo1.appendBasicBlock();
R2,PointerValue R2 = builder.alloca("i64");
R0,Value R0 = foo1.getParam(0);
R3,Value R3 = builder.load(R2);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: ["i64", "i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
R5,Value R5 = builder.load(R4);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,PointerValue R6 = builder.alloca("i64");
R0,Value R0 = foo3.getParam(0);
R1,Value R1 = foo3.getParam(1);
R2,Value R2 = foo3.getParam(2);
R7,Value R7 = builder.load(R6);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.bitCast(arg, pointerType("i64"));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: []});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
c,Value c = context.constInt("i64",42);
R2,Value R2 = builder.load(R1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.ptrToInt(arg, "i64");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
V1,Value V1 = builder.ptrToInt(arg, "i1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
strContent,byte[] strContent ="abc123#@% \n\\\"".toBytes();
str,Value str = context.constString(strContent);
strFn,FunctionDefn strFn = m.addFunctionDefn("test", {returnType: arrayType("i8", strContent.length()), paramTypes: []});
initBlock,BasicBlock initBlock = strFn.appendBasicBlock();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
expectedPath,string expectedPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", expectedFilename);
expectedLines,string[] expectedLines = check io:fileReadLines(expectedPath);
expectedOutput,string expectedOutput = "\n".'join(...expectedLines);
mod,Module mod = func();
actualOutput,string actualOutput = mod.printModuleToString();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i32", 1)]);
v1,PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i32", 0), context.constInt("i32", 2)]);
v2,PointerValue v2 = builder.getElementPtr(v1, [context.constInt("i32", 0), context.constInt("i32", 1)]);
v3,PointerValue v3 = builder.getElementPtr(v2, [context.constInt("i64", 0), context.constInt("i64", 5)]);
arrTy3,Type arrTy3 = arrayType(pointerType("i64", 1), 10);
rtTy2,Type rtTy2 = structType([ "i32", arrTy3, "i32" ]);
stTy2,Type stTy2 = structType(["i8", "i8", rtTy2]);
g2,PointerValue g2 = m.addGlobal(stTy2, "g2");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType(pointerType("i64",1)), paramTypes: []});
t0,PointerValue t0 = builder.getElementPtr(g2, [context.constInt("i32", 1),context.constInt("i32", 2), context.constInt("i32", 1), context.constInt("i32", 4)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0),context.constInt("i64", 1)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
g2,PointerValue g2 = m.addGlobal("i32", "g2");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v1,Value v1 = builder.ptrToInt(g2, "i32");
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0), v1]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,Type structTy = structType(["i64", "i64"]);
arrTy,Type arrTy = arrayType(structTy, 10);
g1,PointerValue g1 = m.addGlobal(arrTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i64", 10)]);
v1,error|PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i64", 10)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="test", linkageName="test", file=fileData, lineNo=0, ty=functionTy, scopeLine=0);
loc,Metadata loc = dIBuilder.createDebugLocation(1, 2, functionData);
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "void", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
v0,Value v0 = foo.getParam(0);
v1,Value v1 = foo.getParam(1);
a,Value a = builder.iArithmeticNoWrap("add", v0, v1);
b,Value b = builder.iArithmeticNoWrap("sub", v0, v1);
c,Value c = builder.iArithmeticNoWrap("mul", a, b);
context,Context context = new;
m,Module m = context.createModule();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,Value R6 = builder.load(R5);
R7,Value R7 = builder.iCmp("eq", R6, context.constInt("i64", 0));
bb8,BasicBlock bb8 = foo.appendBasicBlock();
bb9,BasicBlock bb9 = foo.appendBasicBlock();
R10,Value R10 = builder.load(R4);
R11,Value R11 = builder.iCmp("eq", R10, context.constInt("i64", int:MIN_VALUE));
bb16,BasicBlock bb16 = foo.appendBasicBlock();
bb12,BasicBlock bb12 = foo.appendBasicBlock();
R13,Value R13 = builder.load(R5);
R14,Value R14 = builder.iCmp("eq", R13, context.constInt("i64", -1));
bb15,BasicBlock bb15 = foo.appendBasicBlock();
bb20,BasicBlock bb20 = foo.appendBasicBlock();
R17,Value R17 = builder.load(R4);
R18,Value R18 = builder.load(R5);
R19,Value R19 = builder.iArithmeticSigned("srem", R17, R18);
R21,Value R21 = builder.load(R3);
fn,FunctionDefn fn = m.addFunctionDefn(name, {returnType: "i1", paramTypes: ["double", "double"]});
bb,BasicBlock bb = fn.appendBasicBlock();
p0,Value p0 = fn.getParam(0);
p1,Value p1 = fn.getParam(1);
res,Value res = builder.fCmp(predicate, p0, p1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "double", paramTypes: ["double", "double"]});
initBlock,BasicBlock initBlock = bar.appendBasicBlock();
v0,Value v0 = bar.getParam(0);
v1,Value v1 = bar.getParam(1);
a,Value a = builder.fArithmetic("fadd", v0, v1);
b,Value b = builder.fArithmetic("fsub", v0, v1);
c,Value c = builder.fArithmetic("fmul", a, b);
d,Value d = builder.fArithmetic("fdiv", c, a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
add,FunctionDecl add = m.getIntrinsicDeclaration("sadd.with.overflow.i64.i64");
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(add, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["double"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
neg,Value neg = builder.fNeg(p0);
context,Context context = new;
m,Module m = context.createModule();
mul,FunctionDecl mul = m.getIntrinsicDeclaration("smul.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(mul, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDecl bar = m.addFunctionDecl("bar", {returnType: "void", paramTypes: []});
bar2,FunctionDecl bar2 = m.addFunctionDecl("bar2", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bbfoo,BasicBlock bbfoo = foo.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bbfoo2,BasicBlock bbfoo2 = foo2.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,ConstValue const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
g,PointerValue g = m.addGlobal("i64", "g1");
g2,PointerValue g2 = m.addGlobal("i64", "g2", addressSpace=2);
g7,ConstPointerValue g7 = m.addGlobal(const1Ty, "g7");
testFn,FunctionDefn testFn = m.addFunctionDefn("testFn", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = testFn.appendBasicBlock();
val1,Value val1 = builder.ptrToInt(g, "i64");
val2,Value val2 = builder.ptrToInt(g2, "i64");
ret,Value ret = builder.iArithmeticWrap("add", val1, val2);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "g1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i8", 1), paramTypes: [pointerType("i8", 1)]});
mask,FunctionDecl mask = m.getIntrinsicDeclaration("ptrmask.p1.i64");
bb,BasicBlock bb = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
result,Value? result = builder.call(mask, [arg, context.constInt("i64",72057594037927928)]);
overflowArithmeticReturnType,StructType overflowArithmeticReturnType = structType(["i64", "i1"]);
overflowArithmeticFunctionType,FunctionType overflowArithmeticFunctionType = {returnType: overflowArithmeticReturnType, paramTypes: ["i64", "i64"]};
context,Context context = new;
m,Module m = context.createModule();
names,IntrinsicFunctionName[] names = ["sadd.with.overflow.i64.i64", "ssub.with.overflow.i64.i64", "smul.with.overflow.i64.i64"];
f,FunctionDecl f = m.getIntrinsicDeclaration(name);
functionName,string functionName = "llvm." + name;
context,Context context = new;
m,Module m = context.createModule();
name,IntrinsicFunctionName name = "sadd.with.overflow.i64.i64";
f1,FunctionDecl f1 = m.getIntrinsicDeclaration(name);
f2,FunctionDecl f2 = m.getIntrinsicDeclaration(name);
context,Context context = new;
m,Module m = context.createModule();
attributes,FunctionEnumAttribute[] attributes = ["noreturn", "cold", "nounwind", "readnone", "speculatable", "willreturn"];
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
m,Module m = context.createModule();
attribute,EnumAttribute attribute = "cold";
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["i64", "i32"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
v1,Value v1 = builder.sIToFP(p0, "double");
v2,Value v2 = builder.sIToFP(p1, "double");
ret,Value ret = builder.fArithmetic("fadd", v1, v2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g1,ConstPointerValue g1 = m.addGlobal("i64", "g1");
structTy,StructType structTy = context.structCreateNamed("st");
g2,ConstPointerValue g2 = m.addGlobal(structTy, "g2");
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i32", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "i32", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
d,PointerValue d = new (pointerType("i1"), "d");
e,error? e = trap builder.store(s, d);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.call(f, [s]);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.extractValue(s, 0);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,error? e = trap builder.condBr(s,bb,bb);
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i8", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.trunc(arg, "i8");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: ["i64"]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value|error v1 = trap builder.trunc(arg, "i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
structPtrTy,PointerType structPtrTy = pointerType(structTy);
extFnTy,FunctionType extFnTy = {returnType: "void", paramTypes: [structPtrTy]};
extFnPtrTy,PointerType extFnPtrTy = pointerType(extFnTy);
mainFnTy,FunctionType mainFnTy = {returnType: "void", paramTypes: [structPtrTy]};
mainFn,FunctionDefn mainFn = m.addFunctionDefn("main", mainFnTy);
bb,BasicBlock bb = mainFn.appendBasicBlock();
arg,Value arg = mainFn.getParam(0);
v2,PointerValue v2 = builder.alloca(structPtrTy);
v3,Value v3 = builder.load(v2);
v4,PointerValue v4 = builder.getElementPtr(<PointerValue>v3, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
v5,Value v5 = builder.load(v4);
v6,PointerValue v6 = builder.getElementPtr(<PointerValue>v5, [context.constInt("i64", 1)], "inbounds");
v7,Value v7 = builder.load(v6);
v8,Value v8 = builder.load(v2);
v9,PointerValue v9 = builder.bitCast(<PointerValue>v7, extFnPtrTy);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i64")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.getElementPtr(<PointerValue>arg, [context.constInt("i64", 3)]);
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType("i8"), paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
arg_1,Value arg_1 = bar.getParam(0);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: pointerType("i64", 1), paramTypes: [pointerType("i64", 1)]});
fooBB2,BasicBlock fooBB2 = foo2.appendBasicBlock();
arg_2,Value arg_2 = foo2.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
f1,FunctionDefn f1 = foo1(builder, m);
f2,FunctionDefn f2 = foo2(builder, m);
f3,FunctionDefn f3 = foo3(context, builder, m);
f4,FunctionDefn f4 = foo4(builder, m);
test,FunctionDefn test = m.addFunctionDefn("test", {returnType:"void", paramTypes:[]});
bb5,BasicBlock bb5 = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,Value R3;
R_3,Value|() R_3 = builder.call(f3, []);
R4,Value R4;
R_4,Value|() R_4 = builder.call(f4, [context.constInt("i64", 12), context.constInt("i64", 13)]);
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType:"void", paramTypes:[]});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType:"void", paramTypes:["i64","i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType:"i64", paramTypes:[]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
C1,Value C1 = cx.constInt("i64", 21);
foo4,FunctionDefn foo4 = m.addFunctionDefn("foo4", {returnType:"i64", paramTypes:["i64", "i64"]});
bb4,BasicBlock bb4 = foo4.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo4.getParam(0);
R1,Value R1 = foo4.getParam(1);
R5,Value R5 = builder.load(R4);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
genFn,FunctionDecl genFn = m.addFunctionDecl("genFn", {returnType: pointerType("i64", 3), paramTypes:[]});
pty0,PointerType pty0 = pointerType("i64", 0);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: pty0, paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
val,Value? val = builder.call(genFn, []);
retVal,Value retVal = builder.addrSpaceCast(<PointerValue>val, pty0);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "sadd.with.overflow.i64.i64");
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="main", linkageName="test", file=fileData, lineNo=1, ty=functionTy, scopeLine=0);
tyMeta,Metadata tyMeta = dIBuilder.createBasicType(name="myInt", encoding="signed", sizeInBits=64);
varMeta,Metadata varMeta = dIBuilder.createAutoVariable(ty=tyMeta, scope=functionData, name="myVar", lineNo=2, file=fileData);
bMeta,Metadata bMeta = dIBuilder.createAutoVariable(ty=dIBuilder.createBasicType(name="constInt", encoding="signed", sizeInBits=64), scope=functionData, name="B", lineNo=2, file=fileData);
charMeta,Metadata charMeta = dIBuilder.createBasicType(name="char", encoding="signed_char", sizeInBits=8);
taggedPtrMeta,Metadata taggedPtrMeta = dIBuilder.createTypedef(dIBuilder.createPointerType(pointeeTy=charMeta, sizeInBits=64, addressSpace=1), "TaggedPtr", fileData, 0, scope=fileData);
cMeta,Metadata cMeta = dIBuilder.createAutoVariable(ty=taggedPtrMeta, scope=functionData, name="C", lineNo=2, file=fileData);
emptyExpr,Metadata emptyExpr = dIBuilder.createExpression([]);
bScope,Metadata bScope = dIBuilder.createLexicalBlock(functionData, fileData, 3, 2);
loc1,Metadata loc1 = dIBuilder.createDebugLocation(2, 2, bScope);
loc2,Metadata loc2 = dIBuilder.createDebugLocation(3, 2, functionData);
loc3,Metadata loc3 = dIBuilder.createDebugLocation(4, 2, functionData);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
a,PointerValue a = builder.alloca("i64");
b,PointerValue b = builder.alloca("i64");
c,PointerValue c = builder.alloca(pointerType("i8", 1));
initA,Value initA = context.constInt("i64", 10);
retVal,Value retVal = builder.iArithmeticWrap("add", builder.load(a), context.constInt("i64", 1));
context,Context context = new;
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "void", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
builder,Builder builder = context.createBuilder();
fn,FunctionDefn fn = m.addFunctionDefn(fnName, {returnType: "double", paramTypes: []});
initBlock,BasicBlock initBlock = fn.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
p1,Value p1 = mainFunction.getParam(0);
p2,Value p2 = mainFunction.getParam(1);
v,PointerValue v = builder.alloca("i64");
a,Value a = builder.iArithmeticWrap("add", p1, p2);
greater,BasicBlock greater = mainFunction.appendBasicBlock("greater");
less,BasicBlock less = mainFunction.appendBasicBlock("less");
isGreater,Value isGreater = builder.iCmp("sge", a, context.constInt("i64", 10));
b_1,Value b_1 = builder.iArithmeticWrap("sub", a, context.constInt("i64", 5));
common,BasicBlock common = mainFunction.appendBasicBlock();
b_2,Value b_2 = builder.iArithmeticWrap("add", a, context.constInt("i64", 5));
b_3,Value b_3 = builder.load(v);
context,Context context = new;
m,Module m = context.createModule();
builder,Builder builder = context.createBuilder();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,Value R5 = builder.load(R4);
R6,Value R6 = builder.iCmp("eq", R5, context.constInt("i64", 0));
bb7,BasicBlock bb7 = foo.appendBasicBlock();
bb10,BasicBlock bb10 = foo.appendBasicBlock();
bb13,BasicBlock bb13 = foo.appendBasicBlock();
bb14,BasicBlock bb14 = foo.appendBasicBlock();
R8,Value R8 = builder.load(R3);
R9,Value R9 = builder.iCmp("eq", R8, context.constInt("i64", int:MIN_VALUE));
R11,Value R11 = builder.load(R4);
R12,Value R12 = builder.iCmp("eq", R11, context.constInt("i64", -1));
R15,Value R15 = builder.load(R3);
R16,Value R16 = builder.load(R4);
R17,Value R17 = builder.iArithmeticSigned("sdiv", R15, R16);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
out,string out = typeToString(ty, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
pTy,PointerType pTy = pointerType(ty);
out,string out = typeToString(pTy, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
ty,StructType ty = structType(intTypes);
context,Context context = new;
out,string out = typeToString(ty, context);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
elements,ConstValue[] elements = [context.constInt("i64", 1), context.constInt("i64", 10), context.constInt("i64", 100)];
array,ConstValue array = context.constArray("i64", elements);
retTy,ArrayType retTy = arrayType("i64", 3);
fn,FunctionDefn fn = m.addFunctionDefn("test", {returnType: retTy, paramTypes:[]});
bb,BasicBlock bb = fn.appendBasicBlock();
msg,string msg = "something impossible happened";
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseIntersection(tok);
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
tds,TypeDesc[] tds = [lhs];
opPos,Position[] opPos = [];
right,TypeDesc right = op == "|" ? check parseIntersection(tok) : check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
unary,UnaryTypeDesc unary = { startPos, endPos, op: "!", opPos: startPos, td };
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parsePrimaryTypeDesc(tok);
opPos,Position opPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
optionalTd,UnaryTypeDesc optionalTd = { startPos, endPos, op: "?", opPos, td };
dimensions,SimpleConstExpr?[] dimensions = [];
endPos,Position? endPos = ();
array,ArrayTypeDesc array = { startPos, endPos: <Position>endPos, member: td , dimensions };
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
pos,Position pos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
constituent,TypeDesc constituent = check parseTypeParam(tok);
endPos,Position endPos = tok.currentEndPos();
rest,var rest = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
detail,var detail = check parseTypeParam(tok);
row,TypeDesc row = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
prefix,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
typeName,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
valueExpr,SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);
td,TypeDesc td = check parseTypeDesc(tok);
startPos,Position startPos = tok.currentStartPos();
params,FunctionTypeParam[] params = namedParams ?: [];
paramStartPos,Position paramStartPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
ret,TypeDesc? ret = ();
t,Token? t = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
members,TypeDesc[] members = [];
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
rest,TypeDesc? rest = ();
td,TypeDesc td = check parseTypeDesc(tok);
fields,FieldDesc[] fields = [];
rest,TypeDesc? rest = ();
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
fields,FieldDesc[] fields = [];
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
name,string name = check tok.expectIdentifier();
endPos,Position endPos = check tok.expectEnd(";");
importDecls,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
moduleLevelDefns,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);
org,string? org = decl.org;
prefix,string? prefix = decl.prefix;
nameNodes,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
td,SubsetBuiltinTypeDesc? td = defn.td;
name,string? name = param.name;
body,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
name,string? name = stmt.name;
returnExpr,Expr? returnExpr = stmt.returnExpr;
lValue,LExpr|WILDCARD lValue = stmt.lValue;
ifFalse,StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;
clauses,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
childNodes,SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];
prefix,string? prefix = expr.prefix;
prefix,string? prefix = expr.prefix;
identifierPos,Position? identifierPos = prefix == () ? expr.qNamePos : ();
token,string token;
typeSuffix,FpTypeSuffix? typeSuffix = expr.typeSuffix;
op,BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;
memberNodes,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
rest,TypeDesc? rest = td.rest;
dimensions,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
rest,TypeDesc|INCLUSIVE_RECORD_TYPE_DESC? rest = td.rest;
fields,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
params,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
retTd,TypeDesc? retTd = td.ret;
prefix,string? prefix = td.prefix;
childNodes,SubSyntaxNode[] childNodes = [{ token: td.op, pos: td.startPos }, syntaxNodeFromTypeDesc(td.td)];
token,string token;
valueExpr,ExtendedLiteralExpr valueExpr = td.valueExpr;
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList(nodes);
newNodes,SubSyntaxNode[] newNodes = [];
nodes,SubSyntaxNode[] nodes = [];
words,Word[] words = [];
childNodes,SubSyntaxNode[] childNodes = node.childNodes;
flags,OutputFlags flags = terminalSyntaxNodeFlags(child, node);
parent,AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();
name,string name = parent is FunctionCallExpr ? parent.funcName : parent.methodName;
astNode,AstNode astNode = node.astNode;
chunks,string[] chunks = ["\""];
Char,string:Char? singleEscaped = REVERSE_ESCAPES[ch];
cp,int cp = ch.toCodePointInt();
parts,string[] parts = [];
lines,string[] lines = [];
skipSpace,boolean skipSpace = true;
ignoreNewLine,boolean ignoreNewLine = false;
indentSize,int indentSize = 0;
token,Word token = words[i];
nextToken,Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();
lastLine,string lastLine = string
filteredLines,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
content,string[] content = [];
Char,:Char?[] { string:Char?[] fragFixed = [];
ft,FixedToken?[] ft = [];
s,string s = checkpanic string
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragments,readonly & string[] fragments = line.fragments;
fragCodeIndex,int fragCodeIndex = 0;
fragmentIndex,int fragmentIndex = 0;
i,int i = 0;
code,FragCode code = fragCodes[fragCodeIndex];
ft,FixedToken? ft = fragTokens[<int>code];
lineContent,string[] lineContent = [];
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragmentIndex,int fragmentIndex = 0;
code,FragCode code = fragCodes[fragCodeIndex];
hexDigits,string hexDigits = fragment.substring(3, fragment.length() - 1);
codePoint,int codePoint = check int
:Char,string:Char
result,ScannedLine[] result = from var l in lines select scanLine(l);
codePoints,int[] codePoints = line.toCodePointInts();
fragCodes,FragCode[] fragCodes = [];
endIndex,int[] endIndex = [];
fragments,string[] fragments;
nVarFragments,int nVarFragments = 0;
fragments,string[] fragments = [];
startIndex,int startIndex = 0;
lines,string[] lines = [];
i,int i = 0;
lineStartIndex,int lineStartIndex = 0;
cr,int? cr = ();
len,final int len = codePoints.length();
i,int i = startIndex;
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i);
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
startResultLength,final int startResultLength = result.fragCodes.length();
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanNumericEscape(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = scanOptDigits(codePoints, startIndex);
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i + 1);
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
ei,int[] ei = result.endIndex;
len,int len = ei.length();
startIndex,int startIndex = len > 0 ? ei[len - 1] : 0;
ki,int? ki = keywordIndex(codePoints, startIndex, i);
kw,string kw = checkpanic string
fc,FragCode[] fc = result.fragCodes;
len,int len = fc.length();
len,int len = codePoints.length();
cp,int cp = codePoints[i];
startPos,Position startPos = tok.currentStartPos();
stmts,Stmt[] stmts = [];
endPos,Position endPos = tok.currentEndPos();
closeBracePos,Position closeBracePos = tok.currentStartPos();
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
peeked,var peeked = tok.peek(skipQualIdent=true);
td,TypeDesc td = check parseTypeDesc(tok);
isTypeDesc,boolean isTypeDesc = check savePreparseRestore(tok, preparseArrayTypeDesc);
endPos,Position endPos = check tok.expectEnd(";");
stmt,BreakContinueStmt stmt = { startPos, endPos, breakContinue:<BreakContinue>cur };
peeked,var peeked = tok.peek();
state,TokenizerState state = tok.save();
isTypeDesc,boolean isTypeDesc = check func(tok);
name,string name;
prefix,string? prefix;
expr,FunctionCallExpr expr = check finishFunctionCallExpr(tok, prefix, name, startPos);
endPos,Position endPos = tok.previousEndPos();
lExpr,LExpr lExpr = { startPos, endPos, name, qNamePos: startPos, prefix };
cur,Token? cur = tok.current();
opPos,Position opPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check startPrimaryExpr(tok);
cur,Token? cur = tok.current();
endPos,Position endPos = check tok.expectEnd(";");
primary,Expr primary = check finishPrimaryExpr(tok, expr, startPos);
endPos,Position endPos = check tok.expectEnd(";");
stmt,CallStmt stmt;
t,Token? t = tok.current();
innerKwPos,Position innerKwPos = tok.currentStartPos();
operandStmt,CallStmt operandStmt = check finishCheckingCallStmt(tok, t, innerKwPos);
operandStmt,CallStmt operandStmt = check parseMethodCallStmt(tok);
operand,Expr operand = check parsePrimaryExpr(tok);
expr,CheckingCallExpr expr = { startPos: kwPos, endPos: operand.endPos, checkingKeyword, kwPos, operand};
endPos,Position endPos = check tok.expectEnd(";");
opPos,Position opPos = tok.currentStartPos();
expr,Expr expr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
stmt,AssignStmt stmt = { startPos, endPos, opPos, lValue, expr };
opStr,string opStr = op;
binOp,BinaryArithmeticOp|BinaryBitwiseOp binOp = <BinaryArithmeticOp|BinaryBitwiseOp> opStr.substring(0, opStr.length() - 1);
stmt,CompoundAssignStmt stmt = { startPos, endPos, opPos, lValue, expr, op: binOp };
td,TypeDesc td = check parseTypeDesc(tok);
cur,Token? cur = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string|WILDCARD name;
opPos,Position opPos = check tok.expectStart("=");
initExpr,Expr initExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
returnExpr,Expr? returnExpr;
endPos,Position endPos;
panicExpr,Expr panicExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
ifFalse,IfElseStmt|StmtBlock? ifFalse;
condition,Expr condition = check parseExpr(tok);
ifTrue,StmtBlock ifTrue = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
cur,Token? cur = tok.current();
ifFalseStartPos,Position ifFalseStartPos = tok.currentStartPos();
condition,Expr condition = check parseExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
kwPos,Position kwPos = check tok.expectStart("in");
range,RangeExpr range = check parseRangeExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
expr,Expr expr = check parseInnerExpr(tok);
clauses,MatchClause[] clauses = [];
endPos,Position endPos = tok.currentEndPos();
startPos,Position startPos = tok.currentStartPos();
patterns,MatchPattern[] patterns = check parseMatchPatternList(tok);
opPos,Position opPos = check tok.expectStart("=>");
block,StmtBlock block = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
patterns,MatchPattern[] patterns = [];
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
parenResult,boolean? parenResult = check preparseBracketed(tok, close);
t,Token? t = tok.current();
squareResult,boolean? squareResult = check preparseBracketed(tok, "]");
t,Token? t = tok.current();
result,boolean? result = check preparseBracketed(tok, closeBracketMap.get(<string>t));
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
members,var [members, _] = check parseExprList(tok, "]");
endPos,Position endPos = tok.previousEndPos();
expr,ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };
fields,Field[] fields = check parseFields(tok);
endPos,Position endPos = tok.previousEndPos();
expr,MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseLogicalAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseLogicalAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseOrExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseOrExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseXorExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseXorExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseEqualityExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseEqualityExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseRelationalExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseRelationalExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseShiftExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseShiftExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };
t2,Token? t2 = tok.current();
kwPos,Position kwPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
lower,Expr lower = check parseAdditiveExpr(tok);
opPos,Position opPos = check tok.expectStart("..<");
upper,Expr upper = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseAdditiveExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
shift,BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseMultiplicativeExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseMultiplicativeExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseUnaryExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };
kwPos,Position kwPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };
opPos,Position opPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,TypeCastExpr expr = { startPos, endPos, opPos, td, operand };
startPos,Position startPos = tok.currentStartPos();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,string? prefix;
name,string name;
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };
expr,FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: () };
innerExpr,Expr innerExpr = check parseInnerExpr(tok);
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
expr,LiteralExpr expr = { startPos, endPos, value: () };
kwPos,Position kwPos = tok.currentStartPos();
message,Expr message = check parseExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
accessEndPos,Position accessEndPos = check tok.expectEnd("]");
accessExpr,MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };
qnamePos,Position qnamePos = tok.currentStartPos();
name,string name = check parseIdentifierOrMethodName(tok);
endPos,Position endPos = tok.previousEndPos();
fieldAccessExpr,FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };
t,Token? t = tok.current();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
exprs,Expr[] exprs = [];
expr,Expr expr = check parseExpr(tok);
t,Token? t = tok.current();
closeTerminatorPos,Position closeTerminatorPos = tok.currentStartPos();
fields,Field[] fields = [];
f,Field f = check parseField(tok);
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
isIdentifier,boolean isIdentifier = t[0] == IDENTIFIER;
name,string name = t[1];
colonPos,Position colonPos = tok.currentStartPos();
value,Expr value = check parseExpr(tok);
endPos,Position endPos = tok.previousEndPos();
f,Field f = { startPos, endPos, colonPos, name, value, isIdentifier };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = check tok.expectEnd(")");
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
name,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
untypedLiteral,, var untypedLiteral
typeSuffix,, var typeSuffix] => { Position
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits };
:fromHexString,: int:fromHexString(digits);
tok,Tokenizer tok = new(self.tokState.file);
tok,Tokenizer tok = new (file);
tok,Tokenizer tok = scanned.tokenizer();
defns,ModuleLevelDefn[] defns = [];
part,ModulePart part = { file: scanned.sourceFile(), partIndex: scanned.partIndex, defns, importDecls: scanned.importDecls };
tok,Tokenizer tok = new (file);
expr,Expr expr = check parseExpr(tok);
imports,ImportDecl[] imports = [];
t,Token? t = tok.current();
im,ImportDecl im = check parseImportDecl(tok, partIndex);
startPos,Position startPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
firstModuleName,string firstModuleName = check validImportPart(tok);
org,string? org = ();
names,[string, string...] names = [firstModuleName];
prefix,string? prefix = check parseImportPrefix(tok);
endPos,Position endPos = check tok.expectEnd(";");
names,string[] names = [];
identifier,string identifier = check tok.expectIdentifier();
prevChar,string? prevChar = ();
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
vis,Visibility vis;
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = check tok.expectEnd(";");
t,Token? t = tok.current();
td,SubsetBuiltinTypeDesc? td = ();
tdStartPos,Position tdStartPos = tok.currentStartPos();
tdEndPos,Position tdEndPos = tok.currentEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
expr,Expr expr = check parseInnerExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
params,FunctionParam [] params = [];
typeDesc,FunctionTypeDesc typeDesc = check parseFunctionTypeDesc(tok, params);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
defn,FunctionDefn defn = { startPos, endPos, params, typeDesc, name, vis, namePos, body, part };
message,string message = "parse error";
t,Token? t = tok.current();
str,string str = "";
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
fragment,string fragment = self.getFragment();
ch,string|error ch = unicodeEscapeValue(fragment);
number,string number = self.getFragment();
number,string number = self.getFragment();
ft,FixedToken? ft = fragTokens[<int>fragCode];
fragCodes,readonly & FragCode[] fragCodes = self.fragCodes;
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
lineIndex,int lineIndex = self.lineIndex;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
i,int i = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
nextFragCode,FragCode nextFragCode = fragCodes[i];
lineIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
codePointIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragment,string fragment = self.fragments[self.fragmentIndex];
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex];
t,Token? t = self.curTok;
msg,d:Message msg;
pos,Position pos = self.currentEndPos();
pos,Position pos = self.currentStartPos();
msg,d:Message msg;
t,Token? t = self.curTok;
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex - 1];
startPos,Position startPos;
endPos,Position? endPos;
startLineNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(startLineNum);
lineFragments,string[] lineFragments = scanLineFragments(line);
lineContent,string lineContent = "".'join(...lineFragments);
endColumnNum,int endColumnNum;
endLineNum,int endLineNum;
lineNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(lineNum);
endColumnNum,int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragments,string[] fragments = line.fragments;
fragCodes,FragCode[] fragCodes = line.fragCodes;
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragmentIndex,int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);
nCodePoints,int nCodePoints = 0;
fragmentIndex,int fragmentIndex = 0;
nFragments,int nFragments = fragments.length();
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragCode,FragCode fragCode = fragCodes[fragmentIndex];
file,SourceFile file = createSourceFile([str], { filename: "<internal>" });
tok,Tokenizer tok = new(file);
left,Identifier|TypeProjection left = check parseTypeProjection(tok);
t,Token? t = tok.current();
op,SubtypeTestOp op;
right,Identifier|TypeProjection right = check parseTypeProjection(tok);
identifier,Identifier identifier = check tok.expectIdentifier();
t,Token? t = tok.current();
index,int|Identifier index;
actualNode,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
normalizedActualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
actualNodeLines,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
node,SyntaxNode node;
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
t,err:Syntax|Token? t = advance(tok, k, lines);
lc,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
src,string src = lines[lc[0] - 1];
tStart,int tStart = lc[1];
tStr,string tStr = tokenToString(t);
srcAtPos,string srcAtPos = src.substring(tStart, tStart + tStr.length());
e,err:Syntax? e = tok.advance();
all,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
invalidCases,int invalidCases = all.length();
valid,map<ParserTestCase> valid = check readParserTests();
sources,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
tests,map<TokenizerTestCase> tests = {};
tests,map<ParserTestCase> tests = {};
testData,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
expected,string[] expected;
subject,string subject = s[2];
subjectLines,string[] subjectLines = splitIntoLines(subject);
rule,string rule = s[1];
testFiles,var testFiles = check file:readDir("modules/front.syntax/tests/data");
path,string path = f.absPath;
base,string base = check file:basename(path);
src,string[] src = check readCase(path);
parentDir,string parentDir = check file:parentPath(path);
canonFile,string canonFile = check file:joinPath(parentDir, canonFileName(base));
expected,string[] expected;
baseParts,[Kind, string] baseParts = check splitTestName(base);
rule,string rule = baseParts[1];
len,int len = base.length();
kindPos,int kindPos = base.indexOf("-") ?: 0;
kind,string kind = base.substring(0, kindPos);
afterKindPos,int afterKindPos = min(kindPos + 1, len);
rulePos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
rule,string rule = base.substring(afterKindPos, rulePos);
lines,string[] lines = check io:fileReadLines(path);
caseLines,string[] caseLines = [];
inCase,boolean inCase = false;
indented,int indented = 0;
trimLine,string trimLine = line.trim();
sansExt,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
baseTestDir,string baseTestDir = check file:joinPath(baseDir, testDir);
transformedTestDir,string transformedTestDir = check file:joinPath(transformedDir, testDir);
skipped,TestDiffResult[] skipped = [];
changed,TestDiffResult[] changed = [];
unchanged,TestDiffResult[] unchanged = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
baseTestFile,string baseTestFile = check file:joinPath(baseTestDir, test);
transformedTestFile,string transformedTestFile = check file:joinPath(transformedTestDir, test);
baseTests,TestCase[] baseTests = check parseTests(baseTestFile);
transformedTests,TestCase[] transformedTests = check parseTests(transformedTestFile);
lines,string[] lines = check io:fileReadLines(path);
content,string[] content = [];
description,string description = "";
tests,TestCase[] tests = [];
s,State s = CONTENT;
baseIndex,int baseIndex = 0;
transformedIndex,int transformedIndex = 0;
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
baseDescription,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
baseContent,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
transformedDescription,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
transformedContent,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
body,string[] body = [];
currentPath,string currentPath = "";
path,string path = diff.base.path;
currentPath,string currentPath = "";
path,string path = diff.base.path;
parts,string[] parts = check file:splitPath(absPath);
skipList,string? skipList = opts.skipList;
skipLabels,string[][] skipLabels = skipList != () ? check parseSkipList(skipList) : [];
skipped,int skipped = 0;
total,int total = 0;
tests,BaltTestCase[] tests = check parseTest(path);
parts,string[] parts = check file:splitPath(path);
filename,string filename = parts[parts.length() - 1];
dir,string dir = parts[parts.length() - 2];
testCases,BaltTestCase[] testCases = [];
lines,string[] lines = check io:fileReadLines(path);
header,string[] header = [];
labels,string[] labels = [];
content,string[] content = [];
useIoLib,boolean useIoLib = false;
s,State s = BOF;
fBody,var [_, fBody] = parseField(line);
contentLine,var [contentLine, newLabels] = transformContent(line);
newLabels,var [contentLine, newLabels] = transformContent(line);
newContent,string[] newContent = ["import ballerina/io;"];
newLabels,string[] newLabels = [];
initFunc,string initFunc = "function init()";
newLine,string newLine;
starIndex,int? starIndex = line.indexOf("{");
endIndex,int? endIndex = line.indexOf("}");
targetIndex,int targetIndex = <int>line.indexOf("?;");
i,int? i = s.indexOf(":");
fieldName,string fieldName = s.substring(0, i);
fieldValue,string fieldValue = s.substring(i + 1);
labels,string[] labels = [];
content,string[] content = [];
body,string[] body = [];
skipped,int skipped = 0;
index,int index = 0;
skipIndices,int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];
skipTest,boolean skipTest = false;
outputFileName,string outputFileName = string `./tests/${dir}/${filename}`;
invalid,boolean invalid = true;
tc,t:Context tc = mod.getTypeContext();
numBlocks,int numBlocks = self.blocks.length();
vc,VerifyContext vc = new(mod, defn);
entry,Label entry = 0;
cx,VerifyCodeContext cx = check vc.verifyCodeContext(code);
params,RegSet params = check verifyParamRegs(vc, code.registers);
block,BasicBlock block = cx.blocks[current];
term,Insn term = check blockTerminator(cx, block, predPos);
termPos,Position termPos = term.pos;
onPanic,Label? onPanic = block.onPanic;
cycle,boolean cycle = cx.preds[child];
fid,int fid = cx.fwdInDegrees[child];
i,int i = 0;
insns,Insn[] insns = cx.blocks[i].insns;
paramRegs,RegSet paramRegs = [];
afterParams,boolean afterParams = false;
block,BasicBlock block = cx.blocks[current];
flows,RegFlow[] flows = cx.blocksFlows[current];
regs,RegSet regs = mergeFlows(flows);
afterMerge,boolean afterMerge = false;
operands,| var { args: operands }
onPanic,Label? onPanic = block.onPanic;
term,Insn term = check blockTerminator(cx, block, viaPos);
termPos,Position termPos = term.pos;
trueRegs,RegSet trueRegs = regs.clone();
falseRegs,RegSet falseRegs = regs;
numFlows,int numFlows = flows.length();
i,int i = 0;
flow,RegFlow? flow = flowOriginating(flows, pred);
insns,Insn[] insns = block.insns;
insnsLen,int insnsLen = insns.length();
result,RegSet result = [];
numReg,int numReg = flow[0].regs.length();
conj,boolean conj = true;
name,string name = insn.name;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.result);
union,t:SemType union = t:NEVER;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.operand);
func,FunctionRef func = <FunctionRef>insn.func;
sig,FunctionSignature sig = func.signature;
nSuppliedArgs,int nSuppliedArgs = insn.args.length();
nExpectedArgs,int nExpectedArgs = sig.paramTypes.length();
name,string name = vc.symbolToString(func.symbol);
ty,t:SemType ty = insn.result.semType;
lat,t:ListAtomicType? lat = t:listAtomicType(vc.typeContext(), ty);
operands,Operand[] operands = insn.operands;
ty,t:SemType ty = insn.result.semType;
mat,t:MappingAtomicType? mat = t:mappingAtomicType(vc.typeContext(), ty);
indexOperand,IntOperand indexOperand = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, indexOperand.semType);
i,IntOperand i = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, insn.operands[1].semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInner(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
lhs,Operand lhs = insn.operands[0];
rhs,Operand rhs = insn.operands[1];
label,int label = code.blocks.length();
bb,BasicBlock bb = { label, name };
r,VarRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,FinalRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,NarrowRegister r = { number: code.registers.length(), underlying, semType, pos };
r,ParamRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,TmpRegister r = { number: code.registers.length(), semType, pos, name };
r,AssignTmpRegister r = { number: code.registers.length(), semType, pos, name };
isNamed,boolean isNamed = ty.name != ();
elementTypes,Type[] elementTypes = ty.elementTypes;
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
words,string[] words = [];
operand,string operand = concat(...words);
structBody,string[] structBody = [];
elemTypes,Type[] elemTypes = [];
element,final Value element = elements[i];
structTy,Type structTy = structType(elemTypes);
ty,ArrayType ty = arrayType(elementType, values.length());
body,string[] body = ["["];
element,final ConstValue element = values[i];
ty,ArrayType ty = arrayType("i8", bytes.length());
val,ConstValue val = new(ty, charArray(bytes));
words,string[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self);
words,string[] words = [];
words,string[] words = [];
structName,string structName = "%" + escapeIdent(name);
ty,StructType ty = { elementTypes: [], name: structName };
tyName,string? tyName = namedStructTy.name;
valRep,string valRep;
data,var data = entry[1];
words,string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)];
tyName,string? tyName = ty.name;
data,var data = self.namedStructTypes[tyName];
dIBuilder,DIBuilder dIBuilder = new(self, self.context);
metadata,Metadata metadata = self.addMetadata();
preambleWords,string[] preambleWords = [];
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDefn fn = new (self.context, fnName, fnType);
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDecl fn = new(self.context, fnName, fnType);
fnExisting,FunctionDecl? fnExisting = <FunctionDecl?>self.globals[name];
fnExisting,boolean fnExisting = self.globals[name] != ();
fn,FunctionDecl fn = new(self.context, "llvm." + name, fnType);
varName,string varName = self.escapeGlobalIdent(name);
ptrType,PointerType ptrType = pointerType(ty, props.addressSpace);
val,ConstPointerValue val = new ConstPointerValue(ptrType, "@" + varName);
aliasName,string aliasName = self.escapeGlobalIdent(name);
alias,ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);
varName,string varName = escapeIdent(name);
out,Output out = new;
out,Output out = new;
words,string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];
line,string[] line = [alias.operand, "="];
words,string[] words = [];
initializer,var initializer = prop.initializer;
metadata,Metadata metadata = new(self.genMetadataLabel());
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
paramType,final Type paramType = functionType.paramTypes[i];
register,string register = "%" + i.toString();
arg,Value arg = new (paramType, register);
isFirst,boolean isFirst = true;
bbName,string|Unnamed bbName = self.genName(name);
bb,BasicBlock bb = new (self.context, bbName, self);
varName,string varName = name;
count,int count = self.variableNames.get(varName);
newName,string newName = varName + "." + count.toString();
varName,int varName = self.unnamedLabelCount;
reg,string|Unnamed reg = self.genName(name);
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
newLabel,string newLabel = self.nameCounter.toString();
newName,string newName = "%" + self.nameCounter.toString();
newName,string newName = self.nameTranslation[name];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];
name,string? name = props.name;
alignInBits,Alignment? alignInBits = props.alignInBits;
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
encodingToString,string encodingToString = "DW_ATE_" + props.encoding;
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
align,int? align = props.alignInBits;
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
scope,Metadata? scope = props.scope;
file,Metadata? file = props.file;
ty,Metadata? ty = props.ty;
flags,string[] flags = [];
retainedNodes,Metadata retainedNodes = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
typeNode,Metadata typeNode = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "!", "DILocation", "("];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ptrTy,PointerType ptrTy = pointerType(ty);
bb,BasicBlock bb = self.bb();
ty,Type ty = ptr.ty.pointsTo;
reg,string|Unnamed reg = bb.func.genReg(name);
ty,Type ty = ptr.ty.pointsTo;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntegralType ty = sameIntegralType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg, "="];
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valueType,Type valueType = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
insnWords,(string|Unnamed)[] insnWords;
retType,RetType retType;
bb,BasicBlock bb = self.bb();
fnTy,Type fnTy = fn.ty.pointsTo;
fnName,var fnName = fn.operand;
functionName,string functionName = "@" + fn.functionName;
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg];
insnWords,(string|Unnamed)[] insnWords = [];
arg,final Value arg = args[i];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
elementType,Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);
bb,BasicBlock bb = self.bb();
condTy,Type condTy = condition.ty;
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
tem,BasicBlock? tem = self.currentBlock;
chunks,(string|Unnamed)[] chunks = [];
currentChunk,string[] currentChunk = [];
newLines,(string|Unnamed)[][] newLines = [];
newLine,(string|Unnamed)[] newLine = [];
newLine,string[] newLine = [];
outputLine,string outputLine = createLine([concat(...newLine)], INDENT);
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
tyName,string? tyName = ty.name;
elementTypes,Type[] elementTypes = ty.elementTypes;
typeStringBody,string[] typeStringBody = [];
elementType,final Type elementType = elementTypes[i];
typeStringBody,string[] typeStringBody = [];
typeStringBody,string[] typeStringBody = [];
paramType,final Type paramType = ty.paramTypes[i];
elementTypes,Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);
words,string[] words = [];
metadata,Metadata? metadata = fn.metadata;
ty,final Type ty = fn.functionType.paramTypes[i];
parts,string[] parts = [];
lastTail,string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";
head,string head = word.length() > 0 ? word.substring(0, 1) : "";
escaped,string escaped = "\"";
cp,int cp = ch.toCodePointInt();
bytes,byte[] bytes = ch.toBytes();
result,string result = "";
hex,string hex = cp.toHexString().toUpperAscii();
ptrTy,Type ptrTy = ptr.ty;
resultType,Type resultType = ptr.ty;
resultAddressSpace,int resultAddressSpace = 0;
i,int i;
indexTy,Type indexTy = index.ty;
result,string result = "c\"";
hex,string hex = b.toHexString().toUpperAscii();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g,ConstPointerValue g = m.addGlobal("i64", "g", initializer=context.constInt("i64", 5), addressSpace=1, linkage="internal");
a,ConstPointerValue a = m.addAlias("i64", g, "a", addressSpace=1);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
retVal,Value retVal = builder.load(a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: ["i8"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
a,Value a = foo.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,Value const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
const2,Value const2 = context.constStruct([context.constInt("i64", 3), context.constInt("i64", 4)]);
const2Ty,Type const2Ty = structType(["i64", "i64"]);
const3,Value const3 = context.constStruct([const1, const2]);
const3Ty,Type const3Ty = structType([const1Ty, const2Ty]);
testTy,FunctionType testTy = {returnType: const1Ty, paramTypes: []};
test,FunctionDefn test = m.addFunctionDefn("test", testTy);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
test2,FunctionDefn test2 = m.addFunctionDefn("test2", {returnType: const3Ty, paramTypes: []});
initBlock2,BasicBlock initBlock2 = test2.appendBasicBlock();
constFnStruct,Value constFnStruct = context.constStruct([test]);
constFnStructTy,Type constFnStructTy = structType([pointerType(testTy)]);
test3,FunctionDefn test3 = m.addFunctionDefn("test3", {returnType:constFnStructTy, paramTypes: []});
bb,BasicBlock bb = test3.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
sub,FunctionDecl sub = m.getIntrinsicDeclaration("ssub.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(sub, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
fnTy,FunctionType fnTy = functionType(structTy, [structTy, "i64"]);
notUsed,StructType notUsed = context.structCreateNamed("notUsed");
g,ConstPointerValue g = m.addGlobal(structTy, "g");
foo,FunctionDefn foo = m.addFunctionDefn("foo", { returnType: structTy, paramTypes: [] });
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", { returnType: "void", paramTypes: [structTy] });
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
p2,Value p2 = test.getParam(2);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
temp1,Value temp1 = builder.iArithmeticWrap("add",p0, p1);
temp2,Value temp2 = builder.iArithmeticWrap("add",temp1, p2);
test2,FunctionDecl test2 = m.addFunctionDecl("test2", {returnType:"i64", paramTypes:["i64", "i64", "i64"]});
context,Context context = new;
m,Module m = context.createModule();
fnTy,FunctionType fnTy = functionType("i64", ["i8", "i64"]);
otherFnTy,FunctionType otherFnTy = functionType("i8", ["i64"]);
otherFnPtrTy,PointerType otherFnPtrTy = pointerType(otherFnTy, 0);
fn,FunctionDecl fn = m.addFunctionDecl("otherFn", otherFnTy);
fnPointerTy,PointerType fnPointerTy = pointerType(fnTy, 0);
structTy,StructType structTy = structType(["i32", fnPointerTy]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bar,FunctionDecl bar = m.addFunctionDecl("bar",{returnType:"i64", paramTypes:["i64"]});
barVoid,FunctionDecl barVoid = m.addFunctionDecl("barVoid", {returnType:"void", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R_1,Value? R_1 = builder.call(bar, [context.constInt("i64", 0)]);
R1,Value R1;
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
g1Ty,StructType g1Ty = structType(["i64", "i32", "i8"]);
g1,ConstPointerValue g1 = m.addGlobal(g1Ty, "g1", isConstant=true);
init,ConstValue init = context.constGetElementPtr(g1, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
g2,ConstPointerValue g2 = m.addGlobal(pointerType("i64", 0), "g2", initializer=init);
init2,ConstValue init2 = context.constBitCast(g2, pointerType("i32", 0));
g4,ConstPointerValue g4 = m.addGlobal(pointerType("i32", 0), "g4", isConstant=true);
init3,ConstValue init3 = context.constAddrSpaceCast(g4, pointerType("i32", 1));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64",paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
m,Module m = basicMain();
output,Output output = new ();
outputPath,string outputPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", "tmp.ll");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: ["i64"]});
foo1BB,BasicBlock foo1BB = foo1.appendBasicBlock();
R2,PointerValue R2 = builder.alloca("i64");
R0,Value R0 = foo1.getParam(0);
R3,Value R3 = builder.load(R2);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: ["i64", "i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
R5,Value R5 = builder.load(R4);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,PointerValue R6 = builder.alloca("i64");
R0,Value R0 = foo3.getParam(0);
R1,Value R1 = foo3.getParam(1);
R2,Value R2 = foo3.getParam(2);
R7,Value R7 = builder.load(R6);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.bitCast(arg, pointerType("i64"));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: []});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
c,Value c = context.constInt("i64",42);
R2,Value R2 = builder.load(R1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.ptrToInt(arg, "i64");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
V1,Value V1 = builder.ptrToInt(arg, "i1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
strContent,byte[] strContent ="abc123#@% \n\\\"".toBytes();
str,Value str = context.constString(strContent);
strFn,FunctionDefn strFn = m.addFunctionDefn("test", {returnType: arrayType("i8", strContent.length()), paramTypes: []});
initBlock,BasicBlock initBlock = strFn.appendBasicBlock();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
expectedPath,string expectedPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", expectedFilename);
expectedLines,string[] expectedLines = check io:fileReadLines(expectedPath);
expectedOutput,string expectedOutput = "\n".'join(...expectedLines);
mod,Module mod = func();
actualOutput,string actualOutput = mod.printModuleToString();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i32", 1)]);
v1,PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i32", 0), context.constInt("i32", 2)]);
v2,PointerValue v2 = builder.getElementPtr(v1, [context.constInt("i32", 0), context.constInt("i32", 1)]);
v3,PointerValue v3 = builder.getElementPtr(v2, [context.constInt("i64", 0), context.constInt("i64", 5)]);
arrTy3,Type arrTy3 = arrayType(pointerType("i64", 1), 10);
rtTy2,Type rtTy2 = structType([ "i32", arrTy3, "i32" ]);
stTy2,Type stTy2 = structType(["i8", "i8", rtTy2]);
g2,PointerValue g2 = m.addGlobal(stTy2, "g2");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType(pointerType("i64",1)), paramTypes: []});
t0,PointerValue t0 = builder.getElementPtr(g2, [context.constInt("i32", 1),context.constInt("i32", 2), context.constInt("i32", 1), context.constInt("i32", 4)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0),context.constInt("i64", 1)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
g2,PointerValue g2 = m.addGlobal("i32", "g2");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v1,Value v1 = builder.ptrToInt(g2, "i32");
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0), v1]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,Type structTy = structType(["i64", "i64"]);
arrTy,Type arrTy = arrayType(structTy, 10);
g1,PointerValue g1 = m.addGlobal(arrTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i64", 10)]);
v1,error|PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i64", 10)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="test", linkageName="test", file=fileData, lineNo=0, ty=functionTy, scopeLine=0);
loc,Metadata loc = dIBuilder.createDebugLocation(1, 2, functionData);
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "void", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
v0,Value v0 = foo.getParam(0);
v1,Value v1 = foo.getParam(1);
a,Value a = builder.iArithmeticNoWrap("add", v0, v1);
b,Value b = builder.iArithmeticNoWrap("sub", v0, v1);
c,Value c = builder.iArithmeticNoWrap("mul", a, b);
context,Context context = new;
m,Module m = context.createModule();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,Value R6 = builder.load(R5);
R7,Value R7 = builder.iCmp("eq", R6, context.constInt("i64", 0));
bb8,BasicBlock bb8 = foo.appendBasicBlock();
bb9,BasicBlock bb9 = foo.appendBasicBlock();
R10,Value R10 = builder.load(R4);
R11,Value R11 = builder.iCmp("eq", R10, context.constInt("i64", int:MIN_VALUE));
bb16,BasicBlock bb16 = foo.appendBasicBlock();
bb12,BasicBlock bb12 = foo.appendBasicBlock();
R13,Value R13 = builder.load(R5);
R14,Value R14 = builder.iCmp("eq", R13, context.constInt("i64", -1));
bb15,BasicBlock bb15 = foo.appendBasicBlock();
bb20,BasicBlock bb20 = foo.appendBasicBlock();
R17,Value R17 = builder.load(R4);
R18,Value R18 = builder.load(R5);
R19,Value R19 = builder.iArithmeticSigned("srem", R17, R18);
R21,Value R21 = builder.load(R3);
fn,FunctionDefn fn = m.addFunctionDefn(name, {returnType: "i1", paramTypes: ["double", "double"]});
bb,BasicBlock bb = fn.appendBasicBlock();
p0,Value p0 = fn.getParam(0);
p1,Value p1 = fn.getParam(1);
res,Value res = builder.fCmp(predicate, p0, p1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "double", paramTypes: ["double", "double"]});
initBlock,BasicBlock initBlock = bar.appendBasicBlock();
v0,Value v0 = bar.getParam(0);
v1,Value v1 = bar.getParam(1);
a,Value a = builder.fArithmetic("fadd", v0, v1);
b,Value b = builder.fArithmetic("fsub", v0, v1);
c,Value c = builder.fArithmetic("fmul", a, b);
d,Value d = builder.fArithmetic("fdiv", c, a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
add,FunctionDecl add = m.getIntrinsicDeclaration("sadd.with.overflow.i64.i64");
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(add, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["double"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
neg,Value neg = builder.fNeg(p0);
context,Context context = new;
m,Module m = context.createModule();
mul,FunctionDecl mul = m.getIntrinsicDeclaration("smul.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(mul, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDecl bar = m.addFunctionDecl("bar", {returnType: "void", paramTypes: []});
bar2,FunctionDecl bar2 = m.addFunctionDecl("bar2", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bbfoo,BasicBlock bbfoo = foo.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bbfoo2,BasicBlock bbfoo2 = foo2.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,ConstValue const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
g,PointerValue g = m.addGlobal("i64", "g1");
g2,PointerValue g2 = m.addGlobal("i64", "g2", addressSpace=2);
g7,ConstPointerValue g7 = m.addGlobal(const1Ty, "g7");
testFn,FunctionDefn testFn = m.addFunctionDefn("testFn", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = testFn.appendBasicBlock();
val1,Value val1 = builder.ptrToInt(g, "i64");
val2,Value val2 = builder.ptrToInt(g2, "i64");
ret,Value ret = builder.iArithmeticWrap("add", val1, val2);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "g1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i8", 1), paramTypes: [pointerType("i8", 1)]});
mask,FunctionDecl mask = m.getIntrinsicDeclaration("ptrmask.p1.i64");
bb,BasicBlock bb = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
result,Value? result = builder.call(mask, [arg, context.constInt("i64",72057594037927928)]);
overflowArithmeticReturnType,StructType overflowArithmeticReturnType = structType(["i64", "i1"]);
overflowArithmeticFunctionType,FunctionType overflowArithmeticFunctionType = {returnType: overflowArithmeticReturnType, paramTypes: ["i64", "i64"]};
context,Context context = new;
m,Module m = context.createModule();
names,IntrinsicFunctionName[] names = ["sadd.with.overflow.i64.i64", "ssub.with.overflow.i64.i64", "smul.with.overflow.i64.i64"];
f,FunctionDecl f = m.getIntrinsicDeclaration(name);
functionName,string functionName = "llvm." + name;
context,Context context = new;
m,Module m = context.createModule();
name,IntrinsicFunctionName name = "sadd.with.overflow.i64.i64";
f1,FunctionDecl f1 = m.getIntrinsicDeclaration(name);
f2,FunctionDecl f2 = m.getIntrinsicDeclaration(name);
context,Context context = new;
m,Module m = context.createModule();
attributes,FunctionEnumAttribute[] attributes = ["noreturn", "cold", "nounwind", "readnone", "speculatable", "willreturn"];
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
m,Module m = context.createModule();
attribute,EnumAttribute attribute = "cold";
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["i64", "i32"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
v1,Value v1 = builder.sIToFP(p0, "double");
v2,Value v2 = builder.sIToFP(p1, "double");
ret,Value ret = builder.fArithmetic("fadd", v1, v2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g1,ConstPointerValue g1 = m.addGlobal("i64", "g1");
structTy,StructType structTy = context.structCreateNamed("st");
g2,ConstPointerValue g2 = m.addGlobal(structTy, "g2");
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i32", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "i32", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
d,PointerValue d = new (pointerType("i1"), "d");
e,error? e = trap builder.store(s, d);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.call(f, [s]);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.extractValue(s, 0);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,error? e = trap builder.condBr(s,bb,bb);
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i8", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.trunc(arg, "i8");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: ["i64"]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value|error v1 = trap builder.trunc(arg, "i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
structPtrTy,PointerType structPtrTy = pointerType(structTy);
extFnTy,FunctionType extFnTy = {returnType: "void", paramTypes: [structPtrTy]};
extFnPtrTy,PointerType extFnPtrTy = pointerType(extFnTy);
mainFnTy,FunctionType mainFnTy = {returnType: "void", paramTypes: [structPtrTy]};
mainFn,FunctionDefn mainFn = m.addFunctionDefn("main", mainFnTy);
bb,BasicBlock bb = mainFn.appendBasicBlock();
arg,Value arg = mainFn.getParam(0);
v2,PointerValue v2 = builder.alloca(structPtrTy);
v3,Value v3 = builder.load(v2);
v4,PointerValue v4 = builder.getElementPtr(<PointerValue>v3, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
v5,Value v5 = builder.load(v4);
v6,PointerValue v6 = builder.getElementPtr(<PointerValue>v5, [context.constInt("i64", 1)], "inbounds");
v7,Value v7 = builder.load(v6);
v8,Value v8 = builder.load(v2);
v9,PointerValue v9 = builder.bitCast(<PointerValue>v7, extFnPtrTy);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i64")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.getElementPtr(<PointerValue>arg, [context.constInt("i64", 3)]);
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType("i8"), paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
arg_1,Value arg_1 = bar.getParam(0);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: pointerType("i64", 1), paramTypes: [pointerType("i64", 1)]});
fooBB2,BasicBlock fooBB2 = foo2.appendBasicBlock();
arg_2,Value arg_2 = foo2.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
f1,FunctionDefn f1 = foo1(builder, m);
f2,FunctionDefn f2 = foo2(builder, m);
f3,FunctionDefn f3 = foo3(context, builder, m);
f4,FunctionDefn f4 = foo4(builder, m);
test,FunctionDefn test = m.addFunctionDefn("test", {returnType:"void", paramTypes:[]});
bb5,BasicBlock bb5 = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,Value R3;
R_3,Value|() R_3 = builder.call(f3, []);
R4,Value R4;
R_4,Value|() R_4 = builder.call(f4, [context.constInt("i64", 12), context.constInt("i64", 13)]);
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType:"void", paramTypes:[]});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType:"void", paramTypes:["i64","i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType:"i64", paramTypes:[]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
C1,Value C1 = cx.constInt("i64", 21);
foo4,FunctionDefn foo4 = m.addFunctionDefn("foo4", {returnType:"i64", paramTypes:["i64", "i64"]});
bb4,BasicBlock bb4 = foo4.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo4.getParam(0);
R1,Value R1 = foo4.getParam(1);
R5,Value R5 = builder.load(R4);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
genFn,FunctionDecl genFn = m.addFunctionDecl("genFn", {returnType: pointerType("i64", 3), paramTypes:[]});
pty0,PointerType pty0 = pointerType("i64", 0);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: pty0, paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
val,Value? val = builder.call(genFn, []);
retVal,Value retVal = builder.addrSpaceCast(<PointerValue>val, pty0);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "sadd.with.overflow.i64.i64");
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="main", linkageName="test", file=fileData, lineNo=1, ty=functionTy, scopeLine=0);
tyMeta,Metadata tyMeta = dIBuilder.createBasicType(name="myInt", encoding="signed", sizeInBits=64);
varMeta,Metadata varMeta = dIBuilder.createAutoVariable(ty=tyMeta, scope=functionData, name="myVar", lineNo=2, file=fileData);
bMeta,Metadata bMeta = dIBuilder.createAutoVariable(ty=dIBuilder.createBasicType(name="constInt", encoding="signed", sizeInBits=64), scope=functionData, name="B", lineNo=2, file=fileData);
charMeta,Metadata charMeta = dIBuilder.createBasicType(name="char", encoding="signed_char", sizeInBits=8);
taggedPtrMeta,Metadata taggedPtrMeta = dIBuilder.createTypedef(dIBuilder.createPointerType(pointeeTy=charMeta, sizeInBits=64, addressSpace=1), "TaggedPtr", fileData, 0, scope=fileData);
cMeta,Metadata cMeta = dIBuilder.createAutoVariable(ty=taggedPtrMeta, scope=functionData, name="C", lineNo=2, file=fileData);
emptyExpr,Metadata emptyExpr = dIBuilder.createExpression([]);
bScope,Metadata bScope = dIBuilder.createLexicalBlock(functionData, fileData, 3, 2);
loc1,Metadata loc1 = dIBuilder.createDebugLocation(2, 2, bScope);
loc2,Metadata loc2 = dIBuilder.createDebugLocation(3, 2, functionData);
loc3,Metadata loc3 = dIBuilder.createDebugLocation(4, 2, functionData);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
a,PointerValue a = builder.alloca("i64");
b,PointerValue b = builder.alloca("i64");
c,PointerValue c = builder.alloca(pointerType("i8", 1));
initA,Value initA = context.constInt("i64", 10);
retVal,Value retVal = builder.iArithmeticWrap("add", builder.load(a), context.constInt("i64", 1));
context,Context context = new;
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "void", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
builder,Builder builder = context.createBuilder();
fn,FunctionDefn fn = m.addFunctionDefn(fnName, {returnType: "double", paramTypes: []});
initBlock,BasicBlock initBlock = fn.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
p1,Value p1 = mainFunction.getParam(0);
p2,Value p2 = mainFunction.getParam(1);
v,PointerValue v = builder.alloca("i64");
a,Value a = builder.iArithmeticWrap("add", p1, p2);
greater,BasicBlock greater = mainFunction.appendBasicBlock("greater");
less,BasicBlock less = mainFunction.appendBasicBlock("less");
isGreater,Value isGreater = builder.iCmp("sge", a, context.constInt("i64", 10));
b_1,Value b_1 = builder.iArithmeticWrap("sub", a, context.constInt("i64", 5));
common,BasicBlock common = mainFunction.appendBasicBlock();
b_2,Value b_2 = builder.iArithmeticWrap("add", a, context.constInt("i64", 5));
b_3,Value b_3 = builder.load(v);
context,Context context = new;
m,Module m = context.createModule();
builder,Builder builder = context.createBuilder();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,Value R5 = builder.load(R4);
R6,Value R6 = builder.iCmp("eq", R5, context.constInt("i64", 0));
bb7,BasicBlock bb7 = foo.appendBasicBlock();
bb10,BasicBlock bb10 = foo.appendBasicBlock();
bb13,BasicBlock bb13 = foo.appendBasicBlock();
bb14,BasicBlock bb14 = foo.appendBasicBlock();
R8,Value R8 = builder.load(R3);
R9,Value R9 = builder.iCmp("eq", R8, context.constInt("i64", int:MIN_VALUE));
R11,Value R11 = builder.load(R4);
R12,Value R12 = builder.iCmp("eq", R11, context.constInt("i64", -1));
R15,Value R15 = builder.load(R3);
R16,Value R16 = builder.load(R4);
R17,Value R17 = builder.iArithmeticSigned("sdiv", R15, R16);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
out,string out = typeToString(ty, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
pTy,PointerType pTy = pointerType(ty);
out,string out = typeToString(pTy, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
ty,StructType ty = structType(intTypes);
context,Context context = new;
out,string out = typeToString(ty, context);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
elements,ConstValue[] elements = [context.constInt("i64", 1), context.constInt("i64", 10), context.constInt("i64", 100)];
array,ConstValue array = context.constArray("i64", elements);
retTy,ArrayType retTy = arrayType("i64", 3);
fn,FunctionDefn fn = m.addFunctionDefn("test", {returnType: retTy, paramTypes:[]});
bb,BasicBlock bb = fn.appendBasicBlock();
msg,string msg = "something impossible happened";
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseIntersection(tok);
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
tds,TypeDesc[] tds = [lhs];
opPos,Position[] opPos = [];
right,TypeDesc right = op == "|" ? check parseIntersection(tok) : check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
unary,UnaryTypeDesc unary = { startPos, endPos, op: "!", opPos: startPos, td };
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parsePrimaryTypeDesc(tok);
opPos,Position opPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
optionalTd,UnaryTypeDesc optionalTd = { startPos, endPos, op: "?", opPos, td };
dimensions,SimpleConstExpr?[] dimensions = [];
endPos,Position? endPos = ();
array,ArrayTypeDesc array = { startPos, endPos: <Position>endPos, member: td , dimensions };
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
pos,Position pos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
constituent,TypeDesc constituent = check parseTypeParam(tok);
endPos,Position endPos = tok.currentEndPos();
rest,var rest = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
detail,var detail = check parseTypeParam(tok);
row,TypeDesc row = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
prefix,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
typeName,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
valueExpr,SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);
td,TypeDesc td = check parseTypeDesc(tok);
startPos,Position startPos = tok.currentStartPos();
params,FunctionTypeParam[] params = namedParams ?: [];
paramStartPos,Position paramStartPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
ret,TypeDesc? ret = ();
t,Token? t = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
members,TypeDesc[] members = [];
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
rest,TypeDesc? rest = ();
td,TypeDesc td = check parseTypeDesc(tok);
fields,FieldDesc[] fields = [];
rest,TypeDesc? rest = ();
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
fields,FieldDesc[] fields = [];
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
name,string name = check tok.expectIdentifier();
endPos,Position endPos = check tok.expectEnd(";");
importDecls,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
moduleLevelDefns,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);
org,string? org = decl.org;
prefix,string? prefix = decl.prefix;
nameNodes,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
td,SubsetBuiltinTypeDesc? td = defn.td;
name,string? name = param.name;
body,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
name,string? name = stmt.name;
returnExpr,Expr? returnExpr = stmt.returnExpr;
lValue,LExpr|WILDCARD lValue = stmt.lValue;
ifFalse,StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;
clauses,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
childNodes,SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];
prefix,string? prefix = expr.prefix;
prefix,string? prefix = expr.prefix;
identifierPos,Position? identifierPos = prefix == () ? expr.qNamePos : ();
token,string token;
typeSuffix,FpTypeSuffix? typeSuffix = expr.typeSuffix;
op,BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;
memberNodes,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
rest,TypeDesc? rest = td.rest;
dimensions,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
rest,TypeDesc|INCLUSIVE_RECORD_TYPE_DESC? rest = td.rest;
fields,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
params,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
retTd,TypeDesc? retTd = td.ret;
prefix,string? prefix = td.prefix;
childNodes,SubSyntaxNode[] childNodes = [{ token: td.op, pos: td.startPos }, syntaxNodeFromTypeDesc(td.td)];
token,string token;
valueExpr,ExtendedLiteralExpr valueExpr = td.valueExpr;
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList(nodes);
newNodes,SubSyntaxNode[] newNodes = [];
nodes,SubSyntaxNode[] nodes = [];
words,Word[] words = [];
childNodes,SubSyntaxNode[] childNodes = node.childNodes;
flags,OutputFlags flags = terminalSyntaxNodeFlags(child, node);
parent,AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();
name,string name = parent is FunctionCallExpr ? parent.funcName : parent.methodName;
astNode,AstNode astNode = node.astNode;
chunks,string[] chunks = ["\""];
Char,string:Char? singleEscaped = REVERSE_ESCAPES[ch];
cp,int cp = ch.toCodePointInt();
parts,string[] parts = [];
lines,string[] lines = [];
skipSpace,boolean skipSpace = true;
ignoreNewLine,boolean ignoreNewLine = false;
indentSize,int indentSize = 0;
token,Word token = words[i];
nextToken,Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();
lastLine,string lastLine = string
filteredLines,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
content,string[] content = [];
Char,:Char?[] { string:Char?[] fragFixed = [];
ft,FixedToken?[] ft = [];
s,string s = checkpanic string
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragments,readonly & string[] fragments = line.fragments;
fragCodeIndex,int fragCodeIndex = 0;
fragmentIndex,int fragmentIndex = 0;
i,int i = 0;
code,FragCode code = fragCodes[fragCodeIndex];
ft,FixedToken? ft = fragTokens[<int>code];
lineContent,string[] lineContent = [];
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragmentIndex,int fragmentIndex = 0;
code,FragCode code = fragCodes[fragCodeIndex];
hexDigits,string hexDigits = fragment.substring(3, fragment.length() - 1);
codePoint,int codePoint = check int
:Char,string:Char
result,ScannedLine[] result = from var l in lines select scanLine(l);
codePoints,int[] codePoints = line.toCodePointInts();
fragCodes,FragCode[] fragCodes = [];
endIndex,int[] endIndex = [];
fragments,string[] fragments;
nVarFragments,int nVarFragments = 0;
fragments,string[] fragments = [];
startIndex,int startIndex = 0;
lines,string[] lines = [];
i,int i = 0;
lineStartIndex,int lineStartIndex = 0;
cr,int? cr = ();
len,final int len = codePoints.length();
i,int i = startIndex;
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i);
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
startResultLength,final int startResultLength = result.fragCodes.length();
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanNumericEscape(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = scanOptDigits(codePoints, startIndex);
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i + 1);
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
ei,int[] ei = result.endIndex;
len,int len = ei.length();
startIndex,int startIndex = len > 0 ? ei[len - 1] : 0;
ki,int? ki = keywordIndex(codePoints, startIndex, i);
kw,string kw = checkpanic string
fc,FragCode[] fc = result.fragCodes;
len,int len = fc.length();
len,int len = codePoints.length();
cp,int cp = codePoints[i];
startPos,Position startPos = tok.currentStartPos();
stmts,Stmt[] stmts = [];
endPos,Position endPos = tok.currentEndPos();
closeBracePos,Position closeBracePos = tok.currentStartPos();
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
peeked,var peeked = tok.peek(skipQualIdent=true);
td,TypeDesc td = check parseTypeDesc(tok);
isTypeDesc,boolean isTypeDesc = check savePreparseRestore(tok, preparseArrayTypeDesc);
endPos,Position endPos = check tok.expectEnd(";");
stmt,BreakContinueStmt stmt = { startPos, endPos, breakContinue:<BreakContinue>cur };
peeked,var peeked = tok.peek();
state,TokenizerState state = tok.save();
isTypeDesc,boolean isTypeDesc = check func(tok);
name,string name;
prefix,string? prefix;
expr,FunctionCallExpr expr = check finishFunctionCallExpr(tok, prefix, name, startPos);
endPos,Position endPos = tok.previousEndPos();
lExpr,LExpr lExpr = { startPos, endPos, name, qNamePos: startPos, prefix };
cur,Token? cur = tok.current();
opPos,Position opPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check startPrimaryExpr(tok);
cur,Token? cur = tok.current();
endPos,Position endPos = check tok.expectEnd(";");
primary,Expr primary = check finishPrimaryExpr(tok, expr, startPos);
endPos,Position endPos = check tok.expectEnd(";");
stmt,CallStmt stmt;
t,Token? t = tok.current();
innerKwPos,Position innerKwPos = tok.currentStartPos();
operandStmt,CallStmt operandStmt = check finishCheckingCallStmt(tok, t, innerKwPos);
operandStmt,CallStmt operandStmt = check parseMethodCallStmt(tok);
operand,Expr operand = check parsePrimaryExpr(tok);
expr,CheckingCallExpr expr = { startPos: kwPos, endPos: operand.endPos, checkingKeyword, kwPos, operand};
endPos,Position endPos = check tok.expectEnd(";");
opPos,Position opPos = tok.currentStartPos();
expr,Expr expr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
stmt,AssignStmt stmt = { startPos, endPos, opPos, lValue, expr };
opStr,string opStr = op;
binOp,BinaryArithmeticOp|BinaryBitwiseOp binOp = <BinaryArithmeticOp|BinaryBitwiseOp> opStr.substring(0, opStr.length() - 1);
stmt,CompoundAssignStmt stmt = { startPos, endPos, opPos, lValue, expr, op: binOp };
td,TypeDesc td = check parseTypeDesc(tok);
cur,Token? cur = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string|WILDCARD name;
opPos,Position opPos = check tok.expectStart("=");
initExpr,Expr initExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
returnExpr,Expr? returnExpr;
endPos,Position endPos;
panicExpr,Expr panicExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
ifFalse,IfElseStmt|StmtBlock? ifFalse;
condition,Expr condition = check parseExpr(tok);
ifTrue,StmtBlock ifTrue = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
cur,Token? cur = tok.current();
ifFalseStartPos,Position ifFalseStartPos = tok.currentStartPos();
condition,Expr condition = check parseExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
kwPos,Position kwPos = check tok.expectStart("in");
range,RangeExpr range = check parseRangeExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
expr,Expr expr = check parseInnerExpr(tok);
clauses,MatchClause[] clauses = [];
endPos,Position endPos = tok.currentEndPos();
startPos,Position startPos = tok.currentStartPos();
patterns,MatchPattern[] patterns = check parseMatchPatternList(tok);
opPos,Position opPos = check tok.expectStart("=>");
block,StmtBlock block = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
patterns,MatchPattern[] patterns = [];
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
parenResult,boolean? parenResult = check preparseBracketed(tok, close);
t,Token? t = tok.current();
squareResult,boolean? squareResult = check preparseBracketed(tok, "]");
t,Token? t = tok.current();
result,boolean? result = check preparseBracketed(tok, closeBracketMap.get(<string>t));
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
members,var [members, _] = check parseExprList(tok, "]");
endPos,Position endPos = tok.previousEndPos();
expr,ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };
fields,Field[] fields = check parseFields(tok);
endPos,Position endPos = tok.previousEndPos();
expr,MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseLogicalAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseLogicalAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseOrExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseOrExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseXorExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseXorExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseEqualityExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseEqualityExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseRelationalExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseRelationalExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseShiftExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseShiftExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };
t2,Token? t2 = tok.current();
kwPos,Position kwPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
lower,Expr lower = check parseAdditiveExpr(tok);
opPos,Position opPos = check tok.expectStart("..<");
upper,Expr upper = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseAdditiveExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
shift,BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseMultiplicativeExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseMultiplicativeExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseUnaryExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };
kwPos,Position kwPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };
opPos,Position opPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,TypeCastExpr expr = { startPos, endPos, opPos, td, operand };
startPos,Position startPos = tok.currentStartPos();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,string? prefix;
name,string name;
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };
expr,FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: () };
innerExpr,Expr innerExpr = check parseInnerExpr(tok);
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
expr,LiteralExpr expr = { startPos, endPos, value: () };
kwPos,Position kwPos = tok.currentStartPos();
message,Expr message = check parseExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
accessEndPos,Position accessEndPos = check tok.expectEnd("]");
accessExpr,MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };
qnamePos,Position qnamePos = tok.currentStartPos();
name,string name = check parseIdentifierOrMethodName(tok);
endPos,Position endPos = tok.previousEndPos();
fieldAccessExpr,FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };
t,Token? t = tok.current();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
exprs,Expr[] exprs = [];
expr,Expr expr = check parseExpr(tok);
t,Token? t = tok.current();
closeTerminatorPos,Position closeTerminatorPos = tok.currentStartPos();
fields,Field[] fields = [];
f,Field f = check parseField(tok);
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
isIdentifier,boolean isIdentifier = t[0] == IDENTIFIER;
name,string name = t[1];
colonPos,Position colonPos = tok.currentStartPos();
value,Expr value = check parseExpr(tok);
endPos,Position endPos = tok.previousEndPos();
f,Field f = { startPos, endPos, colonPos, name, value, isIdentifier };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = check tok.expectEnd(")");
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
name,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
untypedLiteral,, var untypedLiteral
typeSuffix,, var typeSuffix] => { Position
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits };
:fromHexString,: int:fromHexString(digits);
tok,Tokenizer tok = new(self.tokState.file);
tok,Tokenizer tok = new (file);
tok,Tokenizer tok = scanned.tokenizer();
defns,ModuleLevelDefn[] defns = [];
part,ModulePart part = { file: scanned.sourceFile(), partIndex: scanned.partIndex, defns, importDecls: scanned.importDecls };
tok,Tokenizer tok = new (file);
expr,Expr expr = check parseExpr(tok);
imports,ImportDecl[] imports = [];
t,Token? t = tok.current();
im,ImportDecl im = check parseImportDecl(tok, partIndex);
startPos,Position startPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
firstModuleName,string firstModuleName = check validImportPart(tok);
org,string? org = ();
names,[string, string...] names = [firstModuleName];
prefix,string? prefix = check parseImportPrefix(tok);
endPos,Position endPos = check tok.expectEnd(";");
names,string[] names = [];
identifier,string identifier = check tok.expectIdentifier();
prevChar,string? prevChar = ();
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
vis,Visibility vis;
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = check tok.expectEnd(";");
t,Token? t = tok.current();
td,SubsetBuiltinTypeDesc? td = ();
tdStartPos,Position tdStartPos = tok.currentStartPos();
tdEndPos,Position tdEndPos = tok.currentEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
expr,Expr expr = check parseInnerExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
params,FunctionParam [] params = [];
typeDesc,FunctionTypeDesc typeDesc = check parseFunctionTypeDesc(tok, params);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
defn,FunctionDefn defn = { startPos, endPos, params, typeDesc, name, vis, namePos, body, part };
message,string message = "parse error";
t,Token? t = tok.current();
str,string str = "";
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
fragment,string fragment = self.getFragment();
ch,string|error ch = unicodeEscapeValue(fragment);
number,string number = self.getFragment();
number,string number = self.getFragment();
ft,FixedToken? ft = fragTokens[<int>fragCode];
fragCodes,readonly & FragCode[] fragCodes = self.fragCodes;
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
lineIndex,int lineIndex = self.lineIndex;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
i,int i = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
nextFragCode,FragCode nextFragCode = fragCodes[i];
lineIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
codePointIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragment,string fragment = self.fragments[self.fragmentIndex];
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex];
t,Token? t = self.curTok;
msg,d:Message msg;
pos,Position pos = self.currentEndPos();
pos,Position pos = self.currentStartPos();
msg,d:Message msg;
t,Token? t = self.curTok;
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex - 1];
startPos,Position startPos;
endPos,Position? endPos;
startLineNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(startLineNum);
lineFragments,string[] lineFragments = scanLineFragments(line);
lineContent,string lineContent = "".'join(...lineFragments);
endColumnNum,int endColumnNum;
endLineNum,int endLineNum;
lineNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(lineNum);
endColumnNum,int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragments,string[] fragments = line.fragments;
fragCodes,FragCode[] fragCodes = line.fragCodes;
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragmentIndex,int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);
nCodePoints,int nCodePoints = 0;
fragmentIndex,int fragmentIndex = 0;
nFragments,int nFragments = fragments.length();
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragCode,FragCode fragCode = fragCodes[fragmentIndex];
file,SourceFile file = createSourceFile([str], { filename: "<internal>" });
tok,Tokenizer tok = new(file);
left,Identifier|TypeProjection left = check parseTypeProjection(tok);
t,Token? t = tok.current();
op,SubtypeTestOp op;
right,Identifier|TypeProjection right = check parseTypeProjection(tok);
identifier,Identifier identifier = check tok.expectIdentifier();
t,Token? t = tok.current();
index,int|Identifier index;
actualNode,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
normalizedActualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
actualNodeLines,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
node,SyntaxNode node;
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
t,err:Syntax|Token? t = advance(tok, k, lines);
lc,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
src,string src = lines[lc[0] - 1];
tStart,int tStart = lc[1];
tStr,string tStr = tokenToString(t);
srcAtPos,string srcAtPos = src.substring(tStart, tStart + tStr.length());
e,err:Syntax? e = tok.advance();
all,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
invalidCases,int invalidCases = all.length();
valid,map<ParserTestCase> valid = check readParserTests();
sources,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
tests,map<TokenizerTestCase> tests = {};
tests,map<ParserTestCase> tests = {};
testData,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
expected,string[] expected;
subject,string subject = s[2];
subjectLines,string[] subjectLines = splitIntoLines(subject);
rule,string rule = s[1];
testFiles,var testFiles = check file:readDir("modules/front.syntax/tests/data");
path,string path = f.absPath;
base,string base = check file:basename(path);
src,string[] src = check readCase(path);
parentDir,string parentDir = check file:parentPath(path);
canonFile,string canonFile = check file:joinPath(parentDir, canonFileName(base));
expected,string[] expected;
baseParts,[Kind, string] baseParts = check splitTestName(base);
rule,string rule = baseParts[1];
len,int len = base.length();
kindPos,int kindPos = base.indexOf("-") ?: 0;
kind,string kind = base.substring(0, kindPos);
afterKindPos,int afterKindPos = min(kindPos + 1, len);
rulePos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
rule,string rule = base.substring(afterKindPos, rulePos);
lines,string[] lines = check io:fileReadLines(path);
caseLines,string[] caseLines = [];
inCase,boolean inCase = false;
indented,int indented = 0;
trimLine,string trimLine = line.trim();
sansExt,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
testDir,foreach var testDir in check file:readDir(opts.transformedDir) { if testDir.dir { var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath)); skipped.push(...newSkipped); changed.push(...newChanged); unchanged.push(...newUnchanged); } }
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
baseTestDir,string baseTestDir = check file:joinPath(baseDir, testDir);
transformedTestDir,string transformedTestDir = check file:joinPath(transformedDir, testDir);
skipped,TestDiffResult[] skipped = [];
changed,TestDiffResult[] changed = [];
unchanged,TestDiffResult[] unchanged = [];
test,foreach var test in check file:readDir(transformedTestDir) { if !test.dir { var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath)); skipped.push(...newSkipped); changed.push(...newChanged); unchanged.push(...newUnchanged); } }
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
baseTestFile,string baseTestFile = check file:joinPath(baseTestDir, test);
transformedTestFile,string transformedTestFile = check file:joinPath(transformedTestDir, test);
baseTests,TestCase[] baseTests = check parseTests(baseTestFile);
transformedTests,TestCase[] transformedTests = check parseTests(transformedTestFile);
lines,string[] lines = check io:fileReadLines(path);
content,string[] content = [];
description,string description = "";
tests,TestCase[] tests = [];
s,State s = CONTENT;
line,foreach string line in lines { if line.startsWith("Test-Case:") { if content.length() != 0 { tests.push({ description, content, path }); } content = []; description = ""; s = CONTENT; } else if line.startsWith("Description:") { description = line; s = DESCRIPTION; } else if s is DESCRIPTION { if line.startsWith("Labels:") { s = CONTENT; } else { description += "\n" + line; } } content.push(line); }
baseIndex,int baseIndex = 0;
transformedIndex,int transformedIndex = 0;
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
baseDescription,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
baseContent,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
transformedDescription,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
transformedContent,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
body,string[] body = [];
currentPath,string currentPath = "";
diff,foreach TestDiffResult diff in diffs { string path = diff.base.path; if path != currentPath { if currentPath != "" { body.push("<hr>"); } body.push(string `<h3>${check file:basename(path)}</h3>`); currentPath = path; } body.push(string `<pre>${"<br>".'join(...diff.base.content)}</pre>`); body.push("<hr>"); }
path,string path = diff.base.path;
currentPath,string currentPath = "";
diff,foreach TestDiffResult diff in diffs { string path = diff.base.path; if path != currentPath { currentPath = path; body.push("</table>"); body.push(string `<h3>${check file:basename(path)}</h3>`); body.push( "<table>", "<tr>", "<th>Base</th>", "<th>Transformed</th>", "</tr>" ); } body.push("<tr>"); body.push(string `<td><pre>${"<br>".'join(...diff.base.content)}</pre></td>`); body.push(string `<td><pre>${"<br>".'join(...(<TestCase>diff.transformed).content)}</pre></td>`); body.push("</tr>"); }
path,string path = diff.base.path;
parts,string[] parts = check file:splitPath(absPath);
skipList,string? skipList = opts.skipList;
skipLabels,string[][] skipLabels = skipList != () ? check parseSkipList(skipList) : [];
skipped,int skipped = 0;
total,int total = 0;
path,foreach string path in paths { BaltTestCase[] tests = check parseTest(path); total += tests.length(); string[] parts = check file:splitPath(path); string filename = parts[parts.length() - 1]; string dir = parts[parts.length() - 2]; skipped += check outputTest(tests, dir, filename, skipLabels); }
tests,BaltTestCase[] tests = check parseTest(path);
parts,string[] parts = check file:splitPath(path);
filename,string filename = parts[parts.length() - 1];
dir,string dir = parts[parts.length() - 2];
testCases,BaltTestCase[] testCases = [];
lines,string[] lines = check io:fileReadLines(path);
header,string[] header = [];
labels,string[] labels = [];
content,string[] content = [];
useIoLib,boolean useIoLib = false;
s,State s = BOF;
line,foreach string line in lines { if line.startsWith("Test-Case:") { if s != BOF { content = addImports(content, useIoLib); testCases.push({ header, labels, content }); header = []; labels = []; content = []; useIoLib = false; } s = HEADER; header.push(line); } else if line.startsWith("Labels:") { var [_, fBody] = parseField(line); labels = parseCharSeparatedList(fBody, ","); s = LABEL; } else if s is HEADER|LABEL && line.trim() == "" { s = CONTENT; } else { match s { HEADER => { header.push(line); } LABEL => { labels.push(...parseCharSeparatedList(line, ",")); } CONTENT => { var [contentLine, newLabels] = transformContent(line); useIoLib = useIoLib ? useIoLib : contentLine.indexOf("io:") != (); content.push(contentLine); foreach var label in newLabels { if labels.indexOf(label) == () { labels.push(label); } } } } } }
fBody,var [_, fBody] = parseField(line);
contentLine,var [contentLine, newLabels] = transformContent(line);
newLabels,var [contentLine, newLabels] = transformContent(line);
label,foreach var label in newLabels { if labels.indexOf(label) == () { labels.push(label); } }
newContent,string[] newContent = ["import ballerina/io;"];
line,return from string line in check io:fileReadLines(skipListPath) select parseCharSeparatedList(line, " ");
newLabels,string[] newLabels = [];
initFunc,string initFunc = "function init()";
newLine,string newLine;
starIndex,int? starIndex = line.indexOf("{");
endIndex,int? endIndex = line.indexOf("}");
targetIndex,int targetIndex = <int>line.indexOf("?;");
i,int? i = s.indexOf(":");
fieldName,string fieldName = s.substring(0, i);
fieldValue,string fieldValue = s.substring(i + 1);
labels,string[] labels = [];
content,string[] content = [];
:Char,foreach string:Char c in s { if c == sep { labels.push("".'join(...content)); content = []; } else if c == " " { continue; } else { content.push(c); } }
skipTest,string[] body = [];
body,int skipped = 0;
skipped,int index = 0;
index,int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];
skipIndices,foreach BaltTestCase test in tests { index += 1; boolean skipTest = false; foreach int skipIndex in skipIndices { if skipIndex == index { skipTest = true; break; } } if skipTest || !testValid(test, skipLabels) { skipped += 1; continue; } body.push(...test.header); body.push("Labels: " + ", ".'join(...test.labels)); body.push(""); body.push(...test.content); }
test,boolean skipTest = false;
skipTest,foreach int skipIndex in skipIndices { if skipIndex == index { skipTest = true; break; } }
skipIndex,string outputFileName = string `./tests/${dir}/${filename}`;
outputFileName,foreach string[] labelGroup in skipLabels { boolean invalid = true; foreach string label in labelGroup { if test.labels.indexOf(label, 0) == () { invalid = false; break; } } if invalid { return false; } }
labelGroup,boolean invalid = true;
invalid,foreach string label in labelGroup { if test.labels.indexOf(label, 0) == () { invalid = false; break; } }
label,null
NIL_SEXPR,null
tc,t:Context tc = mod.getTypeContext();
defn,int numBlocks = self.blocks.length();
tc,VerifyContext vc = new(mod, defn);
funcPos,Label entry = 0;
blocks,VerifyCodeContext cx = check vc.verifyCodeContext(code);
fwdInDegrees,RegSet params = check verifyParamRegs(vc, code.registers);
blocksFlows,foreach BasicBlock b in code.blocks { check verifyBasicBlock(vc, b); }
preds,BasicBlock block = cx.blocks[current];
numBlocks,Insn term = check blockTerminator(cx, block, predPos);
vc,Position termPos = term.pos;
entry,Label? onPanic = block.onPanic;
cx,boolean cycle = cx.preds[child];
params,int fid = cx.fwdInDegrees[child];
b,int i = 0;
block,foreach int fid in cx.fwdInDegrees { if fid == 0 { Insn[] insns = cx.blocks[i].insns; if insns.length() > 0 { return cx.invalidErr(`unreachable block: ${i}`, insns[0].pos); } else { return cx.invalidErr(`unreachable and empty block: ${i}`); } } i += 1; }
term,Insn[] insns = cx.blocks[i].insns;
termPos,RegSet paramRegs = [];
onPanic,boolean afterParams = false;
cycle,foreach var reg in regs { if reg is ParamRegister { if afterParams { return vc.invalidErr("param register is not at the beginning of the register list", reg.pos); } paramRegs.push(true); } else { paramRegs.push(false); afterParams = true; } }
fid,BasicBlock block = cx.blocks[current];
i,RegFlow[] flows = cx.blocksFlows[current];
fid,RegSet regs = mergeFlows(flows);
insns,boolean afterMerge = false;
paramRegs,foreach var insn in block.insns { if insn is TypeMergeInsn { check verifyTypeMergeFlow(cx, afterMerge, flows, insn); } else { afterMerge = true; } match insn { var { result } => { regs[result.number] = true; } var { operand } => { check verifyOperandInitialized(cx, operand, regs, insn.pos); } var { operands } | var { args: operands } => { foreach Operand op in <Operand[]>operands { check verifyOperandInitialized(cx, op, regs, insn.pos); } } } } Label? onPanic = block.onPanic; Insn term = check blockTerminator(cx, block, viaPos); Position termPos = term.pos; if onPanic != () { check verifyRegFlow(cx, onPanic, { origin: current, regs }, termPos); } if term is BranchInsn && !term.backward { check verifyRegFlow(cx, term.dest, { origin: current, regs }, termPos); } else if term is CondBranchInsn { check verifyRegFlow(cx, term.ifTrue, { origin: current, regs: regs.clone() }, termPos); check verifyRegFlow(cx, term.ifFalse, { origin: current, regs }, termPos); } else if term is TypeBranchInsn { RegSet trueRegs = regs.clone(); RegSet falseRegs = regs; trueRegs[term.ifTrueRegister.number] = true; falseRegs[term.ifFalseRegister.number] = true; check verifyRegFlow(cx, term.ifTrue, { origin: current, regs: trueRegs }, termPos); check verifyRegFlow(cx, term.ifFalse, { origin: current, regs: falseRegs }, termPos); } }
afterParams,| var { args: operands }
reg,foreach Operand op in <Operand[]>operands { check verifyOperandInitialized(cx, op, regs, insn.pos); }
block,Label? onPanic = block.onPanic;
flows,Insn term = check blockTerminator(cx, block, viaPos);
regs,Position termPos = term.pos;
afterMerge,RegSet trueRegs = regs.clone();
insn,RegSet falseRegs = regs;
operands,int numFlows = flows.length();
op,int i = 0;
onPanic,foreach Label pred in merge.predecessors { RegFlow? flow = flowOriginating(flows, pred); if flow!= () { check verifyOperandInitialized(cx, merge.operands[i], flow.regs, merge.pos); } else { return cx.invalidErr(`superfluous predecessor ${pred} in TypeMergeInsn`, merge.pos); } i += 1; }
term,RegFlow? flow = flowOriginating(flows, pred);
termPos,Insn[] insns = block.insns;
trueRegs,int insnsLen = insns.length();
falseRegs,foreach RegFlow flow in flows { if flow.origin == origin { return flow; } }
numFlows,RegSet result = [];
i,int numReg = flow[0].regs.length();
pred,foreach int i in 0 ..< numReg { boolean conj = true; foreach var { regs } in flow { if !regs[i] { conj = false; break; } } result.push(conj); }
flow,boolean conj = true;
insns,foreach Insn insn in bb.insns { check verifyInsn(vc, insn); }
insnsLen,string name = insn.name;
flow,Register unnarrowedOp = unnarrow(insn.result);
result,t:SemType union = t:NEVER;
numReg,foreach Register r in insn.operands { if unnarrowedOp.number != unnarrow(r).number { return vc.invalidErr("underlying register of narrow register is incorrect", insn.pos); } union = t:union(union, r.semType); }
i,Register unnarrowedOp = unnarrow(insn.operand);
conj,FunctionRef func = <FunctionRef>insn.func;
insn,FunctionSignature sig = func.signature;
name,int nSuppliedArgs = insn.args.length();
unnarrowedOp,int nExpectedArgs = sig.paramTypes.length();
union,string name = vc.symbolToString(func.symbol);
r,foreach int i in 0 ..< nSuppliedArgs { check validOperandType(vc, insn.args[i], sig.paramTypes[i], `wrong argument type for parameter ${i + 1} in call to function ${vc.symbolToString(func.symbol)}`, vc.qNameRange(insn.pos)); }
unnarrowedOp,t:SemType ty = insn.result.semType;
func,t:ListAtomicType? lat = t:listAtomicType(vc.typeContext(), ty);
sig,Operand[] operands = insn.operands;
nSuppliedArgs,foreach int i in 0 ..< operands.length() { check validOperandType(vc, operands[i], t:listAtomicTypeMemberAtInnerVal(lat, i), "type of list constructor member is not allowed by the list type", insn.pos); }
nExpectedArgs,t:SemType ty = insn.result.semType;
name,t:MappingAtomicType? mat = t:mappingAtomicType(vc.typeContext(), ty);
i,foreach int i in 0 ..< insn.operands.length() { check validOperandType(vc, insn.operands[i], t:mappingAtomicTypeMemberAtInnerVal(mat, insn.fieldNames[i]), "type of mapping constructor member is not allowed by the mapping type", insn.pos); }
ty,IntOperand indexOperand = insn.operands[1];
lat,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, indexOperand.semType);
operands,IntOperand i = insn.operands[1];
i,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, insn.operands[1].semType);
ty,StringOperand keyOperand = insn.operands[1];
mat,t:SemType memberType = t:mappingMemberTypeInner(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
i,StringOperand keyOperand = insn.operands[1];
indexOperand,t:SemType memberType = t:mappingMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
memberType,Operand lhs = insn.operands[0];
i,Operand rhs = insn.operands[1];
memberType,null
keyOperand,null
memberType,null
keyOperand,null
memberType,null
lhs,null
rhs,null
label,int label = code.blocks.length();
bb,BasicBlock bb = { label, name };
r,VarRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,FinalRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,NarrowRegister r = { number: code.registers.length(), underlying, semType, pos };
r,ParamRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,TmpRegister r = { number: code.registers.length(), semType, pos, name };
r,AssignTmpRegister r = { number: code.registers.length(), semType, pos, name };
NIL_OPERAND,foreach Insn insn in block.insns { if isInsnPotentiallyPanicking(insn) { return true; } }
insn,null
PPI_INSNS,null
isNamed,boolean isNamed = ty.name != ();
elementTypes,Type[] elementTypes = ty.elementTypes;
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
,string[] words = [];
DataValue,foreach var word in body { words.push(word); }
operand,string operand = concat(...words);
ty,string[] structBody = [];
class,Type[] elemTypes = [];
,foreach int i in 0 ..< elements.length() { final Value element = elements[i]; if i > 0 { structBody.push(","); } structBody.push(typeToString(element.ty, self)); if element.operand is Unnamed { panic err:illegalArgument("All elements must be constants"); } else { structBody.push(<string>element.operand); } elemTypes.push(element.ty); }
class,final Value element = elements[i];
,Type structTy = structType(elemTypes);
class,ArrayType ty = arrayType(elementType, values.length());
,string[] body = ["["];
words,foreach int i in 0 ..< values.length() { final ConstValue element = values[i]; if i > 0 { body.push(","); } body.push(typeToString(element.ty, self), element.operand); }
word,final ConstValue element = values[i];
operand,ArrayType ty = arrayType("i8", bytes.length());
POS_INF,ConstValue val = new(ty, charArray(bytes));
NEG_INF,string[] words = [];
NAN,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self);
Context,string[] words = [];
structBody,string[] words = [];
elemTypes,string structName = "%" + escapeIdent(name);
i,StructType ty = { elementTypes: [], name: structName };
element,string? tyName = namedStructTy.name;
structTy,string valRep;
ty,foreach var entry in self.namedStructTypes.entries() { var data = entry[1]; if data[1] { string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)]; out.push(concat(...words)); } }
body,var data = entry[1];
i,string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)];
element,string? tyName = ty.name;
ty,var data = self.namedStructTypes[tyName];
val,DIBuilder dIBuilder = new(self, self.context);
words,Metadata metadata = self.addMetadata();
destTy,string[] preambleWords = [];
words,foreach var flagMetadata in self.moduleFlags { preambleWords.push(flagMetadata.ref(), ","); flagMetadata.resetPreamble(); }
words,string fnName = self.escapeGlobalIdent(name);
structName,FunctionDefn fn = new (self.context, fnName, fnType);
ty,string fnName = self.escapeGlobalIdent(name);
tyName,FunctionDecl fn = new(self.context, fnName, fnType);
valRep,FunctionDecl? fnExisting = <FunctionDecl?>self.globals[name];
entry,boolean fnExisting = self.globals[name] != ();
data,FunctionDecl fn = new(self.context, "llvm." + name, fnType);
words,foreach var attr in attrs { fn.addEnumAttribute(attr); }
tyName,string varName = self.escapeGlobalIdent(name);
data,PointerType ptrType = pointerType(ty, props.addressSpace);
,ConstPointerValue val = new ConstPointerValue(ptrType, "@" + varName);
Module,foreach var [globalVar, props] in self.globalVariables { if globalVar === global { props.initializer = initializer; return; } }
dIBuilder,foreach var [globalVar, props] in self.globalVariables { if globalVar === global { props.initializer = initializer; return; } }
metadata,string aliasName = self.escapeGlobalIdent(name);
preambleWords,ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);
flagMetadata,string varName = escapeIdent(name);
fnName,Output out = new;
fn,Output out = new;
fnName,string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];
fn,foreach var val in self.globalVariables { self.outputGlobalVar(val[0], val[1], out); }
fnExisting,foreach var val in self.aliases { self.outputAlias(val[0], val[1], val[2], out); }
fnExisting,foreach var fn in self.functionDecls { fn.output(out); }
fn,foreach var fn in self.functionDefns { fn.output(out); }
attr,foreach var data in self.metadata { if data.hasPreamble() { data.outputPreamble(out); } }
varName,foreach var data in self.metadata { data.output(out); }
ptrType,string[] line = [alias.operand, "="];
val,string[] words = [];
globalVar,var initializer = prop.initializer;
props,Metadata metadata = new(self.genMetadataLabel());
aliasName,ReturnEnumAttribute attrib = attribute[1];
alias,ParamEnumAttribute attrib = attribute[1];
varName,int paramIndex = attribute[0];
out,foreach int i in 0 ..< functionType.paramTypes.length() { final Type paramType = functionType.paramTypes[i]; string register = "%" + i.toString(); Value arg = new (paramType, register); self.paramValues.push(arg); }
out,final Type paramType = functionType.paramTypes[i];
words,string register = "%" + i.toString();
val,Value arg = new (paramType, register);
val,foreach var b in self.basicBlocks { b.updateUnnamed(); }
fn,boolean isFirst = true;
fn,foreach var b in self.basicBlocks { b.output(out, isFirst); isFirst = false; }
data,string|Unnamed bbName = self.genName(name);
data,BasicBlock bb = new (self.context, bbName, self);
line,string varName = name;
words,int count = self.variableNames.get(varName);
initializer,string newName = varName + "." + count.toString();
metadata,int varName = self.unnamedLabelCount;
,string|Unnamed reg = self.genName(name);
FunctionDecl,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
attrib,int paramIndex = attribute[0];
paramIndex,string newLabel = self.nameCounter.toString();
,string newName = "%" + self.nameCounter.toString();
FunctionDefn,string newName = self.nameTranslation[name];
i,foreach var line in self.lines { out.push(line); }
paramType,foreach var line in self.preamble { out.push(line); }
register,Metadata metadata = self.m.addMetadata();
arg,string[] words = [];
b,Metadata metadata = self.m.addMetadata();
isFirst,Metadata metadata = self.m.addMetadata();
b,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];
bbName,string? name = props.name;
bb,Alignment? alignInBits = props.alignInBits;
varName,Metadata metadata = self.m.addMetadata();
count,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
newName,Metadata metadata = self.m.addMetadata();
varName,string encodingToString = "DW_ATE_" + props.encoding;
reg,Metadata metadata = self.m.addMetadata();
attrib,string[] words = [];
attrib,int? align = props.alignInBits;
paramIndex,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
newLabel,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
newName,Metadata metadata = self.m.addMetadata();
newName,string[] words = [];
,Metadata? scope = props.scope;
Metadata,Metadata? file = props.file;
label,Metadata? ty = props.ty;
lines,string[] flags = [];
preamble,foreach int i in 0 ..< flags.length() { if i > 0 { words.push("|"); } words.push(flags[i]); }
line,Metadata retainedNodes = self.m.addMetadata();
line,Metadata metadata = self.m.addMetadata();
sourceLangToString,Metadata metadata = self.m.addMetadata();
emissionKindToString,string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
moduleFlagBehaviorToString,Metadata metadata = self.m.addMetadata();
DIBuilder,Metadata typeNode = self.m.addMetadata();
m,Metadata metadata = self.m.addMetadata();
context,string[] words = [metadata.ref(), "=", "!", "DILocation", "("];
compileUnit,BasicBlock bb = self.bb();
metadata,string|Unnamed reg = bb.func.genReg(name);
words,PointerType ptrTy = pointerType(ty);
metadata,BasicBlock bb = self.bb();
metadata,Type ty = ptr.ty.pointsTo;
body,string|Unnamed reg = bb.func.genReg(name);
name,Type ty = ptr.ty.pointsTo;
alignInBits,BasicBlock bb = self.bb();
metadata,string|Unnamed reg = bb.func.genReg(name);
body,IntType|FloatType ty = sameNumberType(lhs, rhs);
metadata,BasicBlock bb = self.bb();
encodingToString,string|Unnamed reg = bb.func.genReg(name);
metadata,IntType|FloatType ty = sameNumberType(lhs, rhs);
words,BasicBlock bb = self.bb();
align,string|Unnamed reg = bb.func.genReg(name);
words,IntegralType ty = sameIntegralType(lhs, rhs);
words,BasicBlock bb = self.bb();
metadata,string|Unnamed reg = bb.func.genReg(name);
words,IntType|FloatType ty = sameNumberType(lhs, rhs);
scope,BasicBlock bb = self.bb();
file,string|Unnamed reg = bb.func.genReg(name);
ty,(string|Unnamed)[] words = [reg, "="];
flags,BasicBlock bb = self.bb();
i,BasicBlock bb = self.bb();
retainedNodes,string|Unnamed reg = bb.func.genReg(name);
metadata,BasicBlock bb = self.bb();
metadata,string|Unnamed reg = bb.func.genReg(name);
words,BasicBlock bb = self.bb();
metadata,string|Unnamed reg = bb.func.genReg(name);
typeNode,Type valueType = val.ty;
metadata,BasicBlock bb = self.bb();
words,string|Unnamed reg = bb.func.genReg(name);
Builder,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ptrTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
ty,string|Unnamed reg = bb.func.genReg(name);
reg,BasicBlock bb = self.bb();
ty,(string|Unnamed)[] insnWords;
bb,RetType retType;
reg,BasicBlock bb = self.bb();
ty,Type fnTy = fn.ty.pointsTo;
bb,var fnName = fn.operand;
reg,string functionName = "@" + fn.functionName;
ty,string|Unnamed reg = bb.func.genReg(name);
bb,(string|Unnamed)[] words = [reg];
reg,(string|Unnamed)[] insnWords = [];
ty,foreach int i in 0 ..< args.length() { final Value arg = args[i]; if i > 0 { insnWords.push(","); } insnWords.push(typeToString(arg.ty, self.context)); insnWords.push(arg.operand); }
bb,final Value arg = args[i];
reg,BasicBlock bb = self.bb();
ty,string|Unnamed reg = bb.func.genReg(name);
bb,Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);
reg,BasicBlock bb = self.bb();
words,Type condTy = condition.ty;
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,(string|Unnamed)[] words = [];
reg,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valueType,(string|Unnamed)[] words = [];
bb,BasicBlock? tem = self.currentBlock;
reg,(string|Unnamed)[] chunks = [];
valTy,string[] currentChunk = [];
bb,foreach var word in words{ if word is string{ currentChunk.push(word); } else { chunks.push(concat(...currentChunk)); currentChunk = []; chunks.push(word); } }
reg,(string|Unnamed)[][] newLines = [];
valTy,foreach var line in self.lines { (string|Unnamed)[] newLine = []; foreach var name in line { newLine.push(self.func.updateUnnamed(name)); } newLines.push(newLine); }
bb,(string|Unnamed)[] newLine = [];
reg,foreach var name in line { newLine.push(self.func.updateUnnamed(name)); }
bb,foreach var line in self.lines { string[] newLine = []; foreach var name in line { newLine.push(self.func.updateBasicBlockRef(name)); } string outputLine = createLine([concat(...newLine)], INDENT); out.push(outputLine); }
insnWords,string[] newLine = [];
retType,foreach var name in line { newLine.push(self.func.updateBasicBlockRef(name)); }
bb,string outputLine = createLine([concat(...newLine)], INDENT);
fnTy,Type ty1 = v1.ty;
fnName,Type ty2 = v2.ty;
functionName,string? tyName = ty.name;
reg,Type[] elementTypes = ty.elementTypes;
words,string[] typeStringBody = [];
insnWords,foreach int i in 0 ..< elementTypes.length() { final Type elementType = elementTypes[i]; if i > 0 { typeStringBody.push(","); } typeStringBody.push(typeToString(elementType, context)); }
i,final Type elementType = elementTypes[i];
arg,string[] typeStringBody = [];
bb,string[] typeStringBody = [];
reg,foreach int i in 0 ..< ty.paramTypes.length() { final Type paramType = ty.paramTypes[i]; if i > 0 { typeStringBody.push(","); } typeStringBody.push(typeToString(paramType, context)); }
elementType,final Type paramType = ty.paramTypes[i];
bb,Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);
condTy,foreach Type element in elementTypes { includeNamedType(element, context); }
bb,foreach Type paramType in ty.paramTypes { includeNamedType(paramType, context); }
bb,string[] words = [];
reg,Metadata? metadata = fn.metadata;
words,foreach int i in 0 ..< fn.returnAttributes.length() { words.push(fn.returnAttributes[i]); }
destTy,foreach int i in 0 ..< fn.functionType.paramTypes.length() { final Type ty = fn.functionType.paramTypes[i]; if i > 0 { words.push(","); } words.push(typeToString(ty, fn.context)); foreach int j in 0 ..< fn.paramAttributes[i].length() { words.push(fn.paramAttributes[i][j]); } if fn is FunctionDefn { words.push(<string>fn.getParam(i).operand); } }
bb,final Type ty = fn.functionType.paramTypes[i];
reg,foreach int j in 0 ..< fn.paramAttributes[i].length() { words.push(fn.paramAttributes[i][j]); }
words,foreach int i in 0 ..< fn.functionAttributes.length() { words.push(fn.functionAttributes[i]); }
tem,string[] parts = [];
,foreach string word in words { string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : ""; if lastTail.length() > 0 { lastTail = lastTail.substring(lastTail.length() - 1); } string head = word.length() > 0 ? word.substring(0, 1) : ""; if !(omitSpaceBefore(word) || (head != "\"" && omitSpaceBefore(head))) && parts.length() > 0 && !(omitSpaceAfter(parts[parts.length() - 1]) || (lastTail != "\"" && omitSpaceAfter(lastTail))) { parts.push(" "); } parts.push(word); }
BasicBlock,string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";
func,string head = word.length() > 0 ? word.substring(0, 1) : "";
label,string escaped = "\"";
lines,foreach var ch in name { escaped += escapeIdentChar(ch); }
isReferenced,int cp = ch.toCodePointInt();
chunks,byte[] bytes = ch.toBytes();
currentChunk,string result = "";
word,foreach byte b in bytes { result += "\\" + b.toHexString().toUpperAscii(); }
newLines,string hex = cp.toHexString().toUpperAscii();
line,Type ptrTy = ptr.ty;
newLine,Type resultType = ptr.ty;
name,int resultAddressSpace = 0;
line,foreach var index in indices { words.push(","); words.push(typeToString(index.ty, context)); words.push(index.operand); if resultType is PointerType { resultAddressSpace = resultType.addressSpace; resultType = resultType.pointsTo; } else { if resultType is ArrayType { resultType = resultType.elementType; } else if resultType is StructType { int i; if index.operand is Unnamed { i = <Unnamed>index.operand; } else { i = checkpanic int:fromString(<string>index.operand); } Type indexTy = index.ty; if indexTy !is "i32" { panic err:illegalArgument("structures can be index only using i32 constants"); } else { resultType = getTypeAtIndex(resultType, i, context); } } else { panic err:illegalArgument(string `type ${typeToString(resultType, context)} can't be indexed`); } } }
newLine,int i;
name,Type indexTy = index.ty;
outputLine,string result = "c\"";
ty1,foreach var b in bytes { if b >= 0x20 && b < 0x7F && b != CP_DOUBLE_QUOTE && b != CP_BACKSLASH { result += checkpanic string:fromBytes([b]); } else { result += "\\"; string hex = b.toHexString().toUpperAscii(); if hex.length() == 1 { result += "0" + hex; } else { result += hex; } } }
ty2,string hex = b.toHexString().toUpperAscii();
tyName,foreach var ch in name { if !isIdentFollow(ch) { return false; } }
elementTypes,null
typeStringBody,null
i,null
elementType,null
typeStringBody,null
typeStringBody,null
i,null
paramType,null
elementTypes,null
element,null
paramType,null
lines,null
words,null
metadata,null
i,null
i,null
ty,null
j,null
i,null
parts,null
word,null
lastTail,null
head,null
escaped,null
ch,null
cp,null
bytes,null
result,null
b,null
hex,null
ptrTy,null
resultType,null
resultAddressSpace,null
index,null
i,null
indexTy,null
CP_DOUBLE_QUOTE,null
CP_BACKSLASH,null
result,null
b,null
hex,null
ch,null
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g,ConstPointerValue g = m.addGlobal("i64", "g", initializer=context.constInt("i64", 5), addressSpace=1, linkage="internal");
a,ConstPointerValue a = m.addAlias("i64", g, "a", addressSpace=1);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
retVal,Value retVal = builder.load(a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: ["i8"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
a,Value a = foo.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,Value const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
const2,Value const2 = context.constStruct([context.constInt("i64", 3), context.constInt("i64", 4)]);
const2Ty,Type const2Ty = structType(["i64", "i64"]);
const3,Value const3 = context.constStruct([const1, const2]);
const3Ty,Type const3Ty = structType([const1Ty, const2Ty]);
testTy,FunctionType testTy = {returnType: const1Ty, paramTypes: []};
test,FunctionDefn test = m.addFunctionDefn("test", testTy);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
test2,FunctionDefn test2 = m.addFunctionDefn("test2", {returnType: const3Ty, paramTypes: []});
initBlock2,BasicBlock initBlock2 = test2.appendBasicBlock();
constFnStruct,Value constFnStruct = context.constStruct([test]);
constFnStructTy,Type constFnStructTy = structType([pointerType(testTy)]);
test3,FunctionDefn test3 = m.addFunctionDefn("test3", {returnType:constFnStructTy, paramTypes: []});
bb,BasicBlock bb = test3.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
sub,FunctionDecl sub = m.getIntrinsicDeclaration("ssub.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(sub, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
fnTy,FunctionType fnTy = functionType(structTy, [structTy, "i64"]);
notUsed,StructType notUsed = context.structCreateNamed("notUsed");
g,ConstPointerValue g = m.addGlobal(structTy, "g");
foo,FunctionDefn foo = m.addFunctionDefn("foo", { returnType: structTy, paramTypes: [] });
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", { returnType: "void", paramTypes: [structTy] });
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
p2,Value p2 = test.getParam(2);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
temp1,Value temp1 = builder.iArithmeticWrap("add",p0, p1);
temp2,Value temp2 = builder.iArithmeticWrap("add",temp1, p2);
test2,FunctionDecl test2 = m.addFunctionDecl("test2", {returnType:"i64", paramTypes:["i64", "i64", "i64"]});
context,Context context = new;
m,Module m = context.createModule();
fnTy,FunctionType fnTy = functionType("i64", ["i8", "i64"]);
otherFnTy,FunctionType otherFnTy = functionType("i8", ["i64"]);
otherFnPtrTy,PointerType otherFnPtrTy = pointerType(otherFnTy, 0);
fn,FunctionDecl fn = m.addFunctionDecl("otherFn", otherFnTy);
fnPointerTy,PointerType fnPointerTy = pointerType(fnTy, 0);
structTy,StructType structTy = structType(["i32", fnPointerTy]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bar,FunctionDecl bar = m.addFunctionDecl("bar",{returnType:"i64", paramTypes:["i64"]});
barVoid,FunctionDecl barVoid = m.addFunctionDecl("barVoid", {returnType:"void", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R_1,Value? R_1 = builder.call(bar, [context.constInt("i64", 0)]);
R1,Value R1;
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
g1Ty,StructType g1Ty = structType(["i64", "i32", "i8"]);
g1,ConstPointerValue g1 = m.addGlobal(g1Ty, "g1", isConstant=true);
init,ConstValue init = context.constGetElementPtr(g1, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
g2,ConstPointerValue g2 = m.addGlobal(pointerType("i64", 0), "g2", initializer=init);
init2,ConstValue init2 = context.constBitCast(g2, pointerType("i32", 0));
g4,ConstPointerValue g4 = m.addGlobal(pointerType("i32", 0), "g4", isConstant=true);
init3,ConstValue init3 = context.constAddrSpaceCast(g4, pointerType("i32", 1));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64",paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
m,Module m = basicMain();
output,Output output = new ();
outputPath,string outputPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", "tmp.ll");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: ["i64"]});
foo1BB,BasicBlock foo1BB = foo1.appendBasicBlock();
R2,PointerValue R2 = builder.alloca("i64");
R0,Value R0 = foo1.getParam(0);
R3,Value R3 = builder.load(R2);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: ["i64", "i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
R5,Value R5 = builder.load(R4);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,PointerValue R6 = builder.alloca("i64");
R0,Value R0 = foo3.getParam(0);
R1,Value R1 = foo3.getParam(1);
R2,Value R2 = foo3.getParam(2);
R7,Value R7 = builder.load(R6);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.bitCast(arg, pointerType("i64"));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: []});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
c,Value c = context.constInt("i64",42);
R2,Value R2 = builder.load(R1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.ptrToInt(arg, "i64");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
V1,Value V1 = builder.ptrToInt(arg, "i1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
strContent,byte[] strContent ="abc123#@% \n\\\"".toBytes();
str,Value str = context.constString(strContent);
strFn,FunctionDefn strFn = m.addFunctionDefn("test", {returnType: arrayType("i8", strContent.length()), paramTypes: []});
initBlock,BasicBlock initBlock = strFn.appendBasicBlock();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
expectedPath,string expectedPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", expectedFilename);
expectedLines,string[] expectedLines = check io:fileReadLines(expectedPath);
expectedOutput,string expectedOutput = "\n".'join(...expectedLines);
mod,Module mod = func();
actualOutput,string actualOutput = mod.printModuleToString();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i32", 1)]);
v1,PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i32", 0), context.constInt("i32", 2)]);
v2,PointerValue v2 = builder.getElementPtr(v1, [context.constInt("i32", 0), context.constInt("i32", 1)]);
v3,PointerValue v3 = builder.getElementPtr(v2, [context.constInt("i64", 0), context.constInt("i64", 5)]);
arrTy3,Type arrTy3 = arrayType(pointerType("i64", 1), 10);
rtTy2,Type rtTy2 = structType([ "i32", arrTy3, "i32" ]);
stTy2,Type stTy2 = structType(["i8", "i8", rtTy2]);
g2,PointerValue g2 = m.addGlobal(stTy2, "g2");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType(pointerType("i64",1)), paramTypes: []});
t0,PointerValue t0 = builder.getElementPtr(g2, [context.constInt("i32", 1),context.constInt("i32", 2), context.constInt("i32", 1), context.constInt("i32", 4)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0),context.constInt("i64", 1)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
g2,PointerValue g2 = m.addGlobal("i32", "g2");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v1,Value v1 = builder.ptrToInt(g2, "i32");
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0), v1]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,Type structTy = structType(["i64", "i64"]);
arrTy,Type arrTy = arrayType(structTy, 10);
g1,PointerValue g1 = m.addGlobal(arrTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i64", 10)]);
v1,error|PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i64", 10)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="test", linkageName="test", file=fileData, lineNo=0, ty=functionTy, scopeLine=0);
loc,Metadata loc = dIBuilder.createDebugLocation(1, 2, functionData);
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "void", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
v0,Value v0 = foo.getParam(0);
v1,Value v1 = foo.getParam(1);
a,Value a = builder.iArithmeticNoWrap("add", v0, v1);
b,Value b = builder.iArithmeticNoWrap("sub", v0, v1);
c,Value c = builder.iArithmeticNoWrap("mul", a, b);
context,Context context = new;
m,Module m = context.createModule();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,Value R6 = builder.load(R5);
R7,Value R7 = builder.iCmp("eq", R6, context.constInt("i64", 0));
bb8,BasicBlock bb8 = foo.appendBasicBlock();
bb9,BasicBlock bb9 = foo.appendBasicBlock();
R10,Value R10 = builder.load(R4);
R11,Value R11 = builder.iCmp("eq", R10, context.constInt("i64", int:MIN_VALUE));
bb16,BasicBlock bb16 = foo.appendBasicBlock();
bb12,BasicBlock bb12 = foo.appendBasicBlock();
R13,Value R13 = builder.load(R5);
R14,Value R14 = builder.iCmp("eq", R13, context.constInt("i64", -1));
bb15,BasicBlock bb15 = foo.appendBasicBlock();
bb20,BasicBlock bb20 = foo.appendBasicBlock();
R17,Value R17 = builder.load(R4);
R18,Value R18 = builder.load(R5);
R19,Value R19 = builder.iArithmeticSigned("srem", R17, R18);
R21,Value R21 = builder.load(R3);
fn,FunctionDefn fn = m.addFunctionDefn(name, {returnType: "i1", paramTypes: ["double", "double"]});
bb,BasicBlock bb = fn.appendBasicBlock();
p0,Value p0 = fn.getParam(0);
p1,Value p1 = fn.getParam(1);
res,Value res = builder.fCmp(predicate, p0, p1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "double", paramTypes: ["double", "double"]});
initBlock,BasicBlock initBlock = bar.appendBasicBlock();
v0,Value v0 = bar.getParam(0);
v1,Value v1 = bar.getParam(1);
a,Value a = builder.fArithmetic("fadd", v0, v1);
b,Value b = builder.fArithmetic("fsub", v0, v1);
c,Value c = builder.fArithmetic("fmul", a, b);
d,Value d = builder.fArithmetic("fdiv", c, a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
add,FunctionDecl add = m.getIntrinsicDeclaration("sadd.with.overflow.i64.i64");
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(add, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["double"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
neg,Value neg = builder.fNeg(p0);
context,Context context = new;
m,Module m = context.createModule();
mul,FunctionDecl mul = m.getIntrinsicDeclaration("smul.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(mul, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDecl bar = m.addFunctionDecl("bar", {returnType: "void", paramTypes: []});
bar2,FunctionDecl bar2 = m.addFunctionDecl("bar2", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bbfoo,BasicBlock bbfoo = foo.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bbfoo2,BasicBlock bbfoo2 = foo2.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,ConstValue const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
g,PointerValue g = m.addGlobal("i64", "g1");
g2,PointerValue g2 = m.addGlobal("i64", "g2", addressSpace=2);
g7,ConstPointerValue g7 = m.addGlobal(const1Ty, "g7");
testFn,FunctionDefn testFn = m.addFunctionDefn("testFn", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = testFn.appendBasicBlock();
val1,Value val1 = builder.ptrToInt(g, "i64");
val2,Value val2 = builder.ptrToInt(g2, "i64");
ret,Value ret = builder.iArithmeticWrap("add", val1, val2);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "g1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i8", 1), paramTypes: [pointerType("i8", 1)]});
mask,FunctionDecl mask = m.getIntrinsicDeclaration("ptrmask.p1.i64");
bb,BasicBlock bb = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
result,Value? result = builder.call(mask, [arg, context.constInt("i64",72057594037927928)]);
overflowArithmeticReturnType,StructType overflowArithmeticReturnType = structType(["i64", "i1"]);
overflowArithmeticFunctionType,FunctionType overflowArithmeticFunctionType = {returnType: overflowArithmeticReturnType, paramTypes: ["i64", "i64"]};
context,Context context = new;
m,Module m = context.createModule();
names,IntrinsicFunctionName[] names = ["sadd.with.overflow.i64.i64", "ssub.with.overflow.i64.i64", "smul.with.overflow.i64.i64"];
name,foreach var name in names { FunctionDecl f = m.getIntrinsicDeclaration(name); testLLVMOverflowArithmeticFunctionType(f.functionType); string functionName = "llvm." + name; test:assertEquals(f.functionName, functionName); }
f,FunctionDecl f = m.getIntrinsicDeclaration(name);
functionName,string functionName = "llvm." + name;
context,Context context = new;
m,Module m = context.createModule();
name,IntrinsicFunctionName name = "sadd.with.overflow.i64.i64";
f1,FunctionDecl f1 = m.getIntrinsicDeclaration(name);
f2,FunctionDecl f2 = m.getIntrinsicDeclaration(name);
context,Context context = new;
m,Module m = context.createModule();
attributes,FunctionEnumAttribute[] attributes = ["noreturn", "cold", "nounwind", "readnone", "speculatable", "willreturn"];
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
attribute,foreach var attribute in attributes { fDecl.addEnumAttribute(attribute); test:assertNotExactEquals(fDecl.functionAttributes.indexOf(attribute), ()); }
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
attribute,foreach var attribute in attributes { fDefn.addEnumAttribute(attribute); test:assertNotExactEquals(fDefn.functionAttributes.indexOf(attribute), ()); }
context,Context context = new;
m,Module m = context.createModule();
attribute,EnumAttribute attribute = "cold";
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["i64", "i32"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
v1,Value v1 = builder.sIToFP(p0, "double");
v2,Value v2 = builder.sIToFP(p1, "double");
ret,Value ret = builder.fArithmetic("fadd", v1, v2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g1,ConstPointerValue g1 = m.addGlobal("i64", "g1");
structTy,StructType structTy = context.structCreateNamed("st");
g2,ConstPointerValue g2 = m.addGlobal(structTy, "g2");
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i32", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "i32", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
d,PointerValue d = new (pointerType("i1"), "d");
e,error? e = trap builder.store(s, d);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.call(f, [s]);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.extractValue(s, 0);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,error? e = trap builder.condBr(s,bb,bb);
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i8", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.trunc(arg, "i8");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: ["i64"]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value|error v1 = trap builder.trunc(arg, "i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
structPtrTy,PointerType structPtrTy = pointerType(structTy);
extFnTy,FunctionType extFnTy = {returnType: "void", paramTypes: [structPtrTy]};
extFnPtrTy,PointerType extFnPtrTy = pointerType(extFnTy);
mainFnTy,FunctionType mainFnTy = {returnType: "void", paramTypes: [structPtrTy]};
mainFn,FunctionDefn mainFn = m.addFunctionDefn("main", mainFnTy);
bb,BasicBlock bb = mainFn.appendBasicBlock();
arg,Value arg = mainFn.getParam(0);
v2,PointerValue v2 = builder.alloca(structPtrTy);
v3,Value v3 = builder.load(v2);
v4,PointerValue v4 = builder.getElementPtr(<PointerValue>v3, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
v5,Value v5 = builder.load(v4);
v6,PointerValue v6 = builder.getElementPtr(<PointerValue>v5, [context.constInt("i64", 1)], "inbounds");
v7,Value v7 = builder.load(v6);
v8,Value v8 = builder.load(v2);
v9,PointerValue v9 = builder.bitCast(<PointerValue>v7, extFnPtrTy);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i64")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.getElementPtr(<PointerValue>arg, [context.constInt("i64", 3)]);
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType("i8"), paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
arg_1,Value arg_1 = bar.getParam(0);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: pointerType("i64", 1), paramTypes: [pointerType("i64", 1)]});
fooBB2,BasicBlock fooBB2 = foo2.appendBasicBlock();
arg_2,Value arg_2 = foo2.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
f1,FunctionDefn f1 = foo1(builder, m);
f2,FunctionDefn f2 = foo2(builder, m);
f3,FunctionDefn f3 = foo3(context, builder, m);
f4,FunctionDefn f4 = foo4(builder, m);
test,FunctionDefn test = m.addFunctionDefn("test", {returnType:"void", paramTypes:[]});
bb5,BasicBlock bb5 = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,Value R3;
R_3,Value|() R_3 = builder.call(f3, []);
R4,Value R4;
R_4,Value|() R_4 = builder.call(f4, [context.constInt("i64", 12), context.constInt("i64", 13)]);
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType:"void", paramTypes:[]});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType:"void", paramTypes:["i64","i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType:"i64", paramTypes:[]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
C1,Value C1 = cx.constInt("i64", 21);
foo4,FunctionDefn foo4 = m.addFunctionDefn("foo4", {returnType:"i64", paramTypes:["i64", "i64"]});
bb4,BasicBlock bb4 = foo4.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo4.getParam(0);
R1,Value R1 = foo4.getParam(1);
R5,Value R5 = builder.load(R4);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
genFn,FunctionDecl genFn = m.addFunctionDecl("genFn", {returnType: pointerType("i64", 3), paramTypes:[]});
pty0,PointerType pty0 = pointerType("i64", 0);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: pty0, paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
val,Value? val = builder.call(genFn, []);
retVal,Value retVal = builder.addrSpaceCast(<PointerValue>val, pty0);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "sadd.with.overflow.i64.i64");
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="main", linkageName="test", file=fileData, lineNo=1, ty=functionTy, scopeLine=0);
tyMeta,Metadata tyMeta = dIBuilder.createBasicType(name="myInt", encoding="signed", sizeInBits=64);
varMeta,Metadata varMeta = dIBuilder.createAutoVariable(ty=tyMeta, scope=functionData, name="myVar", lineNo=2, file=fileData);
bMeta,Metadata bMeta = dIBuilder.createAutoVariable(ty=dIBuilder.createBasicType(name="constInt", encoding="signed", sizeInBits=64), scope=functionData, name="B", lineNo=2, file=fileData);
charMeta,Metadata charMeta = dIBuilder.createBasicType(name="char", encoding="signed_char", sizeInBits=8);
taggedPtrMeta,Metadata taggedPtrMeta = dIBuilder.createTypedef(dIBuilder.createPointerType(pointeeTy=charMeta, sizeInBits=64, addressSpace=1), "TaggedPtr", fileData, 0, scope=fileData);
cMeta,Metadata cMeta = dIBuilder.createAutoVariable(ty=taggedPtrMeta, scope=functionData, name="C", lineNo=2, file=fileData);
emptyExpr,Metadata emptyExpr = dIBuilder.createExpression([]);
bScope,Metadata bScope = dIBuilder.createLexicalBlock(functionData, fileData, 3, 2);
loc1,Metadata loc1 = dIBuilder.createDebugLocation(2, 2, bScope);
loc2,Metadata loc2 = dIBuilder.createDebugLocation(3, 2, functionData);
loc3,Metadata loc3 = dIBuilder.createDebugLocation(4, 2, functionData);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
a,PointerValue a = builder.alloca("i64");
b,PointerValue b = builder.alloca("i64");
c,PointerValue c = builder.alloca(pointerType("i8", 1));
initA,Value initA = context.constInt("i64", 10);
retVal,Value retVal = builder.iArithmeticWrap("add", builder.load(a), context.constInt("i64", 1));
context,Context context = new;
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "void", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
builder,Builder builder = context.createBuilder();
fn,FunctionDefn fn = m.addFunctionDefn(fnName, {returnType: "double", paramTypes: []});
initBlock,BasicBlock initBlock = fn.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
p1,Value p1 = mainFunction.getParam(0);
p2,Value p2 = mainFunction.getParam(1);
v,PointerValue v = builder.alloca("i64");
a,Value a = builder.iArithmeticWrap("add", p1, p2);
greater,BasicBlock greater = mainFunction.appendBasicBlock("greater");
less,BasicBlock less = mainFunction.appendBasicBlock("less");
isGreater,Value isGreater = builder.iCmp("sge", a, context.constInt("i64", 10));
b_1,Value b_1 = builder.iArithmeticWrap("sub", a, context.constInt("i64", 5));
common,BasicBlock common = mainFunction.appendBasicBlock();
b_2,Value b_2 = builder.iArithmeticWrap("add", a, context.constInt("i64", 5));
b_3,Value b_3 = builder.load(v);
context,Context context = new;
m,Module m = context.createModule();
builder,Builder builder = context.createBuilder();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,Value R5 = builder.load(R4);
R6,Value R6 = builder.iCmp("eq", R5, context.constInt("i64", 0));
bb7,BasicBlock bb7 = foo.appendBasicBlock();
bb10,BasicBlock bb10 = foo.appendBasicBlock();
bb13,BasicBlock bb13 = foo.appendBasicBlock();
bb14,BasicBlock bb14 = foo.appendBasicBlock();
R8,Value R8 = builder.load(R3);
R9,Value R9 = builder.iCmp("eq", R8, context.constInt("i64", int:MIN_VALUE));
R11,Value R11 = builder.load(R4);
R12,Value R12 = builder.iCmp("eq", R11, context.constInt("i64", -1));
R15,Value R15 = builder.load(R3);
R16,Value R16 = builder.load(R4);
R17,Value R17 = builder.iArithmeticSigned("sdiv", R15, R16);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
ty,foreach var ty in intTypes { string out = typeToString(ty, context); test:assertEquals(out, ty); }
out,string out = typeToString(ty, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
ty,foreach var ty in intTypes { PointerType pTy = pointerType(ty); string out = typeToString(pTy, context); test:assertEquals(out, string `ptr`); }
pTy,PointerType pTy = pointerType(ty);
out,string out = typeToString(pTy, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
ty,StructType ty = structType(intTypes);
context,Context context = new;
out,string out = typeToString(ty, context);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
elements,ConstValue[] elements = [context.constInt("i64", 1), context.constInt("i64", 10), context.constInt("i64", 100)];
array,ConstValue array = context.constArray("i64", elements);
retTy,ArrayType retTy = arrayType("i64", 3);
fn,FunctionDefn fn = m.addFunctionDefn("test", {returnType: retTy, paramTypes:[]});
bb,BasicBlock bb = fn.appendBasicBlock();
msg,string msg = "something impossible happened";
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseIntersection(tok);
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
tds,TypeDesc[] tds = [lhs];
opPos,Position[] opPos = [];
right,TypeDesc right = op == "|" ? check parseIntersection(tok) : check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
unary,UnaryTypeDesc unary = { startPos, endPos, op: "!", opPos: startPos, td };
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parsePrimaryTypeDesc(tok);
opPos,Position opPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
optionalTd,UnaryTypeDesc optionalTd = { startPos, endPos, op: "?", opPos, td };
dimensions,SimpleConstExpr?[] dimensions = [];
endPos,Position? endPos = ();
array,ArrayTypeDesc array = { startPos, endPos: <Position>endPos, member: td , dimensions };
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
pos,Position pos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
constituent,TypeDesc constituent = check parseTypeParam(tok);
endPos,Position endPos = tok.currentEndPos();
rest,var rest = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
detail,var detail = check parseTypeParam(tok);
row,TypeDesc row = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
prefix,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
typeName,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
valueExpr,SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);
td,TypeDesc td = check parseTypeDesc(tok);
startPos,Position startPos = tok.currentStartPos();
params,FunctionTypeParam[] params = namedParams ?: [];
paramStartPos,Position paramStartPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
ret,TypeDesc? ret = ();
t,Token? t = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
members,TypeDesc[] members = [];
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
rest,TypeDesc? rest = ();
td,TypeDesc td = check parseTypeDesc(tok);
fields,FieldDesc[] fields = [];
rest,TypeDesc? rest = ();
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
fields,FieldDesc[] fields = [];
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
name,string name = check tok.expectIdentifier();
endPos,Position endPos = check tok.expectEnd(";");
importDecls,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
decl,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
moduleLevelDefns,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
defn,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);
org,string? org = decl.org;
prefix,string? prefix = decl.prefix;
nameNodes,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
i,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
td,SubsetBuiltinTypeDesc? td = defn.td;
name,string? name = param.name;
body,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
stmt,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
name,string? name = stmt.name;
returnExpr,Expr? returnExpr = stmt.returnExpr;
lValue,LExpr|WILDCARD lValue = stmt.lValue;
ifFalse,StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;
clauses,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
clause,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
childNodes,SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];
i,SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];
i,return from int i in 0 ..< patterns.length() select nonTerminalSyntaxNode(patterns[i], childNodes[i]);
prefix,string? prefix = expr.prefix;
arg,return nonTerminalSyntaxNode(expr, prefix != () ? [{ name: prefix, pos: expr.qNamePos }, { token: ":" }] : (), { name: expr.funcName, pos: prefix == () ? expr.qNamePos : () }, { token: "(", pos: expr.openParenPos }, (joinSyntaxNodesWithSeperator((from Expr arg in expr.args select syntaxNodeFromExpr(arg)), { token: "," })), { token: ")" });
arg,return nonTerminalSyntaxNode(expr, syntaxNodeFromExpr(expr.target), { token: ".", pos: expr.opPos }, { name: expr.methodName, pos: expr.namePos }, { token: "(", pos: expr.openParenPos }, (joinSyntaxNodesWithSeperator((from Expr arg in expr.args select syntaxNodeFromExpr(arg)), { token: "," })), { token: ")" });
member,return nonTerminalSyntaxNode(expr, { token: "[", pos: expr.startPos }, (joinSyntaxNodesWithSeperator((from Expr member in expr.members select syntaxNodeFromExpr(member)), { token: "," })), { token: "]" });
f,return nonTerminalSyntaxNode(expr, { token: "{", pos: expr.startPos }, (joinSyntaxNodesWithSeperator((from Field f in expr.fields select syntaxNodeFromField(f)), { token: "," })), { token: "}" });
prefix,string? prefix = expr.prefix;
identifierPos,Position? identifierPos = prefix == () ? expr.qNamePos : ();
token,string token;
typeSuffix,FpTypeSuffix? typeSuffix = expr.typeSuffix;
op,BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;
memberNodes,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
member,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
rest,TypeDesc? rest = td.rest;
dimensions,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
dimension,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
rest,TypeDesc|INCLUSIVE_RECORD_TYPE_DESC? rest = td.rest;
fields,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
f,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
params,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
param,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
retTd,TypeDesc? retTd = td.ret;
operand,return nonTerminalSyntaxNode(td, joinSyntaxNodesWithSeperator(from TypeDesc operand in td.tds select syntaxNodeFromTypeDesc(operand), { token: td.op }));
prefix,string? prefix = td.prefix;
childNodes,SubSyntaxNode[] childNodes = [{ token: td.op, pos: td.startPos }, syntaxNodeFromTypeDesc(td.td)];
token,string token;
valueExpr,ExtendedLiteralExpr valueExpr = td.valueExpr;
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList(nodes);
newNodes,SubSyntaxNode[] newNodes = [];
i,foreach int i in 0 ..< nodes.length() { if i > 0 { newNodes.push(seperator); } newNodes.push(nodes[i]); }
nodes,SubSyntaxNode[] nodes = [];
node,foreach var node in arr { if node is SubSyntaxNode[] { foreach var child in node { nodes.push(child); } } else if node is SubSyntaxNode { nodes.push(node); } }
child,foreach var child in node { nodes.push(child); }
words,Word[] words = [];
childNodes,SubSyntaxNode[] childNodes = node.childNodes;
child,foreach var child in childNodes { if child is TerminalSyntaxNode { OutputFlags flags = terminalSyntaxNodeFlags(child, node); if (flags & CLING_PREV) != 0 { words.push(<Word>CLING); } if (flags & NEWLINE_BEFORE) != 0 { words.push(<Word>NEWLINE); } if (flags & SINGLE_LINE_START) != 0 { words.push(<Word>SINGLE_LINE_START); } words.push(terminalSyntaxNodeToString(child, flags)); if (flags & SINGLE_LINE_END) != 0 { words.push(<Word>SINGLE_LINE_END); } if (flags & CLING_NEXT) != 0 { words.push(<Word>CLING); } if (flags & NEWLINE_AFTER) != 0 { words.push(<Word>NEWLINE); } } else { syntaxNodeToWords(words, child); } }
flags,OutputFlags flags = terminalSyntaxNodeFlags(child, node);
parent,AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();
name,string name = parent is FunctionCallExpr ? parent.funcName : parent.methodName;
astNode,AstNode astNode = node.astNode;
REVERSE_ESCAPES,string[] chunks = ["\""];
chunks,foreach var ch in str { string:Char? singleEscaped = REVERSE_ESCAPES[ch]; if singleEscaped == () { int cp = ch.toCodePointInt(); if 0x20 <= cp && cp < 0x7F { chunks.push(ch); } else { chunks.push("\\u{", cp.toHexString().toUpperAscii(), "}"); } } else { chunks.push("\\", singleEscaped); } }
ch,string:Char? singleEscaped = REVERSE_ESCAPES[ch];
Char,int cp = ch.toCodePointInt();
cp,string[] parts = [];
parts,string[] lines = [];
lines,boolean skipSpace = true;
skipSpace,boolean ignoreNewLine = false;
ignoreNewLine,int indentSize = 0;
indentSize,foreach int i in 0 ..< words.length() { Word token = words[i]; Word? nextToken = i < words.length() - 1 ? words[i + 1] : (); if token is string { if (token == "}" || token == "|}") { if !ignoreNewLine { indentSize -= 1; parts = addNewLine(parts, lines, indentSize); } else { parts.push(" "); } } if !skipSpace && !omitSpaceBefore(token) { parts.push(" "); } parts.push(token); skipSpace = omitSpaceAfter(token); if (token == "{" || token == "{|") { if !ignoreNewLine { indentSize += 1; parts = addNewLine(parts, lines, indentSize); } else if nextToken != "}" && nextToken != "|}" { parts.push(" "); } } if (token == "}" || token == "|}") && nextToken != ";" && !ignoreNewLine { parts = addNewLine(parts, lines, indentSize); } } else if token == CLING { skipSpace = true; } else if token is SINGLE_LINE_START{ ignoreNewLine = true; } else if token is SINGLE_LINE_END { ignoreNewLine = false; } else if token == NEWLINE && !ignoreNewLine { skipSpace = true; parts = addNewLine(parts, lines, indentSize); } }
i,Word token = words[i];
token,Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();
nextToken,string lastLine = string
lastLine,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
filteredLines,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
line,string[] content = [];
content,foreach int i in 0 ..< indentSize { content.push(" "); }
i,null
keywords,:Char?[] { string:Char?[] fragFixed = [];
Char,FixedToken?[] ft = [];
Char,foreach int i in 0 ..< keywords.length() { ft[FRAG_KEYWORD + i] = keywords[i]; }
fragTokens,foreach int cp in 0x20 ..< 0x80 { string s = checkpanic string:fromCodePointInt(cp); if s is SingleCharDelim { ft[cp] = s; } }
ft,string s = checkpanic string
i,readonly & FragCode[] fragCodes = line.fragCodes;
cp,readonly & string[] fragments = line.fragments;
s,int fragCodeIndex = 0;
fragCodes,int fragmentIndex = 0;
fragments,int i = 0;
fragCodeIndex,FragCode code = fragCodes[fragCodeIndex];
fragmentIndex,FixedToken? ft = fragTokens[<int>code];
i,string[] lineContent = [];
code,readonly & FragCode[] fragCodes = line.fragCodes;
ft,int fragmentIndex = 0;
lineContent,foreach int fragCodeIndex in 0 ..< fragCodes.length() { FragCode code = fragCodes[fragCodeIndex]; if code <= VAR_FRAG_MAX { lineContent.push(line.fragments[fragmentIndex]); fragmentIndex += 1; } else if code >= FRAG_FIXED_TOKEN { lineContent.push(<string>fragTokens[<int>code]); } else { lineContent.push(<string>fragFixed[<int>code]); } }
fragCodes,FragCode code = fragCodes[fragCodeIndex];
fragmentIndex,string hexDigits = fragment.substring(3, fragment.length() - 1);
fragCodeIndex,int codePoint = check int
code,string:Char
hexDigits,ScannedLine[] result = from var l in lines select scanLine(l);
codePoint,ScannedLine[] result = from var l in lines select scanLine(l);
:Char,int[] codePoints = line.toCodePointInts();
result,FragCode[] fragCodes = [];
l,int[] endIndex = [];
codePoints,string[] fragments;
fragCodes,int nVarFragments = 0;
endIndex,foreach int i in 0 ..< fragCodes.length() { if fragCodes[i] <= VAR_FRAG_MAX { fragments[nVarFragments] = fragments[i]; nVarFragments += 1; } }
fragments,string[] fragments = [];
nVarFragments,int startIndex = 0;
i,foreach int index in endIndex { fragments.push(str.substring(startIndex, index)); startIndex = index; }
fragments,string[] lines = [];
startIndex,int i = 0;
index,int lineStartIndex = 0;
lines,int? cr = ();
i,foreach var ch in str { if ch == "\n" { if cr == () || cr + 1 != i { lines.push(str.substring(lineStartIndex, i)); } lineStartIndex = i + 1; } else if ch == "\r" { lines.push(str.substring(lineStartIndex, i)); cr = i; lineStartIndex = i + 1; } i += 1; }
lineStartIndex,final int len = codePoints.length();
cr,int i = startIndex;
ch,int cp = codePoints[i];
len,int cp2 = codePoints[i];
i,int cp2 = codePoints[i];
cp,int? endIndex = scanFractionExponent(codePoints, i);
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int? endIndex = scanHexDigits(codePoints, i + 1);
cp2,final int startResultLength = result.fragCodes.length();
cp2,int i = startIndex;
endIndex,int len = codePoints.length();
startResultLength,int cp = codePoints[i];
i,int cp2 = codePoints[i];
len,int? endIndex = scanNumericEscape(codePoints, i + 1);
cp,int len = codePoints.length();
cp2,int i = startIndex;
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
endIndex,int i = scanOptDigits(codePoints, startIndex);
len,int len = codePoints.length();
i,int cp = codePoints[i];
i,int? endIndex = scanFractionExponent(codePoints, i + 1);
len,int? endIndex = scanExponent(codePoints, i + 1);
cp,int cp = codePoints[i];
endIndex,int len = codePoints.length();
endIndex,int i = startIndex;
cp,int i = startIndex;
len,int len = codePoints.length();
i,int cp = codePoints[i];
i,int? endIndex = scanExponent(codePoints, i + 1);
len,int i = startIndex;
cp,int len = codePoints.length();
endIndex,int cp = codePoints[i];
i,int len = codePoints.length();
len,int i = startIndex;
cp,int[] ei = result.endIndex;
len,int len = ei.length();
i,int startIndex = len > 0 ? ei[len - 1] : 0;
ei,int? ki = keywordIndex(codePoints, startIndex, i);
len,string kw = checkpanic string
startIndex,foreach int i in 0 ..< keywords.length() { if keywords[i] == kw { return i; } }
ki,FragCode[] fc = result.fragCodes;
kw,int len = fc.length();
i,int len = codePoints.length();
fc,int cp = codePoints[i];
len,null
len,null
cp,null
startPos,Position startPos = tok.currentStartPos();
stmts,Stmt[] stmts = [];
endPos,Position endPos = tok.currentEndPos();
closeBracePos,Position closeBracePos = tok.currentStartPos();
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
peeked,var peeked = tok.peek(skipQualIdent=true);
td,TypeDesc td = check parseTypeDesc(tok);
isTypeDesc,boolean isTypeDesc = check savePreparseRestore(tok, preparseArrayTypeDesc);
endPos,Position endPos = check tok.expectEnd(";");
stmt,BreakContinueStmt stmt = { startPos, endPos, breakContinue:<BreakContinue>cur };
peeked,var peeked = tok.peek();
state,TokenizerState state = tok.save();
isTypeDesc,boolean isTypeDesc = check func(tok);
name,string name;
prefix,string? prefix;
expr,FunctionCallExpr expr = check finishFunctionCallExpr(tok, prefix, name, startPos);
endPos,Position endPos = tok.previousEndPos();
lExpr,LExpr lExpr = { startPos, endPos, name, qNamePos: startPos, prefix };
cur,Token? cur = tok.current();
opPos,Position opPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check startPrimaryExpr(tok);
cur,Token? cur = tok.current();
endPos,Position endPos = check tok.expectEnd(";");
primary,Expr primary = check finishPrimaryExpr(tok, expr, startPos);
endPos,Position endPos = check tok.expectEnd(";");
stmt,CallStmt stmt;
t,Token? t = tok.current();
innerKwPos,Position innerKwPos = tok.currentStartPos();
operandStmt,CallStmt operandStmt = check finishCheckingCallStmt(tok, t, innerKwPos);
operandStmt,CallStmt operandStmt = check parseMethodCallStmt(tok);
operand,Expr operand = check parsePrimaryExpr(tok);
expr,CheckingCallExpr expr = { startPos: kwPos, endPos: operand.endPos, checkingKeyword, kwPos, operand};
endPos,Position endPos = check tok.expectEnd(";");
opPos,Position opPos = tok.currentStartPos();
expr,Expr expr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
stmt,AssignStmt stmt = { startPos, endPos, opPos, lValue, expr };
opStr,string opStr = op;
binOp,BinaryArithmeticOp|BinaryBitwiseOp binOp = <BinaryArithmeticOp|BinaryBitwiseOp> opStr.substring(0, opStr.length() - 1);
stmt,CompoundAssignStmt stmt = { startPos, endPos, opPos, lValue, expr, op: binOp };
td,TypeDesc td = check parseTypeDesc(tok);
cur,Token? cur = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string|WILDCARD name;
opPos,Position opPos = check tok.expectStart("=");
initExpr,Expr initExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
returnExpr,Expr? returnExpr;
endPos,Position endPos;
panicExpr,Expr panicExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
ifFalse,IfElseStmt|StmtBlock? ifFalse;
condition,Expr condition = check parseExpr(tok);
ifTrue,StmtBlock ifTrue = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
cur,Token? cur = tok.current();
ifFalseStartPos,Position ifFalseStartPos = tok.currentStartPos();
condition,Expr condition = check parseExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
kwPos,Position kwPos = check tok.expectStart("in");
range,RangeExpr range = check parseRangeExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
expr,Expr expr = check parseInnerExpr(tok);
clauses,MatchClause[] clauses = [];
endPos,Position endPos = tok.currentEndPos();
startPos,Position startPos = tok.currentStartPos();
patterns,MatchPattern[] patterns = check parseMatchPatternList(tok);
opPos,Position opPos = check tok.expectStart("=>");
block,StmtBlock block = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
patterns,MatchPattern[] patterns = [];
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
closeBracketMap,boolean? parenResult = check preparseBracketed(tok, close);
parenResult,Token? t = tok.current();
t,boolean? squareResult = check preparseBracketed(tok, "]");
squareResult,Token? t = tok.current();
t,boolean? result = check preparseBracketed(tok, closeBracketMap.get(<string>t));
result,null
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
members,var [members, _] = check parseExprList(tok, "]");
endPos,Position endPos = tok.previousEndPos();
expr,ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };
fields,Field[] fields = check parseFields(tok);
endPos,Position endPos = tok.previousEndPos();
expr,MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseLogicalAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseLogicalAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseOrExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseOrExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseXorExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseXorExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseEqualityExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseEqualityExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseRelationalExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseRelationalExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseShiftExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseShiftExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };
t2,Token? t2 = tok.current();
kwPos,Position kwPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
lower,Expr lower = check parseAdditiveExpr(tok);
opPos,Position opPos = check tok.expectStart("..<");
upper,Expr upper = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseAdditiveExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
shift,BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseMultiplicativeExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseMultiplicativeExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseUnaryExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };
kwPos,Position kwPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };
opPos,Position opPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,TypeCastExpr expr = { startPos, endPos, opPos, td, operand };
startPos,Position startPos = tok.currentStartPos();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,string? prefix;
name,string name;
prefix,[prefix, name] = check parseOptQualIdentifier(tok, t[1]);
name,[prefix, name] = check parseOptQualIdentifier(tok, t[1]);
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };
expr,FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: () };
innerExpr,Expr innerExpr = check parseInnerExpr(tok);
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
expr,LiteralExpr expr = { startPos, endPos, value: () };
kwPos,Position kwPos = tok.currentStartPos();
message,Expr message = check parseExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
accessEndPos,Position accessEndPos = check tok.expectEnd("]");
accessExpr,MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };
qnamePos,Position qnamePos = tok.currentStartPos();
name,string name = check parseIdentifierOrMethodName(tok);
endPos,Position endPos = tok.previousEndPos();
fieldAccessExpr,FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };
t,Token? t = tok.current();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
exprs,Expr[] exprs = [];
expr,Expr expr = check parseExpr(tok);
t,Token? t = tok.current();
closeTerminatorPos,Position closeTerminatorPos = tok.currentStartPos();
fields,Field[] fields = [];
f,Field f = check parseField(tok);
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
isIdentifier,boolean isIdentifier = t[0] == IDENTIFIER;
name,string name = t[1];
colonPos,Position colonPos = tok.currentStartPos();
value,Expr value = check parseExpr(tok);
endPos,Position endPos = tok.previousEndPos();
f,Field f = { startPos, endPos, colonPos, name, value, isIdentifier };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = check tok.expectEnd(")");
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
name,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
untypedLiteral,, var untypedLiteral
typeSuffix,, var typeSuffix] => { Position
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits };
:fromHexString,: int:fromHexString(digits);
class,Tokenizer tok = new(self.tokState.file);
tok,Tokenizer tok = new (file);
,Tokenizer tok = scanned.tokenizer();
tok,ModuleLevelDefn[] defns = [];
tok,ModulePart part = { file: scanned.sourceFile(), partIndex: scanned.partIndex, defns, importDecls: scanned.importDecls };
defns,Tokenizer tok = new (file);
part,Expr expr = check parseExpr(tok);
tok,ImportDecl[] imports = [];
expr,Token? t = tok.current();
imports,ImportDecl im = check parseImportDecl(tok, partIndex);
t,Position startPos = tok.currentStartPos();
im,Position namePos = tok.currentStartPos();
startPos,string firstModuleName = check validImportPart(tok);
namePos,string? org = ();
firstModuleName,[string, string...] names = [firstModuleName];
org,string? prefix = check parseImportPrefix(tok);
names,Position endPos = check tok.expectEnd(";");
prefix,string[] names = [];
endPos,string identifier = check tok.expectIdentifier();
names,string? prevChar = ();
identifier,foreach var ch in identifier { if ch == "_" { if prevChar == () { return tok.err("identifier in an import must not have leading underscores"); } else if prevChar == "_" { return tok.err("identifier in an import must not have consecutive underscores"); } } prevChar = ch; }
prevChar,Token? t = tok.current();
ch,Token? t = tok.current();
t,Position startPos = tok.currentStartPos();
t,Visibility vis;
startPos,Position namePos = tok.currentStartPos();
vis,string name = check tok.expectIdentifier();
namePos,TypeDesc td = check parseTypeDesc(tok);
name,Position endPos = check tok.expectEnd(";");
td,Token? t = tok.current();
endPos,SubsetBuiltinTypeDesc? td = ();
t,Position tdStartPos = tok.currentStartPos();
td,Position tdEndPos = tok.currentEndPos();
tdStartPos,Position namePos = tok.currentStartPos();
tdEndPos,string name = check tok.expectIdentifier();
namePos,Expr expr = check parseInnerExpr(tok);
name,Position endPos = check tok.expectEnd(";");
expr,Position namePos = tok.currentStartPos();
endPos,string name = check tok.expectIdentifier();
namePos,FunctionParam [] params = [];
name,FunctionTypeDesc typeDesc = check parseFunctionTypeDesc(tok, params);
params,StmtBlock body = check parseStmtBlock(tok);
typeDesc,Position endPos = tok.previousEndPos();
body,FunctionDefn defn = { startPos, endPos, params, typeDesc, name, vis, namePos, body, part };
endPos,string message = "parse error";
defn,Token? t = tok.current();
message,null
t,null
ESCAPES,string str = "";
lineIndex,int fragCodeIndex = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
fragments,FragCode fragCode = fragCodes[fragCodeIndex];
fragCodeIndex,string fragment = self.getFragment();
codePointIndex,string|error ch = unicodeEscapeValue(fragment);
fragmentIndex,string number = self.getFragment();
tokenStartCodePointIndex,string number = self.getFragment();
prevTokenEndCodePointIndex,FixedToken? ft = fragTokens[<int>fragCode];
prevTokenEndLineIndex,readonly & FragCode[] fragCodes = self.fragCodes;
mode,int fragCodeIndex = self.fragCodeIndex;
file,int lineIndex = self.lineIndex;
curTok,FragCode fragCode = fragCodes[fragCodeIndex];
str,int i = self.fragCodeIndex;
fragCodeIndex,FragCode[] fragCodes = self.fragCodes;
fragCodes,FragCode nextFragCode = fragCodes[i];
fragCode,var [lineIndex, codePointIndex] = unpackPosition(pos);
fragment,var [lineIndex, codePointIndex] = unpackPosition(pos);
ch,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
number,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
number,string fragment = self.fragments[self.fragmentIndex];
ft,ScannedLine scannedLine = self.lines[self.lineIndex];
fragCodes,Token? t = self.curTok;
fragCodeIndex,d:Message msg;
lineIndex,Position pos = self.currentEndPos();
fragCode,Position pos = self.currentStartPos();
i,d:Message msg;
fragCodes,Token? t = self.curTok;
nextFragCode,ScannedLine scannedLine = self.lines[self.lineIndex - 1];
lineIndex,Position startPos;
codePointIndex,Position? endPos;
fragIndex,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
fragmentIndex,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
fragment,ScannedLine line = self.scannedLine(startLineNum);
scannedLine,string[] lineFragments = scanLineFragments(line);
t,string lineContent = "".'join(...lineFragments);
msg,int endColumnNum;
pos,int endLineNum;
pos,[endLineNum, endColumnNum] = self.lineColumn(endPos);
msg,[endLineNum, endColumnNum] = self.lineColumn(endPos);
t,var [lineNum, startColumnNum] = self.lineColumn(startPos);
scannedLine,var [lineNum, startColumnNum] = self.lineColumn(startPos);
class,ScannedLine line = self.scannedLine(lineNum);
startPos,int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);
endPos,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
startLineNum,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
startColumnNum,string[] fragments = line.fragments;
line,FragCode[] fragCodes = line.fragCodes;
lineFragments,int endCodePointIndex = startCodePointIndex;
lineContent,int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);
endColumnNum,int nCodePoints = 0;
endLineNum,int fragmentIndex = 0;
endLineNum,int nFragments = fragments.length();
endColumnNum,int endCodePointIndex = startCodePointIndex;
lineNum,foreach int fragmentIndex in startFragmentIndex ..< fragments.length() { endCodePointIndex += fragments[fragmentIndex].length(); FragCode fragCode = fragCodes[fragmentIndex]; if fragCode == FRAG_STRING_CLOSE { break; } }
startColumnNum,FragCode fragCode = fragCodes[fragmentIndex];
line,null
endColumnNum,null
,null
fragIndex,null
fragmentIndex,null
fragments,null
fragCodes,null
endCodePointIndex,null
fragmentIndex,null
nCodePoints,null
fragmentIndex,null
nFragments,null
endCodePointIndex,null
fragmentIndex,null
fragCode,null
file,SourceFile file = createSourceFile([str], { filename: "<internal>" });
tok,Tokenizer tok = new(file);
left,Identifier|TypeProjection left = check parseTypeProjection(tok);
t,Token? t = tok.current();
op,SubtypeTestOp op;
right,Identifier|TypeProjection right = check parseTypeProjection(tok);
identifier,Identifier identifier = check tok.expectIdentifier();
t,Token? t = tok.current();
index,int|Identifier index;
CASE_START_LENGTH,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
actualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
normalizedActualNode,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
actualNodeLines,SyntaxNode node;
node,SourceFile file = createSourceFile(lines, { filename: k });
file,Tokenizer tok = new (file);
tok,SourceFile file = createSourceFile(lines, { filename: k });
file,Tokenizer tok = new (file);
tok,err:Syntax|Token? t = advance(tok, k, lines);
t,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
lc,string src = lines[lc[0] - 1];
src,int tStart = lc[1];
tStart,string tStr = tokenToString(t);
tStr,string srcAtPos = src.substring(tStart, tStart + tStr.length());
srcAtPos,err:Syntax? e = tok.advance();
e,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
all,int invalidCases = all.length();
invalidCases,map<ParserTestCase> valid = check readParserTests();
valid,foreach var [k, v] in valid.entries() { all[k] = ["V", v[2]]; }
k,foreach var [k, v] in valid.entries() { all[k] = ["V", v[2]]; }
v,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
sources,map<TokenizerTestCase> tests = {};
tests,foreach var s in sources { tests[s[1]] = [s[0], splitIntoLines(s[1])]; }
s,map<ParserTestCase> tests = {};
tests,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
testData,foreach var s in testData { if s is string[] { string[] expected; string subject = s[2]; string[] subjectLines = splitIntoLines(subject); if s.length() == 4 { expected = splitIntoLines(s[3]); } else { expected = subjectLines; } if tests.hasKey(subject) { test:assertFail("duplicate test: " + subject); } string rule = s[1]; if rule is ProductionRule { tests[subject] = [s[0], rule, subjectLines, expected]; } else { test:assertFail("invalid rule: " + rule); } } }
s,string[] expected;
expected,string subject = s[2];
subject,string[] subjectLines = splitIntoLines(subject);
subjectLines,string rule = s[1];
rule,var testFiles = check file:readDir("modules/front.syntax/tests/data");
testFiles,foreach var f in testFiles { string path = f.absPath; string base = check file:basename(path); if !base.endsWith(SOURCE_EXTENSION) { continue; } string[] src = check readCase(path); string parentDir = check file:parentPath(path); string canonFile = check file:joinPath(parentDir, canonFileName(base)); string[] expected; if check file:test(canonFile, file:EXISTS) { expected = check readCase(canonFile); } else { expected = src; } [Kind, string] baseParts = check splitTestName(base); string rule = baseParts[1]; if rule is ProductionRule { tests["file:" + base] = [baseParts[0], rule, src, expected]; } else { test:assertFail("invalid rule: " + rule); } }
f,string path = f.absPath;
path,string base = check file:basename(path);
base,string[] src = check readCase(path);
src,string parentDir = check file:parentPath(path);
parentDir,string canonFile = check file:joinPath(parentDir, canonFileName(base));
canonFile,string[] expected;
expected,[Kind, string] baseParts = check splitTestName(base);
baseParts,string rule = baseParts[1];
rule,int len = base.length();
len,int kindPos = base.indexOf("-") ?: 0;
kindPos,string kind = base.substring(0, kindPos);
kind,int afterKindPos = min(kindPos + 1, len);
afterKindPos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
rulePos,string rule = base.substring(afterKindPos, rulePos);
rule,string[] lines = check io:fileReadLines(path);
lines,string[] caseLines = [];
caseLines,boolean inCase = false;
inCase,int indented = 0;
indented,foreach var line in lines { string trimLine = line.trim(); if trimLine == CASE_START && line.endsWith(CASE_START) { inCase = true; indented = line.length() - CASE_START_LENGTH; continue; } if trimLine == CASE_END { break; } if inCase { caseLines.push(line.substring(indented)); } }
line,string trimLine = line.trim();
trimLine,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
sansExt,null
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));
baseTestDir,string baseTestDir = check file:joinPath(baseDir, testDir);
transformedTestDir,string transformedTestDir = check file:joinPath(transformedDir, testDir);
skipped,TestDiffResult[] skipped = [];
changed,TestDiffResult[] changed = [];
unchanged,TestDiffResult[] unchanged = [];
newSkipped,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newUnchanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
newChanged,var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));
baseTestFile,string baseTestFile = check file:joinPath(baseTestDir, test);
transformedTestFile,string transformedTestFile = check file:joinPath(transformedTestDir, test);
baseTests,TestCase[] baseTests = check parseTests(baseTestFile);
transformedTests,TestCase[] transformedTests = check parseTests(transformedTestFile);
lines,string[] lines = check io:fileReadLines(path);
content,string[] content = [];
description,string description = "";
tests,TestCase[] tests = [];
s,State s = CONTENT;
baseIndex,int baseIndex = 0;
transformedIndex,int transformedIndex = 0;
skipped,TestDiffResult[] skipped = [];
unchanged,TestDiffResult[] unchanged = [];
changed,TestDiffResult[] changed = [];
baseDescription,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
baseContent,var { description: baseDescription, content: baseContent } = baseTests[baseIndex];
transformedDescription,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
transformedContent,var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];
body,string[] body = [];
currentPath,string currentPath = "";
path,string path = diff.base.path;
currentPath,string currentPath = "";
path,string path = diff.base.path;
parts,string[] parts = check file:splitPath(absPath);
skipList,string? skipList = opts.skipList;
skipLabels,string[][] skipLabels = skipList != () ? check parseSkipList(skipList) : [];
skipped,int skipped = 0;
total,int total = 0;
tests,BaltTestCase[] tests = check parseTest(path);
parts,string[] parts = check file:splitPath(path);
filename,string filename = parts[parts.length() - 1];
dir,string dir = parts[parts.length() - 2];
testCases,BaltTestCase[] testCases = [];
lines,string[] lines = check io:fileReadLines(path);
header,string[] header = [];
labels,string[] labels = [];
content,string[] content = [];
useIoLib,boolean useIoLib = false;
s,State s = BOF;
fBody,var [_, fBody] = parseField(line);
contentLine,var [contentLine, newLabels] = transformContent(line);
newLabels,var [contentLine, newLabels] = transformContent(line);
newContent,string[] newContent = ["import ballerina/io;"];
newLabels,string[] newLabels = [];
initFunc,string initFunc = "function init()";
newLine,string newLine;
starIndex,int? starIndex = line.indexOf("{");
endIndex,int? endIndex = line.indexOf("}");
targetIndex,int targetIndex = <int>line.indexOf("?;");
i,int? i = s.indexOf(":");
fieldName,string fieldName = s.substring(0, i);
fieldValue,string fieldValue = s.substring(i + 1);
labels,string[] labels = [];
content,string[] content = [];
body,string[] body = [];
skipped,int skipped = 0;
index,int index = 0;
skipIndices,int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];
skipTest,boolean skipTest = false;
outputFileName,string outputFileName = string `./tests/${dir}/${filename}`;
invalid,boolean invalid = true;
tc,t:Context tc = mod.getTypeContext();
numBlocks,int numBlocks = self.blocks.length();
vc,VerifyContext vc = new(mod, defn);
entry,Label entry = 0;
cx,VerifyCodeContext cx = check vc.verifyCodeContext(code);
params,RegSet params = check verifyParamRegs(vc, code.registers);
block,BasicBlock block = cx.blocks[current];
term,Insn term = check blockTerminator(cx, block, predPos);
termPos,Position termPos = term.pos;
onPanic,Label? onPanic = block.onPanic;
cycle,boolean cycle = cx.preds[child];
fid,int fid = cx.fwdInDegrees[child];
i,int i = 0;
insns,Insn[] insns = cx.blocks[i].insns;
paramRegs,RegSet paramRegs = [];
afterParams,boolean afterParams = false;
block,BasicBlock block = cx.blocks[current];
flows,RegFlow[] flows = cx.blocksFlows[current];
regs,RegSet regs = mergeFlows(flows);
afterMerge,boolean afterMerge = false;
operands,| var { args: operands }
onPanic,Label? onPanic = block.onPanic;
term,Insn term = check blockTerminator(cx, block, viaPos);
termPos,Position termPos = term.pos;
trueRegs,RegSet trueRegs = regs.clone();
falseRegs,RegSet falseRegs = regs;
numFlows,int numFlows = flows.length();
i,int i = 0;
flow,RegFlow? flow = flowOriginating(flows, pred);
insns,Insn[] insns = block.insns;
insnsLen,int insnsLen = insns.length();
result,RegSet result = [];
numReg,int numReg = flow[0].regs.length();
conj,boolean conj = true;
name,string name = insn.name;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.result);
union,t:SemType union = t:NEVER;
unnarrowedOp,Register unnarrowedOp = unnarrow(insn.operand);
func,FunctionRef func = <FunctionRef>insn.func;
sig,FunctionSignature sig = func.signature;
nSuppliedArgs,int nSuppliedArgs = insn.args.length();
nExpectedArgs,int nExpectedArgs = sig.paramTypes.length();
name,string name = vc.symbolToString(func.symbol);
ty,t:SemType ty = insn.result.semType;
lat,t:ListAtomicType? lat = t:listAtomicType(vc.typeContext(), ty);
operands,Operand[] operands = insn.operands;
ty,t:SemType ty = insn.result.semType;
mat,t:MappingAtomicType? mat = t:mappingAtomicType(vc.typeContext(), ty);
indexOperand,IntOperand indexOperand = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, indexOperand.semType);
i,IntOperand i = insn.operands[1];
memberType,t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, insn.operands[1].semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInner(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
keyOperand,StringOperand keyOperand = insn.operands[1];
memberType,t:SemType memberType = t:mappingMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);
lhs,Operand lhs = insn.operands[0];
rhs,Operand rhs = insn.operands[1];
label,int label = code.blocks.length();
bb,BasicBlock bb = { label, name };
r,VarRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,FinalRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,NarrowRegister r = { number: code.registers.length(), underlying, semType, pos };
r,ParamRegister r = { number: code.registers.length(), semType, pos, name, scope };
r,TmpRegister r = { number: code.registers.length(), semType, pos, name };
r,AssignTmpRegister r = { number: code.registers.length(), semType, pos, name };
isNamed,boolean isNamed = ty.name != ();
elementTypes,Type[] elementTypes = ty.elementTypes;
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
words,string[] words = [];
operand,string operand = concat(...words);
structBody,string[] structBody = [];
elemTypes,Type[] elemTypes = [];
element,final Value element = elements[i];
structTy,Type structTy = structType(elemTypes);
ty,ArrayType ty = arrayType(elementType, values.length());
body,string[] body = ["["];
element,final ConstValue element = values[i];
ty,ArrayType ty = arrayType("i8", bytes.length());
val,ConstValue val = new(ty, charArray(bytes));
words,string[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self);
words,string[] words = [];
words,string[] words = [];
structName,string structName = "%" + escapeIdent(name);
ty,StructType ty = { elementTypes: [], name: structName };
tyName,string? tyName = namedStructTy.name;
valRep,string valRep;
data,var data = entry[1];
words,string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)];
tyName,string? tyName = ty.name;
data,var data = self.namedStructTypes[tyName];
dIBuilder,DIBuilder dIBuilder = new(self, self.context);
metadata,Metadata metadata = self.addMetadata();
preambleWords,string[] preambleWords = [];
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDefn fn = new (self.context, fnName, fnType);
fnName,string fnName = self.escapeGlobalIdent(name);
fn,FunctionDecl fn = new(self.context, fnName, fnType);
fnExisting,FunctionDecl? fnExisting = <FunctionDecl?>self.globals[name];
fnExisting,boolean fnExisting = self.globals[name] != ();
fn,FunctionDecl fn = new(self.context, "llvm." + name, fnType);
varName,string varName = self.escapeGlobalIdent(name);
ptrType,PointerType ptrType = pointerType(ty, props.addressSpace);
val,ConstPointerValue val = new ConstPointerValue(ptrType, "@" + varName);
aliasName,string aliasName = self.escapeGlobalIdent(name);
alias,ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);
varName,string varName = escapeIdent(name);
out,Output out = new;
out,Output out = new;
words,string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];
line,string[] line = [alias.operand, "="];
words,string[] words = [];
initializer,var initializer = prop.initializer;
metadata,Metadata metadata = new(self.genMetadataLabel());
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
paramType,final Type paramType = functionType.paramTypes[i];
register,string register = "%" + i.toString();
arg,Value arg = new (paramType, register);
isFirst,boolean isFirst = true;
bbName,string|Unnamed bbName = self.genName(name);
bb,BasicBlock bb = new (self.context, bbName, self);
varName,string varName = name;
count,int count = self.variableNames.get(varName);
newName,string newName = varName + "." + count.toString();
varName,int varName = self.unnamedLabelCount;
reg,string|Unnamed reg = self.genName(name);
attrib,ReturnEnumAttribute attrib = attribute[1];
attrib,ParamEnumAttribute attrib = attribute[1];
paramIndex,int paramIndex = attribute[0];
newLabel,string newLabel = self.nameCounter.toString();
newName,string newName = "%" + self.nameCounter.toString();
newName,string newName = self.nameTranslation[name];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];
name,string? name = props.name;
alignInBits,Alignment? alignInBits = props.alignInBits;
metadata,Metadata metadata = self.m.addMetadata();
body,string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
encodingToString,string encodingToString = "DW_ATE_" + props.encoding;
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
align,int? align = props.alignInBits;
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
words,(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [];
scope,Metadata? scope = props.scope;
file,Metadata? file = props.file;
ty,Metadata? ty = props.ty;
flags,string[] flags = [];
retainedNodes,Metadata retainedNodes = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];
metadata,Metadata metadata = self.m.addMetadata();
typeNode,Metadata typeNode = self.m.addMetadata();
metadata,Metadata metadata = self.m.addMetadata();
words,string[] words = [metadata.ref(), "=", "!", "DILocation", "("];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ptrTy,PointerType ptrTy = pointerType(ty);
bb,BasicBlock bb = self.bb();
ty,Type ty = ptr.ty.pointsTo;
reg,string|Unnamed reg = bb.func.genReg(name);
ty,Type ty = ptr.ty.pointsTo;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntegralType ty = sameIntegralType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
ty,IntType|FloatType ty = sameNumberType(lhs, rhs);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg, "="];
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valueType,Type valueType = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
valTy,Type valTy = val.ty;
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
bb,BasicBlock bb = self.bb();
insnWords,(string|Unnamed)[] insnWords;
retType,RetType retType;
bb,BasicBlock bb = self.bb();
fnTy,Type fnTy = fn.ty.pointsTo;
fnName,var fnName = fn.operand;
functionName,string functionName = "@" + fn.functionName;
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [reg];
insnWords,(string|Unnamed)[] insnWords = [];
arg,final Value arg = args[i];
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
elementType,Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);
bb,BasicBlock bb = self.bb();
condTy,Type condTy = condition.ty;
bb,BasicBlock bb = self.bb();
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
destTy,PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);
bb,BasicBlock bb = self.bb();
reg,string|Unnamed reg = bb.func.genReg(name);
words,(string|Unnamed)[] words = [];
tem,BasicBlock? tem = self.currentBlock;
chunks,(string|Unnamed)[] chunks = [];
currentChunk,string[] currentChunk = [];
newLines,(string|Unnamed)[][] newLines = [];
newLine,(string|Unnamed)[] newLine = [];
newLine,string[] newLine = [];
outputLine,string outputLine = createLine([concat(...newLine)], INDENT);
ty1,Type ty1 = v1.ty;
ty2,Type ty2 = v2.ty;
tyName,string? tyName = ty.name;
elementTypes,Type[] elementTypes = ty.elementTypes;
typeStringBody,string[] typeStringBody = [];
elementType,final Type elementType = elementTypes[i];
typeStringBody,string[] typeStringBody = [];
typeStringBody,string[] typeStringBody = [];
paramType,final Type paramType = ty.paramTypes[i];
elementTypes,Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);
words,string[] words = [];
metadata,Metadata? metadata = fn.metadata;
ty,final Type ty = fn.functionType.paramTypes[i];
parts,string[] parts = [];
lastTail,string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";
head,string head = word.length() > 0 ? word.substring(0, 1) : "";
escaped,string escaped = "\"";
cp,int cp = ch.toCodePointInt();
bytes,byte[] bytes = ch.toBytes();
result,string result = "";
hex,string hex = cp.toHexString().toUpperAscii();
ptrTy,Type ptrTy = ptr.ty;
resultType,Type resultType = ptr.ty;
resultAddressSpace,int resultAddressSpace = 0;
i,int i;
indexTy,Type indexTy = index.ty;
result,string result = "c\"";
hex,string hex = b.toHexString().toUpperAscii();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g,ConstPointerValue g = m.addGlobal("i64", "g", initializer=context.constInt("i64", 5), addressSpace=1, linkage="internal");
a,ConstPointerValue a = m.addAlias("i64", g, "a", addressSpace=1);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
retVal,Value retVal = builder.load(a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: ["i8"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
a,Value a = foo.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,Value const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
const2,Value const2 = context.constStruct([context.constInt("i64", 3), context.constInt("i64", 4)]);
const2Ty,Type const2Ty = structType(["i64", "i64"]);
const3,Value const3 = context.constStruct([const1, const2]);
const3Ty,Type const3Ty = structType([const1Ty, const2Ty]);
testTy,FunctionType testTy = {returnType: const1Ty, paramTypes: []};
test,FunctionDefn test = m.addFunctionDefn("test", testTy);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
test2,FunctionDefn test2 = m.addFunctionDefn("test2", {returnType: const3Ty, paramTypes: []});
initBlock2,BasicBlock initBlock2 = test2.appendBasicBlock();
constFnStruct,Value constFnStruct = context.constStruct([test]);
constFnStructTy,Type constFnStructTy = structType([pointerType(testTy)]);
test3,FunctionDefn test3 = m.addFunctionDefn("test3", {returnType:constFnStructTy, paramTypes: []});
bb,BasicBlock bb = test3.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
sub,FunctionDecl sub = m.getIntrinsicDeclaration("ssub.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(sub, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
fnTy,FunctionType fnTy = functionType(structTy, [structTy, "i64"]);
notUsed,StructType notUsed = context.structCreateNamed("notUsed");
g,ConstPointerValue g = m.addGlobal(structTy, "g");
foo,FunctionDefn foo = m.addFunctionDefn("foo", { returnType: structTy, paramTypes: [] });
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", { returnType: "void", paramTypes: [structTy] });
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
p2,Value p2 = test.getParam(2);
initBlock,BasicBlock initBlock = test.appendBasicBlock();
temp1,Value temp1 = builder.iArithmeticWrap("add",p0, p1);
temp2,Value temp2 = builder.iArithmeticWrap("add",temp1, p2);
test2,FunctionDecl test2 = m.addFunctionDecl("test2", {returnType:"i64", paramTypes:["i64", "i64", "i64"]});
context,Context context = new;
m,Module m = context.createModule();
fnTy,FunctionType fnTy = functionType("i64", ["i8", "i64"]);
otherFnTy,FunctionType otherFnTy = functionType("i8", ["i64"]);
otherFnPtrTy,PointerType otherFnPtrTy = pointerType(otherFnTy, 0);
fn,FunctionDecl fn = m.addFunctionDecl("otherFn", otherFnTy);
fnPointerTy,PointerType fnPointerTy = pointerType(fnTy, 0);
structTy,StructType structTy = structType(["i32", fnPointerTy]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bar,FunctionDecl bar = m.addFunctionDecl("bar",{returnType:"i64", paramTypes:["i64"]});
barVoid,FunctionDecl barVoid = m.addFunctionDecl("barVoid", {returnType:"void", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R_1,Value? R_1 = builder.call(bar, [context.constInt("i64", 0)]);
R1,Value R1;
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
g1Ty,StructType g1Ty = structType(["i64", "i32", "i8"]);
g1,ConstPointerValue g1 = m.addGlobal(g1Ty, "g1", isConstant=true);
init,ConstValue init = context.constGetElementPtr(g1, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
g2,ConstPointerValue g2 = m.addGlobal(pointerType("i64", 0), "g2", initializer=init);
init2,ConstValue init2 = context.constBitCast(g2, pointerType("i32", 0));
g4,ConstPointerValue g4 = m.addGlobal(pointerType("i32", 0), "g4", isConstant=true);
init3,ConstValue init3 = context.constAddrSpaceCast(g4, pointerType("i32", 1));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64",paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes:["i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,Value R4 = builder.load(R2);
m,Module m = basicMain();
output,Output output = new ();
outputPath,string outputPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", "tmp.ll");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: ["i64"]});
foo1BB,BasicBlock foo1BB = foo1.appendBasicBlock();
R2,PointerValue R2 = builder.alloca("i64");
R0,Value R0 = foo1.getParam(0);
R3,Value R3 = builder.load(R2);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: ["i64", "i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
R5,Value R5 = builder.load(R4);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,PointerValue R6 = builder.alloca("i64");
R0,Value R0 = foo3.getParam(0);
R1,Value R1 = foo3.getParam(1);
R2,Value R2 = foo3.getParam(2);
R7,Value R7 = builder.load(R6);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.bitCast(arg, pointerType("i64"));
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: []});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
c,Value c = context.constInt("i64",42);
R2,Value R2 = builder.load(R1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: [pointerType("i8")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.ptrToInt(arg, "i64");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
V1,Value V1 = builder.ptrToInt(arg, "i1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
strContent,byte[] strContent ="abc123#@% \n\\\"".toBytes();
str,Value str = context.constString(strContent);
strFn,FunctionDefn strFn = m.addFunctionDefn("test", {returnType: arrayType("i8", strContent.length()), paramTypes: []});
initBlock,BasicBlock initBlock = strFn.appendBasicBlock();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
m,Module m = basicMain();
expectedPath,string expectedPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", expectedFilename);
expectedLines,string[] expectedLines = check io:fileReadLines(expectedPath);
expectedOutput,string expectedOutput = "\n".'join(...expectedLines);
mod,Module mod = func();
actualOutput,string actualOutput = mod.printModuleToString();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i32", 1)]);
v1,PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i32", 0), context.constInt("i32", 2)]);
v2,PointerValue v2 = builder.getElementPtr(v1, [context.constInt("i32", 0), context.constInt("i32", 1)]);
v3,PointerValue v3 = builder.getElementPtr(v2, [context.constInt("i64", 0), context.constInt("i64", 5)]);
arrTy3,Type arrTy3 = arrayType(pointerType("i64", 1), 10);
rtTy2,Type rtTy2 = structType([ "i32", arrTy3, "i32" ]);
stTy2,Type stTy2 = structType(["i8", "i8", rtTy2]);
g2,PointerValue g2 = m.addGlobal(stTy2, "g2");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType(pointerType("i64",1)), paramTypes: []});
t0,PointerValue t0 = builder.getElementPtr(g2, [context.constInt("i32", 1),context.constInt("i32", 2), context.constInt("i32", 1), context.constInt("i32", 4)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0),context.constInt("i64", 1)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
arrTy1,Type arrTy1 = arrayType("i64", 20);
arrTy2,Type arrTy2 = arrayType(arrTy1, 10);
rtTy,Type rtTy = structType(["i64", arrTy2,"i64"]);
stTy,Type stTy = structType(["i64", "i64", rtTy]);
g1,PointerValue g1 = m.addGlobal(stTy, "g1");
g2,PointerValue g2 = m.addGlobal("i32", "g2");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v1,Value v1 = builder.ptrToInt(g2, "i32");
v0,error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0), v1]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,Type structTy = structType(["i64", "i64"]);
arrTy,Type arrTy = arrayType(structTy, 10);
g1,PointerValue g1 = m.addGlobal(arrTy, "g1");
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});
bb,BasicBlock bb = foo.appendBasicBlock();
v0,PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i64", 10)]);
v1,error|PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i64", 10)]);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="test", linkageName="test", file=fileData, lineNo=0, ty=functionTy, scopeLine=0);
loc,Metadata loc = dIBuilder.createDebugLocation(1, 2, functionData);
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "void", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
v0,Value v0 = foo.getParam(0);
v1,Value v1 = foo.getParam(1);
a,Value a = builder.iArithmeticNoWrap("add", v0, v1);
b,Value b = builder.iArithmeticNoWrap("sub", v0, v1);
c,Value c = builder.iArithmeticNoWrap("mul", a, b);
context,Context context = new;
m,Module m = context.createModule();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
R6,Value R6 = builder.load(R5);
R7,Value R7 = builder.iCmp("eq", R6, context.constInt("i64", 0));
bb8,BasicBlock bb8 = foo.appendBasicBlock();
bb9,BasicBlock bb9 = foo.appendBasicBlock();
R10,Value R10 = builder.load(R4);
R11,Value R11 = builder.iCmp("eq", R10, context.constInt("i64", int:MIN_VALUE));
bb16,BasicBlock bb16 = foo.appendBasicBlock();
bb12,BasicBlock bb12 = foo.appendBasicBlock();
R13,Value R13 = builder.load(R5);
R14,Value R14 = builder.iCmp("eq", R13, context.constInt("i64", -1));
bb15,BasicBlock bb15 = foo.appendBasicBlock();
bb20,BasicBlock bb20 = foo.appendBasicBlock();
R17,Value R17 = builder.load(R4);
R18,Value R18 = builder.load(R5);
R19,Value R19 = builder.iArithmeticSigned("srem", R17, R18);
R21,Value R21 = builder.load(R3);
fn,FunctionDefn fn = m.addFunctionDefn(name, {returnType: "i1", paramTypes: ["double", "double"]});
bb,BasicBlock bb = fn.appendBasicBlock();
p0,Value p0 = fn.getParam(0);
p1,Value p1 = fn.getParam(1);
res,Value res = builder.fCmp(predicate, p0, p1);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,PointerValue R5 = builder.alloca("i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "double", paramTypes: ["double", "double"]});
initBlock,BasicBlock initBlock = bar.appendBasicBlock();
v0,Value v0 = bar.getParam(0);
v1,Value v1 = bar.getParam(1);
a,Value a = builder.fArithmetic("fadd", v0, v1);
b,Value b = builder.fArithmetic("fsub", v0, v1);
c,Value c = builder.fArithmetic("fmul", a, b);
d,Value d = builder.fArithmetic("fdiv", c, a);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
add,FunctionDecl add = m.getIntrinsicDeclaration("sadd.with.overflow.i64.i64");
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(add, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["double"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
neg,Value neg = builder.fNeg(p0);
context,Context context = new;
m,Module m = context.createModule();
mul,FunctionDecl mul = m.getIntrinsicDeclaration("smul.with.overflow.i64.i64");
abort,Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
builder,Builder builder = context.createBuilder();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R5,Value R5 = builder.load(R3);
R6,Value R6 = builder.load(R4);
R_7,Value? R_7 = builder.call(mul, [R5, R6]);
R7,Value R7;
R8,Value R8 = builder.extractValue(R7, 0);
R9,Value R9 = builder.extractValue(R7, 1);
R10,Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));
ifTrue,BasicBlock ifTrue = foo.appendBasicBlock();
ifFalse,BasicBlock ifFalse = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
bar,FunctionDecl bar = m.addFunctionDecl("bar", {returnType: "void", paramTypes: []});
bar2,FunctionDecl bar2 = m.addFunctionDecl("bar2", {returnType: "void", paramTypes: []});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});
bbfoo,BasicBlock bbfoo = foo.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});
bbfoo2,BasicBlock bbfoo2 = foo2.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
const1,ConstValue const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);
const1Ty,Type const1Ty = structType(["i64", "i64"]);
g,PointerValue g = m.addGlobal("i64", "g1");
g2,PointerValue g2 = m.addGlobal("i64", "g2", addressSpace=2);
g7,ConstPointerValue g7 = m.addGlobal(const1Ty, "g7");
testFn,FunctionDefn testFn = m.addFunctionDefn("testFn", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = testFn.appendBasicBlock();
val1,Value val1 = builder.ptrToInt(g, "i64");
val2,Value val2 = builder.ptrToInt(g2, "i64");
ret,Value ret = builder.iArithmeticWrap("add", val1, val2);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "g1");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes:[]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i8", 1), paramTypes: [pointerType("i8", 1)]});
mask,FunctionDecl mask = m.getIntrinsicDeclaration("ptrmask.p1.i64");
bb,BasicBlock bb = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
result,Value? result = builder.call(mask, [arg, context.constInt("i64",72057594037927928)]);
overflowArithmeticReturnType,StructType overflowArithmeticReturnType = structType(["i64", "i1"]);
overflowArithmeticFunctionType,FunctionType overflowArithmeticFunctionType = {returnType: overflowArithmeticReturnType, paramTypes: ["i64", "i64"]};
context,Context context = new;
m,Module m = context.createModule();
names,IntrinsicFunctionName[] names = ["sadd.with.overflow.i64.i64", "ssub.with.overflow.i64.i64", "smul.with.overflow.i64.i64"];
f,FunctionDecl f = m.getIntrinsicDeclaration(name);
functionName,string functionName = "llvm." + name;
context,Context context = new;
m,Module m = context.createModule();
name,IntrinsicFunctionName name = "sadd.with.overflow.i64.i64";
f1,FunctionDecl f1 = m.getIntrinsicDeclaration(name);
f2,FunctionDecl f2 = m.getIntrinsicDeclaration(name);
context,Context context = new;
m,Module m = context.createModule();
attributes,FunctionEnumAttribute[] attributes = ["noreturn", "cold", "nounwind", "readnone", "speculatable", "willreturn"];
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
m,Module m = context.createModule();
attribute,EnumAttribute attribute = "cold";
fDecl,FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});
fDefn,FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
test,FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["i64", "i32"]});
initBlock,BasicBlock initBlock = test.appendBasicBlock();
p0,Value p0 = test.getParam(0);
p1,Value p1 = test.getParam(1);
v1,Value v1 = builder.sIToFP(p0, "double");
v2,Value v2 = builder.sIToFP(p1, "double");
ret,Value ret = builder.fArithmetic("fadd", v1, v2);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
g1,ConstPointerValue g1 = m.addGlobal("i64", "g1");
structTy,StructType structTy = context.structCreateNamed("st");
g2,ConstPointerValue g2 = m.addGlobal(structTy, "g2");
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i32", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
testFn,FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "i32", paramTypes: []});
testBB,BasicBlock testBB = testFn.appendBasicBlock();
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
d,PointerValue d = new (pointerType("i1"), "d");
e,error? e = trap builder.store(s, d);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.call(f, [s]);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,Value?|error e = trap builder.extractValue(s, 0);
context,Context context = new;
m,Module m = context.createModule();
f,FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});
bb,BasicBlock bb = f.appendBasicBlock();
builder,Builder builder = context.createBuilder();
s,DataValue s = new ("i64", "s");
e,error? e = trap builder.condBr(s,bb,bb);
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i8", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value v1 = builder.trunc(arg, "i8");
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: ["i64"]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
context,Context context = new();
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64"]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
v1,Value|error v1 = trap builder.trunc(arg, "i64");
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
structTy,StructType structTy = context.structCreateNamed("structTy");
structPtrTy,PointerType structPtrTy = pointerType(structTy);
extFnTy,FunctionType extFnTy = {returnType: "void", paramTypes: [structPtrTy]};
extFnPtrTy,PointerType extFnPtrTy = pointerType(extFnTy);
mainFnTy,FunctionType mainFnTy = {returnType: "void", paramTypes: [structPtrTy]};
mainFn,FunctionDefn mainFn = m.addFunctionDefn("main", mainFnTy);
bb,BasicBlock bb = mainFn.appendBasicBlock();
arg,Value arg = mainFn.getParam(0);
v2,PointerValue v2 = builder.alloca(structPtrTy);
v3,Value v3 = builder.load(v2);
v4,PointerValue v4 = builder.getElementPtr(<PointerValue>v3, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");
v5,Value v5 = builder.load(v4);
v6,PointerValue v6 = builder.getElementPtr(<PointerValue>v5, [context.constInt("i64", 1)], "inbounds");
v7,Value v7 = builder.load(v6);
v8,Value v8 = builder.load(v2);
v9,PointerValue v9 = builder.bitCast(<PointerValue>v7, extFnPtrTy);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i64")]});
fooBB,BasicBlock fooBB = foo.appendBasicBlock();
arg,Value arg = foo.getParam(0);
third,Value third = builder.getElementPtr(<PointerValue>arg, [context.constInt("i64", 3)]);
bar,FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType("i8"), paramTypes: [pointerType("i8")]});
barBB,BasicBlock barBB = bar.appendBasicBlock();
arg_1,Value arg_1 = bar.getParam(0);
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: pointerType("i64", 1), paramTypes: [pointerType("i64", 1)]});
fooBB2,BasicBlock fooBB2 = foo2.appendBasicBlock();
arg_2,Value arg_2 = foo2.getParam(0);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
f1,FunctionDefn f1 = foo1(builder, m);
f2,FunctionDefn f2 = foo2(builder, m);
f3,FunctionDefn f3 = foo3(context, builder, m);
f4,FunctionDefn f4 = foo4(builder, m);
test,FunctionDefn test = m.addFunctionDefn("test", {returnType:"void", paramTypes:[]});
bb5,BasicBlock bb5 = test.appendBasicBlock();
R1,PointerValue R1 = builder.alloca("i64");
R2,PointerValue R2 = builder.alloca("i64");
R3,Value R3;
R_3,Value|() R_3 = builder.call(f3, []);
R4,Value R4;
R_4,Value|() R_4 = builder.call(f4, [context.constInt("i64", 12), context.constInt("i64", 13)]);
foo1,FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType:"void", paramTypes:[]});
bb1,BasicBlock bb1 = foo1.appendBasicBlock();
foo2,FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType:"void", paramTypes:["i64","i64"]});
bb2,BasicBlock bb2 = foo2.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo2.getParam(0);
R1,Value R1 = foo2.getParam(1);
foo3,FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType:"i64", paramTypes:[]});
bb3,BasicBlock bb3 = foo3.appendBasicBlock();
C1,Value C1 = cx.constInt("i64", 21);
foo4,FunctionDefn foo4 = m.addFunctionDefn("foo4", {returnType:"i64", paramTypes:["i64", "i64"]});
bb4,BasicBlock bb4 = foo4.appendBasicBlock();
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R0,Value R0 = foo4.getParam(0);
R1,Value R1 = foo4.getParam(1);
R5,Value R5 = builder.load(R4);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
genFn,FunctionDecl genFn = m.addFunctionDecl("genFn", {returnType: pointerType("i64", 3), paramTypes:[]});
pty0,PointerType pty0 = pointerType("i64", 0);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: pty0, paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
val,Value? val = builder.call(genFn, []);
retVal,Value retVal = builder.addrSpaceCast(<PointerValue>val, pty0);
context,Context context = new;
m,Module m = context.createModule();
e,error|PointerValue e = trap m.addGlobal("i64", "sadd.with.overflow.i64.i64");
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDefn fn = trap m.addFunctionDefn("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
m,Module m = context.createModule();
fn,error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
dIBuilder,DIBuilder dIBuilder = m.createDIBuilder();
fileData,Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");
functionTy,Metadata functionTy = dIBuilder.createSubroutineType(fileData);
functionData,Metadata functionData = dIBuilder.createFunction(scope=fileData, name="main", linkageName="test", file=fileData, lineNo=1, ty=functionTy, scopeLine=0);
tyMeta,Metadata tyMeta = dIBuilder.createBasicType(name="myInt", encoding="signed", sizeInBits=64);
varMeta,Metadata varMeta = dIBuilder.createAutoVariable(ty=tyMeta, scope=functionData, name="myVar", lineNo=2, file=fileData);
bMeta,Metadata bMeta = dIBuilder.createAutoVariable(ty=dIBuilder.createBasicType(name="constInt", encoding="signed", sizeInBits=64), scope=functionData, name="B", lineNo=2, file=fileData);
charMeta,Metadata charMeta = dIBuilder.createBasicType(name="char", encoding="signed_char", sizeInBits=8);
taggedPtrMeta,Metadata taggedPtrMeta = dIBuilder.createTypedef(dIBuilder.createPointerType(pointeeTy=charMeta, sizeInBits=64, addressSpace=1), "TaggedPtr", fileData, 0, scope=fileData);
cMeta,Metadata cMeta = dIBuilder.createAutoVariable(ty=taggedPtrMeta, scope=functionData, name="C", lineNo=2, file=fileData);
emptyExpr,Metadata emptyExpr = dIBuilder.createExpression([]);
bScope,Metadata bScope = dIBuilder.createLexicalBlock(functionData, fileData, 3, 2);
loc1,Metadata loc1 = dIBuilder.createDebugLocation(2, 2, bScope);
loc2,Metadata loc2 = dIBuilder.createDebugLocation(3, 2, functionData);
loc3,Metadata loc3 = dIBuilder.createDebugLocation(4, 2, functionData);
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
a,PointerValue a = builder.alloca("i64");
b,PointerValue b = builder.alloca("i64");
c,PointerValue c = builder.alloca(pointerType("i8", 1));
initA,Value initA = context.constInt("i64", 10);
retVal,Value retVal = builder.iArithmeticWrap("add", builder.load(a), context.constInt("i64", 1));
context,Context context = new;
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "void", paramTypes: []});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
builder,Builder builder = context.createBuilder();
fn,FunctionDefn fn = m.addFunctionDefn(fnName, {returnType: "double", paramTypes: []});
initBlock,BasicBlock initBlock = fn.appendBasicBlock();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
mainFunction,FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = mainFunction.appendBasicBlock();
p1,Value p1 = mainFunction.getParam(0);
p2,Value p2 = mainFunction.getParam(1);
v,PointerValue v = builder.alloca("i64");
a,Value a = builder.iArithmeticWrap("add", p1, p2);
greater,BasicBlock greater = mainFunction.appendBasicBlock("greater");
less,BasicBlock less = mainFunction.appendBasicBlock("less");
isGreater,Value isGreater = builder.iCmp("sge", a, context.constInt("i64", 10));
b_1,Value b_1 = builder.iArithmeticWrap("sub", a, context.constInt("i64", 5));
common,BasicBlock common = mainFunction.appendBasicBlock();
b_2,Value b_2 = builder.iArithmeticWrap("add", a, context.constInt("i64", 5));
b_3,Value b_3 = builder.load(v);
context,Context context = new;
m,Module m = context.createModule();
builder,Builder builder = context.createBuilder();
abort,FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});
foo,FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});
initBlock,BasicBlock initBlock = foo.appendBasicBlock();
R0,Value R0 = foo.getParam(0);
R1,Value R1 = foo.getParam(1);
R3,PointerValue R3 = builder.alloca("i64");
R4,PointerValue R4 = builder.alloca("i64");
R5,Value R5 = builder.load(R4);
R6,Value R6 = builder.iCmp("eq", R5, context.constInt("i64", 0));
bb7,BasicBlock bb7 = foo.appendBasicBlock();
bb10,BasicBlock bb10 = foo.appendBasicBlock();
bb13,BasicBlock bb13 = foo.appendBasicBlock();
bb14,BasicBlock bb14 = foo.appendBasicBlock();
R8,Value R8 = builder.load(R3);
R9,Value R9 = builder.iCmp("eq", R8, context.constInt("i64", int:MIN_VALUE));
R11,Value R11 = builder.load(R4);
R12,Value R12 = builder.iCmp("eq", R11, context.constInt("i64", -1));
R15,Value R15 = builder.load(R3);
R16,Value R16 = builder.load(R4);
R17,Value R17 = builder.iArithmeticSigned("sdiv", R15, R16);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
out,string out = typeToString(ty, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
context,Context context = new;
pTy,PointerType pTy = pointerType(ty);
out,string out = typeToString(pTy, context);
intTypes,IntType[] intTypes = ["i64", "i1"];
ty,StructType ty = structType(intTypes);
context,Context context = new;
out,string out = typeToString(ty, context);
context,Context context = new;
builder,Builder builder = context.createBuilder();
m,Module m = context.createModule();
elements,ConstValue[] elements = [context.constInt("i64", 1), context.constInt("i64", 10), context.constInt("i64", 100)];
array,ConstValue array = context.constArray("i64", elements);
retTy,ArrayType retTy = arrayType("i64", 3);
fn,FunctionDefn fn = m.addFunctionDefn("test", {returnType: retTy, paramTypes:[]});
bb,BasicBlock bb = fn.appendBasicBlock();
msg,string msg = "something impossible happened";
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseIntersection(tok);
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
tds,TypeDesc[] tds = [lhs];
opPos,Position[] opPos = [];
right,TypeDesc right = op == "|" ? check parseIntersection(tok) : check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parseUnaryTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
unary,UnaryTypeDesc unary = { startPos, endPos, op: "!", opPos: startPos, td };
startPos,Position startPos = tok.currentStartPos();
td,TypeDesc td = check parsePrimaryTypeDesc(tok);
opPos,Position opPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
optionalTd,UnaryTypeDesc optionalTd = { startPos, endPos, op: "?", opPos, td };
dimensions,SimpleConstExpr?[] dimensions = [];
endPos,Position? endPos = ();
array,ArrayTypeDesc array = { startPos, endPos: <Position>endPos, member: td , dimensions };
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
pos,Position pos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
typeName,string typeName = check tok.expectIdentifier();
constituent,TypeDesc constituent = check parseTypeParam(tok);
endPos,Position endPos = tok.currentEndPos();
rest,var rest = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
detail,var detail = check parseTypeParam(tok);
row,TypeDesc row = check parseTypeParam(tok);
endPos,Position endPos = tok.previousEndPos();
qNamePos,Position qNamePos = tok.currentStartPos();
prefix,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
typeName,var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);
endPos,Position endPos = tok.previousEndPos();
endPos,Position endPos = tok.currentEndPos();
valueExpr,SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);
td,TypeDesc td = check parseTypeDesc(tok);
startPos,Position startPos = tok.currentStartPos();
params,FunctionTypeParam[] params = namedParams ?: [];
paramStartPos,Position paramStartPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
ret,TypeDesc? ret = ();
t,Token? t = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
members,TypeDesc[] members = [];
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
rest,TypeDesc? rest = ();
td,TypeDesc td = check parseTypeDesc(tok);
fields,FieldDesc[] fields = [];
rest,TypeDesc? rest = ();
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
fields,FieldDesc[] fields = [];
fieldStartPos,Position fieldStartPos = tok.currentStartPos();
ro,boolean ro = false;
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.currentEndPos();
name,string name = check tok.expectIdentifier();
endPos,Position endPos = check tok.expectEnd(";");
importDecls,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
moduleLevelDefns,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);
org,string? org = decl.org;
prefix,string? prefix = decl.prefix;
nameNodes,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
td,SubsetBuiltinTypeDesc? td = defn.td;
name,string? name = param.name;
body,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
name,string? name = stmt.name;
returnExpr,Expr? returnExpr = stmt.returnExpr;
lValue,LExpr|WILDCARD lValue = stmt.lValue;
ifFalse,StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;
clauses,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
childNodes,SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];
prefix,string? prefix = expr.prefix;
prefix,string? prefix = expr.prefix;
identifierPos,Position? identifierPos = prefix == () ? expr.qNamePos : ();
token,string token;
typeSuffix,FpTypeSuffix? typeSuffix = expr.typeSuffix;
op,BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;
memberNodes,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
rest,TypeDesc? rest = td.rest;
dimensions,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
rest,TypeDesc|INCLUSIVE_RECORD_TYPE_DESC? rest = td.rest;
fields,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
params,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
retTd,TypeDesc? retTd = td.ret;
prefix,string? prefix = td.prefix;
childNodes,SubSyntaxNode[] childNodes = [{ token: td.op, pos: td.startPos }, syntaxNodeFromTypeDesc(td.td)];
token,string token;
valueExpr,ExtendedLiteralExpr valueExpr = td.valueExpr;
childNodes,SubSyntaxNode[] childNodes = flattenSyntaxNodeList(nodes);
newNodes,SubSyntaxNode[] newNodes = [];
nodes,SubSyntaxNode[] nodes = [];
words,Word[] words = [];
childNodes,SubSyntaxNode[] childNodes = node.childNodes;
flags,OutputFlags flags = terminalSyntaxNodeFlags(child, node);
parent,AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();
name,string name = parent is FunctionCallExpr ? parent.funcName : parent.methodName;
astNode,AstNode astNode = node.astNode;
chunks,string[] chunks = ["\""];
Char,string:Char? singleEscaped = REVERSE_ESCAPES[ch];
cp,int cp = ch.toCodePointInt();
parts,string[] parts = [];
lines,string[] lines = [];
skipSpace,boolean skipSpace = true;
ignoreNewLine,boolean ignoreNewLine = false;
indentSize,int indentSize = 0;
token,Word token = words[i];
nextToken,Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();
lastLine,string lastLine = string
filteredLines,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
content,string[] content = [];
Char,:Char?[] { string:Char?[] fragFixed = [];
ft,FixedToken?[] ft = [];
s,string s = checkpanic string
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragments,readonly & string[] fragments = line.fragments;
fragCodeIndex,int fragCodeIndex = 0;
fragmentIndex,int fragmentIndex = 0;
i,int i = 0;
code,FragCode code = fragCodes[fragCodeIndex];
ft,FixedToken? ft = fragTokens[<int>code];
lineContent,string[] lineContent = [];
fragCodes,readonly & FragCode[] fragCodes = line.fragCodes;
fragmentIndex,int fragmentIndex = 0;
code,FragCode code = fragCodes[fragCodeIndex];
hexDigits,string hexDigits = fragment.substring(3, fragment.length() - 1);
codePoint,int codePoint = check int
:Char,string:Char
result,ScannedLine[] result = from var l in lines select scanLine(l);
codePoints,int[] codePoints = line.toCodePointInts();
fragCodes,FragCode[] fragCodes = [];
endIndex,int[] endIndex = [];
fragments,string[] fragments;
nVarFragments,int nVarFragments = 0;
fragments,string[] fragments = [];
startIndex,int startIndex = 0;
lines,string[] lines = [];
i,int i = 0;
lineStartIndex,int lineStartIndex = 0;
cr,int? cr = ();
len,final int len = codePoints.length();
i,int i = startIndex;
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i);
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
startResultLength,final int startResultLength = result.fragCodes.length();
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
cp2,int cp2 = codePoints[i];
endIndex,int? endIndex = scanNumericEscape(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
endIndex,int? endIndex = scanHexDigits(codePoints, i + 1);
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = scanOptDigits(codePoints, startIndex);
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanFractionExponent(codePoints, i + 1);
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
endIndex,int? endIndex = scanExponent(codePoints, i + 1);
i,int i = startIndex;
len,int len = codePoints.length();
cp,int cp = codePoints[i];
len,int len = codePoints.length();
i,int i = startIndex;
ei,int[] ei = result.endIndex;
len,int len = ei.length();
startIndex,int startIndex = len > 0 ? ei[len - 1] : 0;
ki,int? ki = keywordIndex(codePoints, startIndex, i);
kw,string kw = checkpanic string
fc,FragCode[] fc = result.fragCodes;
len,int len = fc.length();
len,int len = codePoints.length();
cp,int cp = codePoints[i];
startPos,Position startPos = tok.currentStartPos();
stmts,Stmt[] stmts = [];
endPos,Position endPos = tok.currentEndPos();
closeBracePos,Position closeBracePos = tok.currentStartPos();
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
peeked,var peeked = tok.peek(skipQualIdent=true);
td,TypeDesc td = check parseTypeDesc(tok);
isTypeDesc,boolean isTypeDesc = check savePreparseRestore(tok, preparseArrayTypeDesc);
endPos,Position endPos = check tok.expectEnd(";");
stmt,BreakContinueStmt stmt = { startPos, endPos, breakContinue:<BreakContinue>cur };
peeked,var peeked = tok.peek();
state,TokenizerState state = tok.save();
isTypeDesc,boolean isTypeDesc = check func(tok);
name,string name;
prefix,string? prefix;
expr,FunctionCallExpr expr = check finishFunctionCallExpr(tok, prefix, name, startPos);
endPos,Position endPos = tok.previousEndPos();
lExpr,LExpr lExpr = { startPos, endPos, name, qNamePos: startPos, prefix };
cur,Token? cur = tok.current();
opPos,Position opPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check startPrimaryExpr(tok);
cur,Token? cur = tok.current();
endPos,Position endPos = check tok.expectEnd(";");
primary,Expr primary = check finishPrimaryExpr(tok, expr, startPos);
endPos,Position endPos = check tok.expectEnd(";");
stmt,CallStmt stmt;
t,Token? t = tok.current();
innerKwPos,Position innerKwPos = tok.currentStartPos();
operandStmt,CallStmt operandStmt = check finishCheckingCallStmt(tok, t, innerKwPos);
operandStmt,CallStmt operandStmt = check parseMethodCallStmt(tok);
operand,Expr operand = check parsePrimaryExpr(tok);
expr,CheckingCallExpr expr = { startPos: kwPos, endPos: operand.endPos, checkingKeyword, kwPos, operand};
endPos,Position endPos = check tok.expectEnd(";");
opPos,Position opPos = tok.currentStartPos();
expr,Expr expr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
stmt,AssignStmt stmt = { startPos, endPos, opPos, lValue, expr };
opStr,string opStr = op;
binOp,BinaryArithmeticOp|BinaryBitwiseOp binOp = <BinaryArithmeticOp|BinaryBitwiseOp> opStr.substring(0, opStr.length() - 1);
stmt,CompoundAssignStmt stmt = { startPos, endPos, opPos, lValue, expr, op: binOp };
td,TypeDesc td = check parseTypeDesc(tok);
cur,Token? cur = tok.current();
namePos,Position namePos = tok.currentStartPos();
name,string|WILDCARD name;
opPos,Position opPos = check tok.expectStart("=");
initExpr,Expr initExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
returnExpr,Expr? returnExpr;
endPos,Position endPos;
panicExpr,Expr panicExpr = check parseExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
ifFalse,IfElseStmt|StmtBlock? ifFalse;
condition,Expr condition = check parseExpr(tok);
ifTrue,StmtBlock ifTrue = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
cur,Token? cur = tok.current();
ifFalseStartPos,Position ifFalseStartPos = tok.currentStartPos();
condition,Expr condition = check parseExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
kwPos,Position kwPos = check tok.expectStart("in");
range,RangeExpr range = check parseRangeExpr(tok);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
expr,Expr expr = check parseInnerExpr(tok);
clauses,MatchClause[] clauses = [];
endPos,Position endPos = tok.currentEndPos();
startPos,Position startPos = tok.currentStartPos();
patterns,MatchPattern[] patterns = check parseMatchPatternList(tok);
opPos,Position opPos = check tok.expectStart("=>");
block,StmtBlock block = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
patterns,MatchPattern[] patterns = [];
cur,Token? cur = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
parenResult,boolean? parenResult = check preparseBracketed(tok, close);
t,Token? t = tok.current();
squareResult,boolean? squareResult = check preparseBracketed(tok, "]");
t,Token? t = tok.current();
result,boolean? result = check preparseBracketed(tok, closeBracketMap.get(<string>t));
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
members,var [members, _] = check parseExprList(tok, "]");
endPos,Position endPos = tok.previousEndPos();
expr,ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };
fields,Field[] fields = check parseFields(tok);
endPos,Position endPos = tok.previousEndPos();
expr,MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseLogicalAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseLogicalAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseOrExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseOrExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseXorExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseXorExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseBitwiseAndExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseBitwiseAndExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseEqualityExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseEqualityExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseRelationalExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseRelationalExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseShiftExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseShiftExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };
t2,Token? t2 = tok.current();
kwPos,Position kwPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
lower,Expr lower = check parseAdditiveExpr(tok);
opPos,Position opPos = check tok.expectStart("..<");
upper,Expr upper = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseAdditiveExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseAdditiveExpr(tok);
endPos,Position endPos = tok.previousEndPos();
shift,BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseMultiplicativeExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseMultiplicativeExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
startPos,Position startPos = tok.currentStartPos();
expr,Expr expr = check parseUnaryExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
right,Expr right = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
bin,BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };
kwPos,Position kwPos = tok.currentStartPos();
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };
opPos,Position opPos = tok.currentStartPos();
td,TypeDesc td = check parseTypeDesc(tok);
operand,Expr operand = check parseUnaryExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,TypeCastExpr expr = { startPos, endPos, opPos, td, operand };
startPos,Position startPos = tok.currentStartPos();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,string? prefix;
name,string name;
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };
expr,FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: t[1] };
expr,LiteralExpr expr = { startPos, endPos, value: () };
innerExpr,Expr innerExpr = check parseInnerExpr(tok);
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
expr,LiteralExpr expr = { startPos, endPos, value: () };
kwPos,Position kwPos = tok.currentStartPos();
message,Expr message = check parseExpr(tok);
t,Token? t = tok.current();
opPos,Position opPos = tok.currentStartPos();
index,Expr index = check parseInnerExpr(tok);
accessEndPos,Position accessEndPos = check tok.expectEnd("]");
accessExpr,MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };
qnamePos,Position qnamePos = tok.currentStartPos();
name,string name = check parseIdentifierOrMethodName(tok);
endPos,Position endPos = tok.previousEndPos();
fieldAccessExpr,FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };
t,Token? t = tok.current();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
openParenPos,Position openParenPos = tok.currentStartPos();
args,var [args, closeParenPos] = check parseExprList(tok, ")");
closeParenPos,var [args, closeParenPos] = check parseExprList(tok, ")");
endPos,Position endPos = tok.previousEndPos();
exprs,Expr[] exprs = [];
expr,Expr expr = check parseExpr(tok);
t,Token? t = tok.current();
closeTerminatorPos,Position closeTerminatorPos = tok.currentStartPos();
fields,Field[] fields = [];
f,Field f = check parseField(tok);
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
isIdentifier,boolean isIdentifier = t[0] == IDENTIFIER;
name,string name = t[1];
colonPos,Position colonPos = tok.currentStartPos();
value,Expr value = check parseExpr(tok);
endPos,Position endPos = tok.previousEndPos();
f,Field f = { startPos, endPos, colonPos, name, value, isIdentifier };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
opPos,Position opPos = tok.currentStartPos();
operand,NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);
endPos,Position endPos = tok.previousEndPos();
expr,SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = check tok.expectEnd(")");
expr,LiteralExpr expr = { startPos, endPos, value: () };
endPos,Position endPos = tok.currentEndPos();
expr,LiteralExpr expr = { startPos, endPos, value: t == "true" };
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
prefix,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
name,var [prefix, name] = check parseOptQualIdentifier(tok, identifier);
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
untypedLiteral,, var untypedLiteral
typeSuffix,, var typeSuffix] => { Position
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
endPos,Position endPos = tok.currentEndPos();
expr,IntLiteralExpr expr = { startPos, endPos, base: 10, digits };
expr,IntLiteralExpr expr = { startPos, endPos, base: 16, digits };
:fromHexString,: int:fromHexString(digits);
tok,Tokenizer tok = new(self.tokState.file);
tok,Tokenizer tok = new (file);
tok,Tokenizer tok = scanned.tokenizer();
defns,ModuleLevelDefn[] defns = [];
part,ModulePart part = { file: scanned.sourceFile(), partIndex: scanned.partIndex, defns, importDecls: scanned.importDecls };
tok,Tokenizer tok = new (file);
expr,Expr expr = check parseExpr(tok);
imports,ImportDecl[] imports = [];
t,Token? t = tok.current();
im,ImportDecl im = check parseImportDecl(tok, partIndex);
startPos,Position startPos = tok.currentStartPos();
namePos,Position namePos = tok.currentStartPos();
firstModuleName,string firstModuleName = check validImportPart(tok);
org,string? org = ();
names,[string, string...] names = [firstModuleName];
prefix,string? prefix = check parseImportPrefix(tok);
endPos,Position endPos = check tok.expectEnd(";");
names,string[] names = [];
identifier,string identifier = check tok.expectIdentifier();
prevChar,string? prevChar = ();
t,Token? t = tok.current();
t,Token? t = tok.current();
startPos,Position startPos = tok.currentStartPos();
vis,Visibility vis;
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
td,TypeDesc td = check parseTypeDesc(tok);
endPos,Position endPos = check tok.expectEnd(";");
t,Token? t = tok.current();
td,SubsetBuiltinTypeDesc? td = ();
tdStartPos,Position tdStartPos = tok.currentStartPos();
tdEndPos,Position tdEndPos = tok.currentEndPos();
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
expr,Expr expr = check parseInnerExpr(tok);
endPos,Position endPos = check tok.expectEnd(";");
namePos,Position namePos = tok.currentStartPos();
name,string name = check tok.expectIdentifier();
params,FunctionParam [] params = [];
typeDesc,FunctionTypeDesc typeDesc = check parseFunctionTypeDesc(tok, params);
body,StmtBlock body = check parseStmtBlock(tok);
endPos,Position endPos = tok.previousEndPos();
defn,FunctionDefn defn = { startPos, endPos, params, typeDesc, name, vis, namePos, body, part };
message,string message = "parse error";
t,Token? t = tok.current();
str,string str = "";
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
fragment,string fragment = self.getFragment();
ch,string|error ch = unicodeEscapeValue(fragment);
number,string number = self.getFragment();
number,string number = self.getFragment();
ft,FixedToken? ft = fragTokens[<int>fragCode];
fragCodes,readonly & FragCode[] fragCodes = self.fragCodes;
fragCodeIndex,int fragCodeIndex = self.fragCodeIndex;
lineIndex,int lineIndex = self.lineIndex;
fragCode,FragCode fragCode = fragCodes[fragCodeIndex];
i,int i = self.fragCodeIndex;
fragCodes,FragCode[] fragCodes = self.fragCodes;
nextFragCode,FragCode nextFragCode = fragCodes[i];
lineIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
codePointIndex,var [lineIndex, codePointIndex] = unpackPosition(pos);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);
fragment,string fragment = self.fragments[self.fragmentIndex];
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex];
t,Token? t = self.curTok;
msg,d:Message msg;
pos,Position pos = self.currentEndPos();
pos,Position pos = self.currentStartPos();
msg,d:Message msg;
t,Token? t = self.curTok;
scannedLine,ScannedLine scannedLine = self.lines[self.lineIndex - 1];
startPos,Position startPos;
endPos,Position? endPos;
startLineNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [startLineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(startLineNum);
lineFragments,string[] lineFragments = scanLineFragments(line);
lineContent,string lineContent = "".'join(...lineFragments);
endColumnNum,int endColumnNum;
endLineNum,int endLineNum;
lineNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
startColumnNum,var [lineNum, startColumnNum] = self.lineColumn(startPos);
line,ScannedLine line = self.scannedLine(lineNum);
endColumnNum,int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);
fragIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragmentIndex,var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);
fragments,string[] fragments = line.fragments;
fragCodes,FragCode[] fragCodes = line.fragCodes;
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragmentIndex,int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);
nCodePoints,int nCodePoints = 0;
fragmentIndex,int fragmentIndex = 0;
nFragments,int nFragments = fragments.length();
endCodePointIndex,int endCodePointIndex = startCodePointIndex;
fragCode,FragCode fragCode = fragCodes[fragmentIndex];
file,SourceFile file = createSourceFile([str], { filename: "<internal>" });
tok,Tokenizer tok = new(file);
left,Identifier|TypeProjection left = check parseTypeProjection(tok);
t,Token? t = tok.current();
op,SubtypeTestOp op;
right,Identifier|TypeProjection right = check parseTypeProjection(tok);
identifier,Identifier identifier = check tok.expectIdentifier();
t,Token? t = tok.current();
index,int|Identifier index;
actualNode,err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);
normalizedActualNode,SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);
actualNodeLines,string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);
node,SyntaxNode node;
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
file,SourceFile file = createSourceFile(lines, { filename: k });
tok,Tokenizer tok = new (file);
t,err:Syntax|Token? t = advance(tok, k, lines);
lc,d:LineColumn lc = file.lineColumn(tok.currentStartPos());
src,string src = lines[lc[0] - 1];
tStart,int tStart = lc[1];
tStr,string tStr = tokenToString(t);
srcAtPos,string srcAtPos = src.substring(tStart, tStart + tStr.length());
e,err:Syntax? e = tok.advance();
all,map<TokenizerTestCase> all = check invalidTokenSourceFragments();
invalidCases,int invalidCases = all.length();
valid,map<ParserTestCase> valid = check readParserTests();
sources,SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];
tests,map<TokenizerTestCase> tests = {};
tests,map<ParserTestCase> tests = {};
testData,ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();
expected,string[] expected;
subject,string subject = s[2];
subjectLines,string[] subjectLines = splitIntoLines(subject);
rule,string rule = s[1];
testFiles,var testFiles = check file:readDir("modules/front.syntax/tests/data");
path,string path = f.absPath;
base,string base = check file:basename(path);
src,string[] src = check readCase(path);
parentDir,string parentDir = check file:parentPath(path);
canonFile,string canonFile = check file:joinPath(parentDir, canonFileName(base));
expected,string[] expected;
baseParts,[Kind, string] baseParts = check splitTestName(base);
rule,string rule = baseParts[1];
len,int len = base.length();
kindPos,int kindPos = base.indexOf("-") ?: 0;
kind,string kind = base.substring(0, kindPos);
afterKindPos,int afterKindPos = min(kindPos + 1, len);
rulePos,int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;
rule,string rule = base.substring(afterKindPos, rulePos);
lines,string[] lines = check io:fileReadLines(path);
caseLines,string[] caseLines = [];
inCase,boolean inCase = false;
indented,int indented = 0;
trimLine,string trimLine = line.trim();
sansExt,string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());
