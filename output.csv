importDecls,SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);
SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);,SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);
moduleLevelDefns,SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);
SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);,string? org = decl.org;
childNodes,string? prefix = decl.prefix;
SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);,SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });
org,SubsetBuiltinTypeDesc? td = defn.td;
string? org = decl.org;,string? name = param.name;
prefix,SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);
string? prefix = decl.prefix;,Expr? returnExpr = stmt.returnExpr;
nameNodes,LExpr|WILDCARD lValue = stmt.lValue;
SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });,StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;
td,SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);
SubsetBuiltinTypeDesc? td = defn.td;,Position? identifierPos = prefix == () ? expr.qNamePos : ();
name,string token;
string? name = param.name;,FpTypeSuffix? typeSuffix = expr.typeSuffix;
body,BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;
SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);,SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });
string? name = stmt.name;,TypeDesc? rest = td.rest;
returnExpr,SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];
Expr? returnExpr = stmt.returnExpr;,SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);
lValue,SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });
LExpr|WILDCARD lValue = stmt.lValue;,TypeDesc? retTd = td.ret;
ifFalse,ExtendedLiteralExpr valueExpr = td.valueExpr;
StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;,SubSyntaxNode[] newNodes = [];
clauses,SubSyntaxNode[] nodes = [];
SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);,Word[] words = [];
SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];,OutputFlags flags = terminalSyntaxNodeFlags(child, node);
string? prefix = expr.prefix;,AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();
identifierPos,AstNode astNode = node.astNode;
Position? identifierPos = prefix == () ? expr.qNamePos : ();,string[] chunks = ["\""];
token,string:Char? singleEscaped = REVERSE_ESCAPES[ch];
string token;,int cp = ch.toCodePointInt();
typeSuffix,string[] parts = [];
FpTypeSuffix? typeSuffix = expr.typeSuffix;,string[] lines = [];
op,boolean skipSpace = true;
BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;,boolean ignoreNewLine = false;
memberNodes,int indentSize = 0;
SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });,Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();
rest,string lastLine = string
TypeDesc? rest = td.rest;,string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;
dimensions,string[] content = [];
