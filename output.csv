nanoAdjustments,"int nanoAdjustments = (<int>lastSecondFraction * 1000000000);"
instant,"var instant = ofEpochSecond(epochSeconds, nanoAdjustments);"
zoneId,"var zoneId = getZoneId(java:fromString(Z));"
zonedDateTime,"var zonedDateTime = atZone(instant, zoneId);"
dateTimeFormatter,"var dateTimeFormatter = ofPattern(java:fromString(pattern));"
formatString,"handle formatString = format(zonedDateTime, dateTimeFormatter);"
value,"string value = check url:encode(requestURI, UTF_8);"
statusCode,"int statusCode = httpResponse.statusCode;"
jsonPayload,"json jsonPayload = check httpResponse.getJsonPayload();"
key,"string key = parameterKey;"
value,"PrimitiveType|PrimitiveType[] value = check extractParamValue(key, parameterValue);"
query,"string query = \"?\";"
pathParams,"regex:Match[] pathParams = regex:searchAll(path, \"\\{(\\w*?)\\}\");"
properties,"map<ParameterType> properties = pathParameters.properties;"
extractedParameters,"map<ParameterType> extractedParameters = map from regex:Match param in pathParams let var matched = param.matched select [matched.substring(1, matched.length() - 1), {'type: STRING}];"
fileJson,"map<json> fileJson = check io:fileReadJson(jsonPath).ensureType();"
serviceUrl,"string? serviceUrl = self.visitServers(openApiSpec.servers);"
paths,"Paths? paths = openApiSpec.paths;"
referenceMap,"map<ComponentType> referenceMap = {};"
ref,"string ref = string `#/${OPENAPI_COMPONENTS_KEY}/${componentType}/${componentName}`;"
description,"string? description = operation.summary ?: operation.description;"
name,"string? name = operation.operationId;"
queryParameters,"ParameterSchema? queryParameters = ();"
pathParameters,"ParameterSchema? pathParameters = ();"
parameters,"(Parameter|Reference)[]? parameters = operation.parameters;"
requestBody,"JsonInputSchema? requestBody = ();"
requestBodySchema,"RequestBody|Reference? requestBodySchema = operation.requestBody;"
resolvedRequestBody,"RequestBody resolvedRequestBody = check self.resolveReference(requestBodySchema).ensureType();"
content,"map<MediaType> content = requestBody.content;"
schema,"Schema schema = content.get(OPENAPI_JSON_CONTENT_KEY).schema;"
items,"JsonSubSchema items = parameterSchema.items;"
default,"json[]? default = parameterSchema.default;"
pathParams,"map<ParameterType> pathParams = {};"
queryParams,"map<ParameterType> queryParams = {};"
pathRequired,"string[] pathRequired = [];"
queryRequired,"string[] queryRequired = [];"
resolvedParameter,"Parameter resolvedParameter;"
schema,"Schema? schema = resolvedParameter.schema;"
style,"string? style = resolvedParameter.style;"
explode,"boolean? explode = resolvedParameter.explode;"
parameterType,"ParameterType parameterType = check self.verifyParameterType(check self.visitSchema(schema));"
name,"string name = resolvedParameter.name;"
pathParameters,"ParameterSchema pathParameters = {properties: pathParams, required: pathRequired.length() > 0 ? pathRequired : ()};"
queryParameters,"ParameterSchema queryParameters = {properties: queryParams, required: queryRequired.length() > 0 ? queryRequired : ()};"
component,"ComponentType|Reference component = self.referenceMap.get(reference.\$ref);"
resolvedSchema,"Schema resolvedSchema = check self.resolveReference(<Reference>schema).ensureType();"
objectSchema,"ObjectInputSchema objectSchema = { 'type: OBJECT, properties: {} };"
properties,"map<Schema> properties = <map<Schema>>schema?.properties;"
required,"boolean|string[]? required = schema?.required;"
inputSchmea,"PrimitiveInputSchema inputSchmea = { 'type: schema.'type };"
pattern,"string? pattern = schema.pattern;"
format,"string? format = schema.format;"
anyOf,"ObjectInputSchema[] anyOf = from Schema element in schema.anyOf select check self.visitSchema(element).ensureType();"
allOf,"ObjectInputSchema[] allOf = from Schema element in schema.allOf select check self.visitSchema(element).ensureType();"
oneOf,"JsonSubSchema[] oneOf = from Schema element in schema.oneOf select check self.visitSchema(element);"
returnedValue,"json returnedValue = ();"
tempKey,"string tempKey = key;"
required,"string[]? required = schema.required;"
inputValue,"json inputValue = inputs[key];"
dateStrings,"[string, string]|error dateStrings = generateDateString();"
canonicalURI,"var canonicalURI = getCanonicalURI(requestURI);"
canonicalQuery,"string|error canonicalQuery = generateCanonicalQueryString(queryParams);"
contentType,"string contentType = check request.getHeader(CONTENT_TYPE.toLowerAscii());"
stringToSign,"string stringToSign = generateStringToSign(amzDateStr, shortDateStr, region, canonicalRequest);"
authHeader,"string authHeader = check constructAuthSignature(accessKeyId, secretAccessKey, shortDateStr, region, signedHeaders, stringToSign);"
time,"time:Utc time = time:utcNow();"
amzDate,"string amzDate = check utcToString(time, ISO8601_BASIC_DATE_FORMAT);"
shortDate,"string shortDate = check utcToString(time, SHORT_DATE_FORMAT);"
zoneId,"var zoneId = getZoneId(java:fromString(\"Z\"));"
stringToSign,"string stringToSign = string `${AWS4_HMAC_SHA256}${\"\n\"}${amzDateStr}${\"\n\"}${shortDateStr}/${region}/${SERVICE_NAME}/${TERMINATION_STRING}${\"\n\"}${array:toBase16(crypto:hashSha256(canonicalRequest.toBytes())).toLowerAscii()}`;"
canonicalQueryString,"string canonicalQueryString = \"\";"
key,"string key;"
value,"string value;"
encodedKeyValue,"string encodedKeyValue = EMPTY_STRING;"
encodedValue,"string encodedValue = EMPTY_STRING;"
queryParamsKeys,"string[] queryParamsKeys = queryParams.keys();"
sortedKeys,"string[] sortedKeys = sort(queryParamsKeys);"
index,"int index = 0;"
encodedKey,"string encodedKey = check url:encode(key, UTF_8);"
encodedVal,"string encodedVal = check url:encode(value, UTF_8);"
canonicalHeaders,"string canonicalHeaders = \"\";"
signedHeaders,"string signedHeaders = \"\";"
headerKeys,"string[] headerKeys = headers.keys();"
sortedHeaderKeys,"string[] sortedHeaderKeys = sort(headerKeys);"
signValue,"string signValue = AWS4 + secretAccessKey;"
dateKey,"byte[] dateKey = check crypto:hmacSha256(shortDateStr.toBytes(), signValue.toBytes());"
regionKey,"byte[] regionKey = check crypto:hmacSha256(region.toBytes(), dateKey);"
serviceKey,"byte[] serviceKey = check crypto:hmacSha256(SERVICE_NAME.toBytes(), regionKey);"
signingKey,"byte[] signingKey = check crypto:hmacSha256(TERMINATION_STRING.toBytes(), serviceKey);"
encodedStr,"string encodedStr = array:toBase16(check crypto:hmacSha256(stringToSign.toBytes(), signingKey));"
credential,"string credential = string `${accessKeyId}/${shortDateStr}/${region}/${SERVICE_NAME}/${TERMINATION_STRING}`;"
authHeader,"string authHeader = string `${AWS4_HMAC_SHA256} ${CREDENTIAL}=${credential},${SIGNED_HEADER}=${signedHeaders}`;"
queryParamsStr,"string queryParamsStr = \"\";"
xmlPayload,"xml xmlPayload = check httpResponse.getXmlPayload();"
payload,"string payload = string `${verb.toLowerAscii()}${NEW_LINE}${resourceType.toLowerAscii()}${NEW_LINE}${resourceId}` + string `${NEW_LINE}${date.toLowerAscii()}${NEW_LINE}${EMPTY_STRING}${NEW_LINE}`;"
decodedArray,"byte[] decodedArray = check array:fromBase64(token);"
digest,"byte[] digest = check crypto:hmacSha256(payload.toBytes(), decodedArray);"
signature,"string signature = digest.toBase64();"
authorizationString,"string authorizationString = string `type=${tokenType}&ver=${TOKEN_VERSION}&sig=${signature}`;"
jsonResponse,"json jsonResponse = check httpResponse.getJsonPayload();"
message,"string message = let var msg = jsonResponse.message in msg is string ? msg : REST_API_INVOKING_ERROR;"
newStructure,"map<json> newStructure = parentStructure[parentKey] is map<json> ? <map<json>>parentStructure[parentKey] : {};"
currentKey,"string currentKey;"
currentStructure,"map<json> currentStructure;"
prevStructure,"map<json> prevStructure;"
returnData,"json returnData;"
value,"int value = 0;"
power,"int power = 1;"
length,"int length = state.currentToken.value.length() - 1;"
keys,"string[] keys = [];"
workspace,"Workspace workspace = workspacesTable.get(workspaceId);"
building,"Building building = buildingsTable.get(buildingCode);"
department,"Department department = departmentsTable.get(deptNo);"
employeesClonedTable,"table<Employee> key(empNo) employeesClonedTable;"
departmentsClonedTable,"table<Department> key(deptNo) departmentsClonedTable;"
workspacesClonedTable,"table<Workspace> key(workspaceId) workspacesClonedTable;"
buildingsClonedTable,"table<Building> key(buildingCode) buildingsClonedTable;"
keys,"int[] keys = [];"
post,"Post post = postsTable.get(id);"
follow,"Follow follow = followsTable.get(id);"
comment,"Comment comment = commentsTable.get(id);"
usersClonedTable,"table<User> key(id) usersClonedTable;"
postsClonedTable,"table<Post> key(id) postsClonedTable;"
followsClonedTable,"table<Follow> key(id) followsClonedTable;"
commentsClonedTable,"table<Comment> key(id) commentsClonedTable;"
medicalitem,"MedicalItem medicalitem = medicalitemsTable.get(itemId);"
medicalneedsClonedTable,"table<MedicalNeed> key(needId) medicalneedsClonedTable;"
medicalitemsClonedTable,"table<MedicalItem> key(itemId) medicalitemsClonedTable;"
keys,"[string, string][] keys = [];"
department,"Department department = departmentsTable.get([deptNo, deptName]);"
orderitem,"OrderItem orderitem = orderitemsTable.get([orderId, itemId]);"
employee,"Employee employee = employeesTable.get([empNo, firstName]);"
workspacesClonedTable,"table<Workspace> key(workspaceId, workspaceType) workspacesClonedTable;"
departmentsClonedTable,"table<Department> key(deptNo, deptName) departmentsClonedTable;"
orderitemsClonedTable,"table<OrderItem> key(orderId, itemId) orderitemsClonedTable;"
employeesClonedTable,"table<Employee> key(empNo, firstName) employeesClonedTable;"
employee,"Employee employee = employeesTable.get(empNo);"
timeToSend,"string timeToSend = timeInUTC.toString();"
uuid,"string uuid = getRandomString();"
signature,"string signature = check getNetsuiteSignature(timeToSend, uuid, config);"
header,"string header = string `<soapenv:Envelope xmlns:soapenv=\"http: xmlns:urn=\"urn:messages_2020_2.platform.webservices.netsuite.com\" xmlns:urn1=\"urn:core_2020_2.platform.webservices.netsuite.com\" xmlns:xsi=\"http: <soapenv:Header> <urn:tokenPassport><urn1:account>${ config.accountId}</urn1:account> <urn1:consumerKey>${config.consumerId}</urn1:consumerKey> <urn1:token>${ config.token}</urn1:token> <urn1:nonce>${uuid}</urn1:nonce> <urn1:timestamp>${timeToSend}</urn1:timestamp> <urn1:signature algorithm=\"HMAC-SHA256\">${ signature}</urn1:signature> </urn:tokenPassport> </soapenv:Header>`;"
xmlRecord,"string xmlRecord = string `<${recordRef?.'type.toString()} xsi:type=\"urn1:RecordRef\" internalId=\"${recordRef.internalId}\"/>`;"
externalId,"string? externalId = recordRef?.externalId;"
xmlRecord,"string xmlRecord = string `<${recordRef.'type.toString()} xsi:type=\"urn1:RecordRef\" internalId=\"${recordRef.internalId}\"/>`;"
header,"string header = check buildXMLPayloadHeader(config);"
body,"string body = string `<soapenv:Body>${customBody.toString()}</soapenv:Body></soapenv:Envelope>`;"
subElements,"string subElements = check getAddOperationElements(recordType, recordCoreType);"
body,"string body = getAddXMLBodyWithParentElement(subElements);"
subElements,"string subElements = getDeletePayload(recordType);"
body,"string body = getDeleteXMLBodyWithParentElement(subElements);"
elements,"string elements = check getUpdateOperationElements(recordType, recordCoreType, replaceAll);"
body,"string body = getUpdateXMLBodyWithParentElement(elements);"
subElements,"string subElements = EMPTY_STRING;"
elements,"string elements = prepareElementsForGetOperation(records);"
body,"string body = string `<soapenv:Body><urn:get xmlns:xsi=\"http: </urn:get></soapenv:Body></soapenv:Envelope>`;"
elements,"string elements = string `<urn:baseRef internalId=\"${recordDetail.recordInternalId}\" type=\"${recordDetail.recordType}\" xsi:type=\"urn1:RecordRef\"/>`;"
body,"string body = getXMLBodyForGetAllOperation(recordType);"
body,"string body = getXMLBodyForGetServerTime();"
recordRef,"RecordRef recordRef = { name: getValidJson(elementRecordType.name).toString(), internalId: getValidJson(element.\@internalId).toString(), externalId: getValidJson(element.\@externalId).toString(), 'type: let var recordType = getValidJson(element.\'type) in recordType is () ? EMPTY_STRING : (recordType.toString()) };"
castedValue,"decimal|error castedValue = trap decimalLib:fromString((element).toString());"
castedValue,"int|error castedValue = trap intLib:fromString((element).toString());"
body,"string body = getXMLBodyForGetSavedSearchIDs(searchType);"
fieldsWithParentElement,"string fieldsWithParentElement = string `<${namespace}:customFieldList xmlns:platformCore=\"urn:core_2020_2.platform.webservices.netsuite.com\">`;"
multiField,"string multiField = EMPTY_STRING;"
listOrRecordRef,"ListOrRecordRef[] listOrRecordRef = [];"
customFields,"CustomField[] customFields = [];"
'type,"string? 'type = extractStringFromXML(element.xsi_type);"
requestPayload,"string requestPayload = header + body;"
lim,"Limit|error lim = value.cloneWithType(Limit);"
errMsg,"string errMsg = \"Error occurred while constructing Limit record.\";"
res,"SoqlResult|error res = payload.cloneWithType(SoqlResult);"
errMsg,"string errMsg = \"Error occurred while constructing SoqlResult record.\";"
res,"SoslResult|error res = payload.cloneWithType(SoslResult);"
errMsg,"string errMsg = \"Error occurred while constructing SoslResult record.\";"
res,"SObjectMetaData|error res = payload.cloneWithType(SObjectMetaData);"
errMsg,"string errMsg = \"Error occurred while constructing SObjectMetaData record.\";"
res,"OrgMetadata|error res = payload.cloneWithType(OrgMetadata);"
errMsg,"string errMsg = \"Error occurred while constructing OrgMetadata record.\";"
res,"SObjectBasicInfo|error res = payload.cloneWithType(SObjectBasicInfo);"
errMsg,"string errMsg = \"Error occurred while constructing SObjectBasicInfo record.\";"
nextParent,"string nextParent = parent + \"[\" + key + \"]\";"
recordArray,"string[] recordArray = [];"
key,"string key = arrayName;"
arrayValues,"string[] arrayValues = [];"
serializedArray,"string[] serializedArray = [];"
arayIndex,"int arayIndex = 0;"
encoded,"string|error encoded = url:encode(value.toString(), \"UTF8\");"
param,"string[] param = [];"
encodingData,"Encoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : defaultEncoding;"
restOfPath,"string restOfPath = string:'join(\"\", ...param);"
headerMap,"map<string|string[]> headerMap = {};"
stringArray,"string[] stringArray = [];"
encodingData,"Encoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : {};"
entity,"mime:Entity entity = new mime:Entity();"
headers,"map<any>? headers = encodingData?.headers;"
entities,"mime:Entity[] entities = [];"
updateV,"string updateV = check url:encode(value, \"UTF-8\");"
encoded,"string|error encoded = url:encode(value, \"UTF8\");"
res,"http:Response res = new;"
payload,"json payload = check req.getJsonPayload();"
str,"string str;"
response,"http:Response|error response = stClient->get(\"/echo/message\");"
response,"http:Response|error response = stClient->get(\"/echo/message/echo/message\");"
response,"http:Response|error response = stClient->get(\"/abcd/message/echo/message\");"
response,"http:Response|error response = stClient->get(\"/echo/message_worker\");"
response,"http:Response|error response = stClient->get(\"/foo/message\");"
response,"http:Response|error response = stClient->get(\"/echo/bar\");"
req,"http:Request req = new;"
response,"http:Response|error response = stClient->post(\"/echo/setString\", req);"
response,"http:Response|error response = stClient->get(\"/echo/getString\");"
response,"http:Response|error response = stClient->get(\"/echo/removeHeaders\");"
response,"http:Response|error response = stClient->post(\"/echo/getFormParams\", req);"
newReq,"http:Request newReq = new;"
response,"http:Response|error response = stClient->patch(\"/echo/modify\", \"WSO2\");"
response,"http:Response|error response = stClient->get(\"/hello/echo\");"
response,"http:Response|error response = stClient->get(\"/hello/testFunctionCall\");"
response,"http:Response|error response = stClient->post(\"/echo/parseJSON\", req);"
response,"string response = check stClient->post(\"/echo/formData\", req);"
encodedValue,"string encodedValue = check url:encode(value, \"UTF-8\");"
entry,"string entry = string `${'key}=${encodedValue}`;"
result,"var result = trap val:toJson(message);"
response,"Response response = new;"
errorMsg,"string errorMsg = \"invalid response body type. expected one of the types: http:Response|xml|json|table<map<json>>|(map<json>|table<map<json>>)[]|mime:Entity[]|stream<byte[], io:Error?>\";"
request,"Request request = new;"
result,"var result = httpClient->get(path, message = outRequest);"
result,"var result = httpClient->post(path, outRequest);"
result,"var result = httpClient->options(path, message = outRequest);"
result,"var result = httpClient->put(path, outRequest);"
result,"var result = httpClient->delete(path, outRequest);"
result,"var result = httpClient->patch(path, outRequest);"
result,"var result = httpClient->forward(path, outRequest);"
result,"var result = httpClient->head(path, message = outRequest);"
inferredConnectorAction,"HttpOperation inferredConnectorAction = HTTP_NONE;"
bodyParts,"mime:Entity[] bodyParts = check inRequest.getBodyParts();"
childParts,"mime:Entity[]|error childParts = bodyPart.getBodyParts();"
childBlobContent,"byte[]|error childBlobContent = childPart.getByteArray();"
bodyPartBlobContent,"byte[]|error bodyPartBlobContent = bodyPart.getByteArray();"
newOutRequest,"Request newOutRequest = new;"
result,"var result = java:toString(nativeUuid());"
statusCodeConverted,"string statusCodeConverted = statusCode.toString();"
parameters,"map<string> parameters = {};"
decodedValue,"var decodedValue = decode(formData);"
entries,"string[] entries = re`&`.split(decodedValue);"
index,"int? index = entry.indexOf(\"=\");"
name,"string name = entry.substring(0, index);"
value,"string value = entry.substring(index + 1);"
mappedValues,"string[] mappedValues = headerValues.'map(val => val.toString());"
mappedValues,"string[] mappedValues = headerValue.'map(val => val.toString());"
mediaType,"string? mediaType = retrieveMediaType(message, returnMediaType);"
mediaType,"string? mediaType = resp?.mediaType;"
headerValue,"string? headerValue = createLinkHeaderValue(links);"
linkValues,"string[] linkValues = from var [rel, link] in links.entries() select createLink(rel, link);"
header,"string header = string`<${link.href}>; rel=\"${rel}\"`;"
methods,"string[]? methods = link?.methods;"
types,"string[]? types = link?.types;"
err,"error? err = trap addLinksToJsonPayload(message, links);"
pairs,"map<string>|error pairs = val:cloneWithType(payload);"
result,"string|error result = retrieveUrlEncodedData(pairs);"
messageParams,"string[] messageParams = [];"
encodedKey,"string encodedKey = check url:encode('key, CHARSET_UTF_8);"
encodedValue,"string encodedValue = check url:encode(value, CHARSET_UTF_8);"
entry,"string entry = string `${'encodedKey}=${encodedValue}`;"
result,"var result = trap val:toJson(payload);"
statusCode,"int? statusCode = err.detail().statusCode;"
cause,"error? cause = err.cause();"
response,"var response = httpClient->getResponse(backendResponse);"
responseStatusCode,"int responseStatusCode = response.statusCode;"
interval,"decimal interval = currentDelay;"
retryCount,"int retryCount = currentRetryCount + 1;"
waitTime,"decimal waitTime = interval * <decimal> backOffFactor;"
futureResponse,"var futureResponse = foClient->getResponse(endpointResponse);"
httpStatusCode,"int httpStatusCode = futureResponse.statusCode;"
result,"ClientError? result = ();"
httpConnectorErr,"ClientError? httpConnectorErr = ();"
tmpClnt,"Client? tmpClnt;"
err,"error err = error(\"Unexpected type found for failover client.\");"
lastSuccessClient,"Client? lastSuccessClient;"
err,"error err = error(\"Unexpected type found for failover client\");"
err,"error err = httpActionErr;"
lastErrorMsg,"string lastErrorMsg = err.message();"
failoverMessage,"string failoverMessage = \"All the failover endpoints failed. Last error was: \" + lastErrorMsg;"
failoverMessage,"string failoverMessage = \"Endpoint \" + index.toString() + \" returned response is: \" + inResponse.statusCode.toString() + \" \" + inResponse.reasonPhrase;"
httpActionErr,"FailoverActionFailedError httpActionErr = error FailoverActionFailedError(failoverMessage);"
message,"string message = \"Last endpoint returned response: \" + inResponse.statusCode.toString() + \" \" + inResponse.reasonPhrase;"
lastHttpConnectorErr,"FailoverActionFailedError lastHttpConnectorErr = error FailoverActionFailedError(message);"
failoverMessage,"string failoverMessage = \"All the failover endpoints failed. Last endpoint returned response is: \" + inResponse.statusCode.toString() + \" \" + inResponse.reasonPhrase;"
clientEPConfig,"ClientConfiguration clientEPConfig = { http1Settings: foConfig.http1Settings, http2Settings: foConfig.http2Settings, circuitBreaker:foConfig.circuitBreaker, timeout:foConfig.timeout, httpVersion:foConfig.httpVersion, forwarded:foConfig.forwarded, followRedirects:foConfig.followRedirects, retryConfig:foConfig.retryConfig, poolConfig:foConfig.poolConfig, secureSocket:target.secureSocket, cache:foConfig.cache, compression:foConfig.compression, auth:foConfig.auth, cookieConfig:foConfig.cookieConfig, responseLimits:foConfig.responseLimits, validation:foConfig.validation, socketConfig:foConfig.socketConfig };"
resultError,"ClientError? resultError = ();"
currentIndex,"int currentIndex = index;"
daysOfWeek,"DayOfWeek[] daysOfWeek = [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY];"
utcOffset,"ZoneOffset utcOffset;"
civilTimeSecField,"decimal? civilTimeSecField = civilTime?.second;"
utcOffsetSecField,"decimal? utcOffsetSecField = utcOffset?.seconds;"
civilTimeSeconds,"decimal civilTimeSeconds = (civilTimeSecField is Seconds) ? civilTimeSecField : 0.0;"
utcOffsetSeconds,"decimal utcOffsetSeconds = (utcOffsetSecField is decimal) ? utcOffsetSecField : 0.0;"
civilTimeSecField,"decimal? civilTimeSecField = civil?.second;"
utcOffsetHours,"int utcOffsetHours = 0;"
utcOffsetMinutes,"int utcOffsetMinutes = 0;"
utcOffsetSeconds,"decimal utcOffsetSeconds = 0.0;"
utcOffset,"ZoneOffset? utcOffset = civil?.utcOffset;"
timeAbbrevField,"string? timeAbbrevField = civil?.timeAbbrev;"
timeAbbrev,"string timeAbbrev = (timeAbbrevField is string) ? timeAbbrevField : \"\";"
jsonKey,"string jsonKey = k.trim();"
node,"xml node = check traverseNode(value, allNamespaces, namespacesOfElem, options, jsonKey);"
node,"xml node = check getElement(jsonKey, check traverseNode(value, allNamespaces, namespacesOfElem, options), allNamespaces, options, check getAttributesMap(value, options, allNamespaces, parentNamespaces));"
arrayEntryTagKey,"string arrayEntryTagKey = \"\";"
item,"xml item;"
jMap,"map<anydata>|error jMap = node.ensureType();"
attributePrefix,"string attributePrefix = options.attributePrefix;"
element,"xml:Element element;"
index,"int? index = name.indexOf(\":\");"
prefix,"string prefix = name.substring(0, index);"
elementName,"string elementName = name.substring(index + 1, name.length());"
namespaceUrl,"string namespaceUrl = attributes[string `{${XMLNS_NAMESPACE_URI}}${prefix}`].toString();"
newAttributes,"map<string> newAttributes = attributes;"
value,"string value = newAttributes.get(string `{${XMLNS_NAMESPACE_URI}}`);"
attributes,"map<string> attributes = parentNamespaces.clone();"
attr,"map<json>|error attr = jTree.ensureType();"
index,"int? index = k.indexOf(\":\");"
suffix,"string suffix = k.substring(index + 1);"
startIndex,"int startIndex = getStartIndex(attributePrefix, k);"
prefix,"string prefix = k.substring(startIndex, index);"
namespaceUrl,"string namespaceUrl = namespaces.get(string `{${XMLNS_NAMESPACE_URI}}${prefix}`);"
startIndex,"int startIndex = 1;"
location,"int? location = key.indexOf(\"_\");"
namespaces,"map<string> namespaces = parentNamespaces.clone();"
prefix,"string prefix = k.substring(index + 1);"
cn,"string cn = check charAt(path, index);"
value,"string value = check charAt(path, index);"
c0,"string c0 = check charAt(path, 0);"
c1,"string c1 = check charAt(path, 1);"
size,"int size = path.length();"
c2,"string c2 = check charAt(path, 2);"
n,"int n = 3;"
cn,"string cn = check charAt(path, n);"
normalizedPath,"string normalizedPath = \"\";"
length,"int length = path.length();"
offset,"int offset = check nextNonSlashIndex(path, off, length);"
startIndex,"int startIndex = offset;"
c,"string c = check charAt(path, offset);"
validatedPath,"string validatedPath = check parse(path);"
offsetIndexes,"int[] offsetIndexes = check getOffsetIndexes(validatedPath);"
count,"int count = offsetIndexes.length();"
root,"string root;"
offset,"int offset;"
i,"int i = 0;"
parts,"string[] parts = [];"
ignore,"boolean[] ignore = [];"
parentRef,"boolean[] parentRef = [];"
remaining,"int remaining = count;"
begin,"int begin = offsetIndexes[i];"
length,"int length;"
j,"int j = i - 1;"
hasPrevious,"boolean hasPrevious = false;"
lowerCasePath,"string lowerCasePath = path.toLowerAscii();"
cleanBase,"string cleanBase = check normalizePath(base, CLEAN);"
cleanTarget,"string cleanTarget = check normalizePath(target, CLEAN);"
baseRoot,"string baseRoot;"
baseOffset,"int baseOffset;"
targetRoot,"string targetRoot;"
targetOffset,"int targetOffset;"
b0,"int b0 = baseOffset;"
bi,"int bi = baseOffset;"
t0,"int t0 = targetOffset;"
ti,"int ti = targetOffset;"
bl,"int bl = cleanBase.length();"
tl,"int tl = cleanTarget.length();"
remainder,"string remainder = cleanBase.substring(b0, bl);"
offsets,"int[] offsets = check getOffsetIndexes(remainder);"
noSeparators,"int noSeparators = offsets.length() - 1;"
relativePath,"string relativePath = \"..\";"
offset,"int offset = 0;"
root,"string root = \"\";"
n,"int n = input.length();"
prevC,"string prevC = \"\";"
c,"string c = check charAt(input, i);"
off,"int off = offset;"
length,"int length = input.length();"
a,"string[] a;"
b,"string b;"
pathCreated,"error? pathCreated = trap createLink();"
path,"string path = getTmpDir() + \"/test_link.txt\";"
resPath,"string|error resPath = normalizePath(path, SYMLINK);"
expected,"string|error expected = getSymLink();"
removeLinkResult,"error? removeLinkResult = trap removeLink();"
path,"string path = \"tests/resources/test.txt\";"
path,"string path = \"tests/resources/test_non_existent.txt\";"
path,"string path = \"/hoMe/UseR/\";"
normpath,"string|error normpath = normalizePath(path, NORMCASE);"
isAbs,"boolean|error isAbs = isAbsolutePath(path);"
fname,"string|error fname = basename(path);"
parentName,"string|error parentName = parentPath(input);"
normPath,"string|error normPath = normalizePath(input, CLEAN);"
path,"string[]|error path = splitPath(input);"
exvalues,"string[] exvalues = re`,`.split(expected);"
arrSize,"int arrSize = path.length();"
bpath,"string|error bpath = joinPath(...parts);"
relPath,"string|error relPath = relativePath(basePath, targetPath);"
headers,"map<string|string[]> headers = {};"
message,"AddItemRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/AddItem\", message, headers);"
message,"GetCartRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/GetCart\", message, headers);"
message,"EmptyCartRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/EmptyCart\", message, headers);"
message,"ListRecommendationsRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.RecommendationService/ListRecommendations\", message, headers);"
message,"Empty message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/ListProducts\", message, headers);"
message,"GetProductRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/GetProduct\", message, headers);"
message,"SearchProductsRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/SearchProducts\", message, headers);"
message,"GetQuoteRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ShippingService/GetQuote\", message, headers);"
message,"ShipOrderRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ShippingService/ShipOrder\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CurrencyService/GetSupportedCurrencies\", message, headers);"
message,"CurrencyConversionRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CurrencyService/Convert\", message, headers);"
message,"ChargeRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.PaymentService/Charge\", message, headers);"
message,"SendOrderConfirmationRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.EmailService/SendOrderConfirmation\", message, headers);"
message,"PlaceOrderRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CheckoutService/PlaceOrder\", message, headers);"
message,"AdRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.AdService/GetAds\", message, headers);"
textPrompt,"text:CreateCompletionRequest textPrompt = { prompt: string `generate a product descirption in 250 words about ${name}`, model: \"text-davinci-003\", max_tokens: 100 };"
completionRes,"text:CreateCompletionResponse completionRes = check openAIText->/completions.post(textPrompt);"
imagePrmt,"images:CreateImageRequest imagePrmt = {prompt: string `${name}, ${benefits}, ${features}`};"
imageRes,"images:ImagesResponse imageRes = check openAIImages->/images/generations.post(imagePrmt);"
product,"shopify:CreateProduct product = { product: { title: name, body_html: completionRes.choices[0].text, tags: features, product_type: productType, images: [{src: imageRes.data[0].url}] } };"
prodObj,"shopify:ProductObject prodObj = check shopify->createProduct(product);"
pid,"int? pid = prodObj?.product?.id;"
lastRowIndex,"int lastRowIndex = range.values.length() - 1;"
row,"(int|string|decimal)[] row = range.values[lastRowIndex];"
message,"string message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Albums/getAlbum\", message, headers);"
message,"Album message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Albums/addAlbum\", message, headers);"
message,"empty:Empty message = {};"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Albums/listAlbums\", message, headers);"
outputStream,"AlbumStream outputStream = new AlbumStream(result);"
streamValue,"var streamValue = self.anydataStream.next();"
nextRecord,"record {|Album value;|} nextRecord = {value: <Album>streamValue.value};"
clientEndpoint,"final http:Client clientEndpoint = check new (\"https: timeout: 10, httpVersion: http:HTTP_1_1"
returnArray,"(int|error)[] returnArray = [];"
count,"int count = -1;"
data,"record {|record {} value;|}? data = check queryResult.next();"
variable,"record {} variable = data.value;"
dbClient1,"Client dbClient1 = check new (jdbcUrl, user, password, options);"
dbClient2,"Client dbClient2 = check new (jdbcUrl, user, password, options);"
dbClient3,"Client dbClient3 = check new (jdbcUrl, user, password, options);"
dbClient4,"Client dbClient4 = check new (jdbcUrl, user, password, options);"
dbClient5,"Client dbClient5 = check new (jdbcUrl, user, password, options);"
resultArray,"stream<record {}, error?>[] resultArray = [];"
value,"record {} value = data.value;"
sqlError,"sql:ApplicationError sqlError = <sql:ApplicationError>dbError;"
sqlError,"sql:DatabaseError sqlError = <sql:DatabaseError>dbError;"
rwType,"MappingAtomicType rwType = { names: names.cloneReadOnly(), types: types.cloneReadOnly(), rest };"
roType,"MappingAtomicType roType = { names: rwType.names, types: readOnlyTypeList(rwType.types), rest: intersect(rest, READONLY) };"
roBdd,"readonly & bdd:Node roBdd = bdd:atom(self.ro);"
rwBdd,"readonly & bdd:Node rwBdd;"
s,"SemType s = new SemType(0, [[UT_MAPPING_RO, roBdd], [UT_MAPPING_RW, rwBdd]]);"
i,"int i = env.mappingDefs.length();"
dummy,"MappingAtomicType dummy = { names: [], types: [], rest: NEVER };"
sortedFields,"Field[] sortedFields = fields.sort(\"ascending\", fieldName);"
names,"string[] names = [];"
types,"SemType[] types = [];"
b,"bdd:Bdd b = <bdd:Bdd>t;"
mm,"BddMemo? mm = tc.mappingMemo[b];"
m,"BddMemo m;"
res,"boolean? res = m.isEmpty;"
isEmpty,"boolean isEmpty = bddEvery(tc, b, (), (), mappingFormulaIsEmpty);"
combined,"TempMappingSubtype combined;"
p,"Conjunction? p = posList.next;"
m,"var m = intersectMapping(combined, tc.mappingDefs[p.atom]);"
neg,"MappingAtomicType neg = tc.mappingDefs[negList.atom];"
pairing,"MappingPairing pairing;"
d,"SemType d = diff(posType, negType);"
mt,"TempMappingSubtype mt;"
i,"int? i = pairing.index1(name);"
posTypes,"SemType[] posTypes = shallowCopyTypes(pos.types);"
names,"string[] names = shallowCopyStrings(m.names);"
types,"SemType[] types = shallowCopyTypes(m.types);"
i,"int i = names.length();"
t,"SemType t = intersect(type1, type2);"
rest,"SemType rest = intersect(m1.rest, m2.rest);"
i1Prev,"int i1Prev = self.i1 - 1;"
p,"FieldPair p;"
name1,"string name1 = self.curName1();"
name2,"string name2 = self.curName2();"
c,"int c = code;"
some,"int some = self.some;"
subtypeList,"UniformSubtype[] subtypeList = [];"
code,"var code = <UniformTypeCode>numberOfTrailingZeros(some);"
loBits,"int loBits = self.some & (c - 1);"
n,"int n = 0;"
v,"int v = bits;"
flag,"int flag = 1;"
all1,"UniformTypeBitSet all1;"
all2,"UniformTypeBitSet all2;"
some1,"UniformTypeBitSet some1;"
some2,"UniformTypeBitSet some2;"
all,"UniformTypeBitSet all = all1 | all2;"
some,"UniformTypeBitSet some = (some1 | some2) & ~<int>all;"
subtypes,"UniformSubtype[] subtypes = [];"
data,"SubtypeData data;"
union,"var union = ops[code].union;"
all,"UniformTypeBitSet all = all1 & all2;"
some,"UniformTypeBitSet some = (some1 | all1) & (some2 | all2);"
intersect,"var intersect = ops[code].intersect;"
all,"UniformTypeBitSet all = all1 & ~<int>(all2 | some2);"
some,"UniformTypeBitSet some = (all1 | some1) & ~<int>all2;"
complement,"var complement = ops[code].complement;"
diff,"var diff = ops[code].diff;"
isEmpty,"var isEmpty = ops[code].isEmpty;"
bits,"UniformTypeBitSet bits;"
listDef,"ListDefinition listDef = new;"
mapDef,"MappingDefinition mapDef = new;"
simple,"SemType simple = uniformTypeUnion((1 << UT_NIL) | (1 << UT_BOOLEAN) | (1 << UT_INT)| (1 << UT_FLOAT)| (1 << UT_DECIMAL)| (1 << UT_STRING));"
j,"SemType j = union(simple, union(listDef.getSemType(env), mapDef.getSemType(env)));"
db,"DefBinding db = { desc, def, next };"
fields,"core:Field[] fields = [];"
f,"core:Field f = check parseField(env, b, jlist[i], pathAppend(parent, i));"
name,"json name = j[0];"
t,"core:SemType t = check parseType(env, b, j[1], pathAppend(path, 1));"
tem,"Binding? tem = b;"
loop,"boolean loop = true;"
nb,"NameBinding nb = { name, next: b, desc: t, path };"
s,"core:SemType[] s = [];"
t,"core:SemType t = check parseType(env, b, js[i], pathAppend(parent, i));"
result,"core:SemType result = binary(v[0], v[1]);"
path,"Path path = parent.clone();"
lines,"string[] lines = from var [name1, name2] in results let string s = name1 + \"<:\" + name2 order by s select s;"
env,"core:Env env = new;"
firstOk,"boolean firstOk = false;"
ok,"boolean ok = true;"
t1,"core:SemType t1 = check j:parse(env, j1);"
t2,"core:SemType t2 = check j:parse(env, j2);"
expect,"var expect = <[boolean,boolean]>relationExpect[rel];"
tem,"int tem = bdd:getCount();"
tc,"var tc = core:typeCheckContext(env);"
b,"boolean b = core:isSubtype(tc, t1, t2);"
index,"int? index = self.uniqueGreetings.indexOf(greeting);"
nextVal,"record {|int value;|} nextVal = {value: self.integers[self.cursor]};"
doubled,"int[] doubled = intArray.map(function(int value) returns int { return value * 2; });"
sortedArray,"int[] sortedArray = intArray.sort(array:DESCENDING, isolated function(int value) returns string[] { if (value < 5) { return [\"Z\", value.toString()]; } else { return [\"B\", value.toString()]; } });"
f1,"future<int> f1 = start calculate(\"365*24\");"
f2,"future<int> f2 = @strand {thread: \"any\"} start multiply(1, 2);"
hoursInYear,"int hoursInYear = wait f1;"
result2,"record { int r1; int r2; } result2 = wait {r1: f1, r2: f1};"
a,"int a = -385;"
b,"int:Unsigned8 b = 128;"
res1,"int:Unsigned8 res1 = a & b;"
byteVal,"byte byteVal = 12;"
byteArray1,"byte[] byteArray1 = [5, 24, 56, 243];"
byteArray2,"byte[] byteArray2 = base16 `aeeecdefabcd12345567888822`;"
byteArray3,"byte[] byteArray3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`;"
countryCapitals,"map<string> countryCapitals = { \"USA\": \"Washington, D.C.\", \"Sri Lanka\": \"Colombo\", \"England\": \"London\" };"
books,"xml books = xml `<books> <book> <name>Sherlock Holmes</name> <author>Sir Arthur Conan Doyle</author> </book> <book> <name>Harry Potter</name> <author>J.K. Rowling</author> </book> </books>`;"
p1,"Person|error p1 = new(\"John\");"
value,"string|int|boolean value = 10;"
fields,"anydata[] fields = [];"
httpClient,"http:Client httpClient = checkpanic new (\"https:"
response,"string response = <string>checkpanic httpClient->get(string `/v4/?expr=${expr}`, targetType = string);"
result,"json result = { RequestID: ctx.getRequestId(), DeadlineMS: ctx.getDeadlineMs(), InvokedFunctionArn: ctx.getInvokedFunctionArn(), TraceID: ctx.getTraceId(), RemainingExecTime: ctx.getRemainingExecutionTime() };"
jsonRes2,"json jsonRes2 = { \"args\": {}, \"data\": \"POST: Hello World\", \"files\": {}, \"form\": {}, \"json\": null, \"url\": \"https: };"
j1,"json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Bob\"}];"
imagePath,"string imagePath = \"./files/ballerina.jpg\";"
isString,"boolean isString = imagePath is string;"
bytes,"byte[] bytes = check io:fileReadBytes(imagePath);"
blockStream,"stream<io:Block, io:Error> blockStream = check io:fileReadBlocksAsStream(imagePath, 2048);"
key,"string key = \"somesecret\";"
keyArr,"byte[] keyArr = key.toBytes();"
csvContent,"string[][] csvContent = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"], [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"], [\"5\", \"Oliver\", \"1100000\"]];"
csvStream,"stream<string[], io:Error> csvStream = check io:fileReadCsvAsStream(\"/path\");"
e,"error? e = csvStream.forEach(function(string[] val) { io:println(val); });"
readCsv,"string[][] readCsv = check io:fileReadCsv(\"csvFilePath1\");"
input,"string? input = ();"
name,"string name = input is () ? \"John Doe\" : input;"
t1,"[string|int, float, boolean] t1 = [1, 1.0, false];"
t2,"[int, float|string, boolean] t2 = [1, 1.0, false];"
v1,"[string, string] v1 = [\"Sample String\", \"Sample String 2\"];"
parsedNum,"int parsedNum = check parse(\"12\");"
parsedStr,"int parsedStr = check parse(\"invalid\");"
res,"var res = commit;"
invalidAccoundIdError,"error invalidAccoundIdError = error(\"INVALID_ACCOUNT_ID\", accountID = 7);"
canVote,"function (Person) returns boolean canVote = (p) => p.age >= 18;"
toEmployee,"var toEmployee = function(Person p, string pos) returns Employee => { name: p.name, designation: pos };"
t,"string t = \"Hello \".concat(name);"
immutableDetails,"Details & readonly immutableDetails = { name: \"May\", id: 112233 };"
codes,"final string[] & readonly codes = [\"AB\", \"CD\"];"
marks,"map<int> & readonly marks = { math: 80, physics: 85, chemistry: 75 };"
d,"readonly d = 5;"
m5,"map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};"
a,"int a = let int b = 1 in b * 2;"
greeting,"string greeting = let string hello = \"Hello \", string ballerina = \"Ballerina!\" in hello + ballerina;"
length,"int length = let var num = 10, var txt = \"four\" in num + txt.length();"
three,"int three = let int one = 1, int two = one + one in one + two;"
v2,"[int, int] v2 = [10, 20];"
tupleBindingResult,"int tupleBindingResult = let [int, int] [d1, d2] = v2, int d3 = d1 + d2 in d3 * 2;"
value,"any|error value = val.reduce(getStringValue, \"\");"
aValue,"string aValue = a is error ? a.toString() : a.toString();"
bValue,"string bValue = b is error ? b.toString() : b.toString();"
cache,"cache:Cache cache = new ({ capacity: 10, evictionFactor: 0.2, defaultMaxAgeInSeconds: 2, cleanupIntervalInSeconds: 3 });"
value,"string value = <string>check cache.get(\"key1\");"
keys,"string[] keys = cache.keys();"
w,"int|error w = parse(\"12\");"
y,"int y = checkpanic parse(\"120\");"
response1,"json response1 = { name: \"San Francisco Test Station,USA\", longitude: -122.43, latitude: 37.76, altitude: 150, rank: 1 };"
httpEndpoint,"http:Client httpEndpoint = checkpanic new (\"http: http:Request req = new;"
response,"var response = httpEndpoint->post(\"/cbr/route\", req);"
jsonRes,"var jsonRes = check response.getJsonPayload();"
nameString,"json|error nameString = response1;"
response2,"http:Response|http:PayloadType|error response2;"
result,"var result = httpEndpoint->respond(<@untainted>response2);"
insertRecords,"var insertRecords = [ {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1, creditLimit: 5000.75, country: \"USA\"}, {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2, creditLimit: 8000.00, country: \"USA\"}, {firstName: \"Bill\", lastName: \"John\", registrationID: 3, creditLimit: 3000.25, country: \"USA\"} ];"
insertQueries,"sql:ParameterizedQuery[] insertQueries = from var data in insertRecords select `INSERT INTO Customers (firstName, lastName, registrationID, creditLimit, country) VALUES (${data.firstName}, ${data.lastName}, ${data.registrationID}, ${data.creditLimit}, ${data.country})`;"
b1,"[string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];"
a,"int a = 3;"
foo,"var foo = function(int b) returns int { int c = 34; if (b == 3) { c = c + b + a + moduleA; } return c + a; };"
a,"int a = 2;"
func1,"var func1 = function(int x) returns int { int b = 23; a = a + 8; var func2 = function(int y) returns int { int c = 7; var func3 = function(int z) returns int { b = b + 1; return x + y + z + a + b + c; }; return func3(8) + y + x; }; return func2(4) + x; };"
rsaKeyArr,"byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];"
keyFile,"string keyFile = \"../resources/private.key\";"
privateKey,"crypto:PrivateKey privateKey = check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile);"
encryptedKeyFile,"string encryptedKeyFile = \"../resources/encrypted-private.key\";"
certFile,"string certFile = \"../resources/public.crt\";"
publicKey,"crypto:PublicKey publicKey = check crypto:decodeRsaPublicKeyFromCertFile(certFile);"
readDirResults,"file:MetaData[]|error readDirResults = file:readDir(\"foo\");"
participantEP,"http:Client participantEP = checkpanic new (\"http:"
price,"float price = 100.00;"
bizReq,"json bizReq = {symbol: \"GOODS\", price: price};"
result,"var result = participantEP->post(\"\", req);"
accountNotFoundError,"AccountNotFoundError accountNotFoundError = error AccountNotFoundError(\"ACCOUNT_NOT_FOUND\", accountID = accountID);"
fields,"string[] fields = [];"
response,"string response = <string>checkpanic httpClient->get(\"/v4/?expr=2*3\", targetType = string);"
response,"string response = <string>checkpanic httpClient->get(\"/v4/?expr=9*4\", targetType = string);"
result,"record { int w1; int w2; } result = wait {w1, w2};"
helloString,"handle helloString = java:fromString(\"Hello world\");"
arrayDeque,"var arrayDeque = newArrayDeque();"
e,"boolean|error e = trap offer(arrayDeque, java:createNull());"
csvch,"io:WritableCSVChannel csvch = check io:openWritableCsvFile(\"\");"
recIndex,"int recIndex = 0;"
recLen,"int recLen = 0;"
result1,"[string[], string[]] result1 = getFields(<map<json>>content[recIndex]);"
marks,"map<int> marks = {sam: 50, jon: 60};"
modifiedMarks,"map<int> modifiedMarks = marks.entries().map(function ([string, int] pair) returns int { var [name, score] = pair; io:println(io:sprintf(\"%s scored: %d\", name, score)); return score + 10; } );"
allMarks,"map<int> allMarks = {physics: 100, ...modifiedMarks, chemistry: 75};"
xmlValue,"xml<never> xmlValue = <xml<never>> 'xml:concat();"
someMap,"map<never> someMap = {};"
detailTable,"table<Details> key<never> detailTable = table [ {name: \"John\", id: 23}, {name: \"Paul\", id: 25} ];"
d1,"Details d1 = { name: \"Martin\", id: 1990 };"
d2,"Details d2 = { name: \"Michelle\", id: 2001};"
detailList,"Details[] detailList = [d1, d2];"
reportList,"any[] reportList = from var detail in detailList where detail.id >= 2.0 let string degreeName = \"Bachelor of Medicine\", int graduationYear = 1990 order by detail.name descending limit 2 select { name: detail.name, degree: degreeName, graduationYear: graduationYear };"
onConflictError,"error onConflictError = error(\"Key Conflict\", message = \"cannot insert report\");"
d3,"any|error d3 = table key(id) from var detail in detailList select { id: detail.id } on conflict onConflictError;"
moduleString,"string moduleString = \"Module(s): \" + \", \".'join(...modules);"
i,"int i = age;"
formattedCoordinates,"string[] formattedCoordinates = [];"
fileReadJson,"json fileReadJson = check io:fileReadJson(\"inputFile\");"
fillupEntries,"FillUpEntry[] fillupEntries = check fileReadJson.cloneWithType();"
sortedInput,"FillUpEntry[] sortedInput = fillupEntries.sort(array:ASCENDING, isolated function(FillUpEntry value) returns int => value.employeeId );"
baseTestDir,"string baseTestDir = check file:joinPath(baseDir, testDir);"
transformedTestDir,"string transformedTestDir = check file:joinPath(transformedDir, testDir);"
skipped,"TestDiffResult[] skipped = [];"
changed,"TestDiffResult[] changed = [];"
unchanged,"TestDiffResult[] unchanged = [];"
baseTestFile,"string baseTestFile = check file:joinPath(baseTestDir, test);"
transformedTestFile,"string transformedTestFile = check file:joinPath(transformedTestDir, test);"
baseTests,"TestCase[] baseTests = check parseTests(baseTestFile);"
transformedTests,"TestCase[] transformedTests = check parseTests(transformedTestFile);"
lines,"string[] lines = check io:fileReadLines(path);"
content,"string[] content = [];"
description,"string description = \"\";"
tests,"TestCase[] tests = [];"
s,"State s = CONTENT;"
baseIndex,"int baseIndex = 0;"
transformedIndex,"int transformedIndex = 0;"
baseDescription,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
baseContent,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
transformedDescription,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
transformedContent,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
body,"string[] body = [];"
currentPath,"string currentPath = \"\";"
path,"string path = diff.base.path;"
parts,"string[] parts = check file:splitPath(absPath);"
newContent,"string[] newContent = [\"import ballerina/io;\"];"
newLabels,"string[] newLabels = [];"
initFunc,"string initFunc = \"function init()\";"
newLine,"string newLine;"
starIndex,"int? starIndex = line.indexOf(\"{\");"
endIndex,"int? endIndex = line.indexOf(\"}\");"
targetIndex,"int targetIndex = <int>line.indexOf(\"?;\");"
i,"int? i = s.indexOf(\":\");"
fieldName,"string fieldName = s.substring(0, i);"
fieldValue,"string fieldValue = s.substring(i + 1);"
labels,"string[] labels = [];"
skipped,"int skipped = 0;"
skipIndices,"int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];"
skipTest,"boolean skipTest = false;"
outputFileName,"string outputFileName = string `./tests/${dir}/${filename}`;"
invalid,"boolean invalid = true;"
aliasName,"string aliasName = self.escapeGlobalIdent(name);"
alias,"ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), \"@\" + aliasName);"
varName,"string varName = escapeIdent(name);"
out,"Output out = new;"
words,"string[] words = [\"target\", \"triple\", \"=\", \"\\"\", <TargetTriple>self.target, \"\\"\"];"
line,"string[] line = [alias.operand, \"=\"];"
words,"string[] words = [];"
initializer,"var initializer = prop.initializer;"
metadata,"Metadata metadata = new(self.genMetadataLabel());"
attrib,"ReturnEnumAttribute attrib = attribute[1];"
attrib,"ParamEnumAttribute attrib = attribute[1];"
paramIndex,"int paramIndex = attribute[0];"
paramType,"final Type paramType = functionType.paramTypes[i];"
register,"string register = \"%\" + i.toString();"
arg,"Value arg = new (paramType, register);"
isFirst,"boolean isFirst = true;"
bbName,"string|Unnamed bbName = self.genName(name);"
bb,"BasicBlock bb = new (self.context, bbName, self);"
varName,"string varName = name;"
count,"int count = self.variableNames.get(varName);"
newName,"string newName = varName + \".\" + count.toString();"
varName,"int varName = self.unnamedLabelCount;"
reg,"string|Unnamed reg = self.genName(name);"
newLabel,"string newLabel = self.nameCounter.toString();"
newName,"string newName = \"%\" + self.nameCounter.toString();"
newName,"string newName = self.nameTranslation[name];"
metadata,"Metadata metadata = self.m.addMetadata();"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_pointer_type\"];"
name,"string? name = props.name;"
alignInBits,"Alignment? alignInBits = props.alignInBits;"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_typedef\", \",\", \"name\", \":\", \"\\"\", name, \"\\"\", \",\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
encodingToString,"string encodingToString = \"DW_ATE_\" + props.encoding;"
align,"int? align = props.alignInBits;"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.value\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.declare\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
scope,"Metadata? scope = props.scope;"
file,"Metadata? file = props.file;"
ty,"Metadata? ty = props.ty;"
flags,"string[] flags = [];"
retainedNodes,"Metadata retainedNodes = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"distinct\", \"!\", \"DILexicalBlock\", \"(\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
typeNode,"Metadata typeNode = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"!\", \"DILocation\", \"(\"];"
bb,"BasicBlock bb = self.bb();"
reg,"string|Unnamed reg = bb.func.genReg(name);"
ptrTy,"PointerType ptrTy = pointerType(ty);"
ty,"Type ty = ptr.ty.pointsTo;"
ty,"IntType|FloatType ty = sameNumberType(lhs, rhs);"
ty,"IntegralType ty = sameIntegralType(lhs, rhs);"
words,"(string|Unnamed)[] words = [reg, \"=\"];"
valueType,"Type valueType = val.ty;"
valTy,"Type valTy = val.ty;"
insnWords,"(string|Unnamed)[] insnWords;"
retType,"RetType retType;"
fnTy,"Type fnTy = fn.ty.pointsTo;"
fnName,"var fnName = fn.operand;"
functionName,"string functionName = \"@\" + fn.functionName;"
words,"(string|Unnamed)[] words = [reg];"
insnWords,"(string|Unnamed)[] insnWords = [];"
arg,"final Value arg = args[i];"
elementType,"Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);"
condTy,"Type condTy = condition.ty;"
words,"(string|Unnamed)[] words = [];"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);"
tem,"BasicBlock? tem = self.currentBlock;"
chunks,"(string|Unnamed)[] chunks = [];"
currentChunk,"string[] currentChunk = [];"
newLines,"(string|Unnamed)[][] newLines = [];"
newLine,"(string|Unnamed)[] newLine = [];"
newLine,"string[] newLine = [];"
outputLine,"string outputLine = createLine([concat(...newLine)], INDENT);"
ty1,"Type ty1 = v1.ty;"
ty2,"Type ty2 = v2.ty;"
tyName,"string? tyName = ty.name;"
elementTypes,"Type[] elementTypes = ty.elementTypes;"
typeStringBody,"string[] typeStringBody = [];"
elementType,"final Type elementType = elementTypes[i];"
paramType,"final Type paramType = ty.paramTypes[i];"
elementTypes,"Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);"
metadata,"Metadata? metadata = fn.metadata;"
ty,"final Type ty = fn.functionType.paramTypes[i];"
lastTail,"string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : \"\";"
head,"string head = word.length() > 0 ? word.substring(0, 1) : \"\";"
escaped,"string escaped = \"\\"\";"
cp,"int cp = ch.toCodePointInt();"
bytes,"byte[] bytes = ch.toBytes();"
result,"string result = \"\";"
hex,"string hex = cp.toHexString().toUpperAscii();"
ptrTy,"Type ptrTy = ptr.ty;"
resultType,"Type resultType = ptr.ty;"
resultAddressSpace,"int resultAddressSpace = 0;"
i,"int i;"
indexTy,"Type indexTy = index.ty;"
result,"string result = \"c\\"\";"
hex,"string hex = b.toHexString().toUpperAscii();"
endPos,"Position endPos = tok.previousEndPos();"
endPos,"Position endPos = tok.currentEndPos();"
valueExpr,"SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);"
td,"TypeDesc td = check parseTypeDesc(tok);"
startPos,"Position startPos = tok.currentStartPos();"
params,"FunctionTypeParam[] params = namedParams ?: [];"
paramStartPos,"Position paramStartPos = tok.currentStartPos();"
ret,"TypeDesc? ret = ();"
t,"Token? t = tok.current();"
namePos,"Position namePos = tok.currentStartPos();"
name,"string name = check tok.expectIdentifier();"
members,"TypeDesc[] members = [];"
rest,"TypeDesc? rest = ();"
fields,"FieldDesc[] fields = [];"
fieldStartPos,"Position fieldStartPos = tok.currentStartPos();"
ro,"boolean ro = false;"
opt,"boolean opt = false;"
endPos,"Position endPos = check tok.expectEnd(\";\");"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };"
expr,"FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: () };"
expr,"Expr expr = check parseExpr(tok);"
expr,"LiteralExpr expr = { startPos, endPos, value: t == \"true\" };"
kwPos,"Position kwPos = tok.currentStartPos();"
message,"Expr message = check parseExpr(tok);"
fields,"Field[] fields = check parseFields(tok);"
opPos,"Position opPos = tok.currentStartPos();"
index,"Expr index = check parseExpr(tok);"
accessEndPos,"Position accessEndPos = check tok.expectEnd(\"]\");"
accessExpr,"MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };"
qnamePos,"Position qnamePos = tok.currentStartPos();"
name,"string name = check parseIdentifierOrMethodName(tok);"
fieldAccessExpr,"FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };"
openParenPos,"Position openParenPos = tok.currentStartPos();"
exprs,"Expr[] exprs = [];"
closeTerminatorPos,"Position closeTerminatorPos = tok.currentStartPos();"
fields,"Field[] fields = [];"
f,"Field f = check parseField(tok);"
isIdentifier,"boolean isIdentifier = t[0] == IDENTIFIER;"
name,"string name = t[1];"
colonPos,"Position colonPos = tok.currentStartPos();"
value,"Expr value = check parseExpr(tok);"
f,"Field f = { startPos, endPos, colonPos, name, value, isIdentifier };"
operand,"NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);"
expr,"SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };"
expr,"LiteralExpr expr = { startPos, endPos, value };"
endPos,"Position endPos = check tok.expectEnd(\")\");"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits };"
fragment,"string fragment = self.fragments[self.fragmentIndex];"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex];"
t,"Token? t = self.curTok;"
msg,"d:Message msg;"
pos,"Position pos = self.currentEndPos();"
pos,"Position pos = self.currentStartPos();"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex - 1];"
startPos,"Position startPos;"
endPos,"Position? endPos;"
line,"ScannedLine line = self.scannedLine(startLineNum);"
lineFragments,"string[] lineFragments = scanLineFragments(line);"
lineContent,"string lineContent = \"\".'join(...lineFragments);"
endColumnNum,"int endColumnNum;"
endLineNum,"int endLineNum;"
line,"ScannedLine line = self.scannedLine(lineNum);"
endColumnNum,"int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);"
fragments,"string[] fragments = line.fragments;"
fragCodes,"FragCode[] fragCodes = line.fragCodes;"
endCodePointIndex,"int endCodePointIndex = startCodePointIndex;"
fragmentIndex,"int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);"
nCodePoints,"int nCodePoints = 0;"
fragmentIndex,"int fragmentIndex = 0;"
nFragments,"int nFragments = fragments.length();"
fragCode,"FragCode fragCode = fragCodes[fragmentIndex];"
sources,"SingleStringTokenizerTestCase[] sources = [ [\"E\", string`\"`], [\"E\", \"'\"], [\"E\", \"`\"], [\"E\", string`\"\\"`], [\"E\", string`\"\a\"`], [\"E\", string`\`], [\"E\", string`\"${ \"\n\" }\"`], [\"E\", string`\"${ \"\r\" }\"`], [\"E\", string`\"\\`], [\"E\", string`\"\u{}\"`], [\"E\", \"\\"\\\" + \"u{D800}\\"\"], [\"E\", \"\\"\\\" + \"u{DFFF}\\"\"], [\"E\", \"\\"\\\" + \"u{110000}\\"\"], [\"E\", string`\"\u{X}\"`], [\"E\", string`\"\u{-6A}\"`], [\"E\", string`\"\u\"`], [\"E\", string`\"\u{\"`], [\"E\", string`\"\u{0\"`] ];"
tests,"map<TokenizerTestCase> tests = {};"
tests,"map<ParserTestCase> tests = {};"
testData,"ParserTestJson[] testData = check (check io:fileReadJson(\"modules/front.syntax/tests/data/testParser.json\")).fromJsonWithType();"
expected,"string[] expected;"
subject,"string subject = s[2];"
subjectLines,"string[] subjectLines = splitIntoLines(subject);"
rule,"string rule = s[1];"
testFiles,"var testFiles = check file:readDir(\"modules/front.syntax/tests/data\");"
path,"string path = f.absPath;"
base,"string base = check file:basename(path);"
src,"string[] src = check readCase(path);"
parentDir,"string parentDir = check file:parentPath(path);"
canonFile,"string canonFile = check file:joinPath(parentDir, canonFileName(base));"
baseParts,"[Kind, string] baseParts = check splitTestName(base);"
rule,"string rule = baseParts[1];"
len,"int len = base.length();"
kindPos,"int kindPos = base.indexOf(\"-\") ?: 0;"
kind,"string kind = base.substring(0, kindPos);"
afterKindPos,"int afterKindPos = min(kindPos + 1, len);"
rulePos,"int rulePos = base.indexOf(\"-\", afterKindPos) ?: afterKindPos;"
rule,"string rule = base.substring(afterKindPos, rulePos);"
caseLines,"string[] caseLines = [];"
inCase,"boolean inCase = false;"
indented,"int indented = 0;"
trimLine,"string trimLine = line.trim();"
sansExt,"string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());"
line,"ScannedLine line = file.scannedLine(lineIndex);"
lineContent,"string lineContent = \"\".'join(...scanLineFragments(line));"
rest,"string rest = lineContent.substring(isEndPos ? columnIndex - 1 : columnIndex);"
fields,"t:Field[] fields = [];"
f,"t:Field f = check parseField(tc, b, jlist[i], pathAppend(parent, i));"
ty,"t:SemType ty = check parseType(tc, b, j[1], pathAppend(path, 1));"
s,"t:SemType[] s = [];"
t,"t:SemType t = check parseType(tc, b, js[i], pathAppend(parent, i));"
result,"t:SemType result = binary(v[0], v[1]);"
i,"int? i = path.lastIndexOf(\"/\");"
filename,"string filename = i == () ? path : path.substring(i + 1);"
onPanic,"bir:Label? onPanic = block.onPanic;"
blockPanic,"readonly & BlockPanic blockPanic = onPanic == () ? [\"no-panic\"] : [\"on-panic\", formLabel(sc, onPanic)];"
insns,"(Insn & readonly|Position & readonly)[] insns = [];"
args,"(readonly & Operand)[] args = from var arg in insn.operands.slice(1) select fromOperand(sc, arg);"
func,"bir:FunctionRef func = insn.operands[0].value;"
ref,"FunctionRef ref = fromFunctionRefAccum(sc, func);"
entires,"MapEntry[] entires = [];"
preds,"TypeMergePred[] preds = [];"
insnSexpr,"sexpr:Data[] insnSexpr = [INSN_NAMES_SEXPR.get([insn.name, insn?.op]).sexpr];"
result,"bir:Register? result = insn?.result;"
operand,"bir:Operand? operand = insn?.operand;"
operands,"bir:Operand[]? operands = insn?.operands;"
value,"t:SingleValue|bir:FunctionRef value = op.value;"
ib,"int|boolean ib = value;"
symbol,"bir:Symbol symbol = funcRef.symbol;"
identifier,"string identifier = symbol.identifier;"
id,"ModuleId & readonly id = formModuleId(symbol.module);"
decls,"ModuleDeclsMemo decls = addGetModDecls(sc, id);"
existing,"ModuleDeclsMemo? existing = sc.decls[id];"
newDecl,"ModuleDeclsMemo newDecl = { id };"
params,"readonly & ts:Type[] params = from var t in sig.paramTypes select fromType(sc, t).cloneReadOnly();"
ret,"readonly & ts:Type ret = fromType(sc, sig.returnType);"
rest,"readonly & ts:Type rest = sig.restParamType != () ? fromType(sc, <t:SemType>sig.restParamType) : fromType(sc, t:NEVER);"
result,"IdNames result = table[];"
names,"map<true> names = {};"
maybeId,"string maybeId = names.hasKey(srcName) ? id.toString() : \"\";"
name,"string name = prefix + maybeId + \".\" + srcName;"
sexprAtoms,"t:AtomTableSexpr sexprAtoms = map from var [name, atom] in namedAtoms select [name.s, atom];"
atoms,"t:AtomTable atoms = t:atomTableFromSexpr(env, sexprAtoms);"
vFilesByName,"map<VirtualFile> vFilesByName = map from var [i, f] in files.enumerate() select [f[0].s, new(i, f[1].s, f.length() > 2 ? f[2].s : ())];"
funcDefns,"bir:FunctionDefn[] funcDefns = [];"
internalFuncDecl,"map<t:FunctionSignature> internalFuncDecl = {};"
funcCodes,"FunctionCode[] funcCodes = [];"
signature,"t:FunctionSignature signature = toFunctionSignature(env, atoms, sig);"
extFuncDecl,"ExternalFuncDecls extFuncDecl = table[];"
pc,"ParseContext pc = { tc, atoms, extFuncDecl, internalFuncDecl };"
vFiles,"VirtualFile[] vFiles = from var f in vFilesByName order by f.partIndex() select f;"
mod,"VirtualModule mod = new(pc, modId, funcDefns.cloneReadOnly(), funcCodes, vFiles);"
restParamType,"t:SemType restParamType = t:fromSexpr(env, atoms, rest);"
regMap,"map<bir:Register> regMap = {};"
regList,"bir:Register[] regList = [];"
regIndex,"int regIndex = 0;"
blockLabels,"map<bir:Label> blockLabels = {};"
label,"bir:Label label = 0;"
birBlocks,"bir:BasicBlock[] birBlocks = [];"
label,"int label = 0;"
insns,"bir:Insn[] insns = [];"
pos,"Position? pos = ();"
scope,"bir:RegisterScope scope = { scope: (), startPos: 0, endPos: 0 };"
pos,"bir:Position pos = 0;"
name,"string name = toMaybeName(nameSexpr) ?: \"_\";"
semType,"t:SemType semType = toSemType(pc, semTypeSexpr);"
underlying,"bir:Register? underlying = prevRegs[underlyingName];"
name,"string? name = toMaybeName(nameSexpr);"
dotPos,"int? dotPos = name.indexOf(\".\");"
pos,"bir:Position pos = posSexpr != () ? createPosition(posSexpr[1], posSexpr[2]) : 0;"
fieldNames,"string[] fieldNames = [];"
operands,"bir:Operand[] operands = [];"
fieldOperandsTyped,"[sexpr:String, Operand][] fieldOperandsTyped = checkpanic fieldOperands.cloneWithType();"
operandsWithType,"Operand[] operandsWithType = checkpanic operands.cloneWithType();"
operands,"bir:Register[] operands = [];"
predecessors,"bir:Label[] predecessors = [];"
predOperandsTyped,"[sexpr:Symbol, Label][] predOperandsTyped = checkpanic predOperands.cloneWithType();"
name,"var { bir: name, op } = INSN_NAMES_BIR_OP.get(insnSexpr[0]);"
insn,"BirInsnBase? insn = ();"
symbol,"bir:Symbol|bir:Register symbol = symbolSexpr is FunctionRef ? symbolFromSexpr(symbolSexpr): lookupRegister(pc, symbolSexpr);"
args,"readonly & bir:Operand[] args = from var arg in argsSexpr select toOperand(pc, arg);"
result,"var result = toResultRegister(pc, resultSexpr);"
erasedSignature,"t:FunctionSignature erasedSignature = lookupSignature(pc, symbol);"
signature,"t:FunctionSignature signature;"
func,"bir:FunctionConstOperand func = { value: { symbol, signature, erasedSignature }, semType: t:functionSemType(pc.tc, signature) };"
module,"bir:ModuleId module = { org: org.s, names: [nameFirst.s, ...from var { s } in nameRest select s] };"
symbol,"bir:Symbol symbol = symbolFromSexpr(<FunctionRef>symbolSexpr);"
signature,"t:FunctionSignature signature = lookupSignature(pc, symbol);"
semType,"t:SemType semType = t:functionSemType(pc.tc, signature);"
names,"readonly & [string, string...] names = [first.s, ...from var { s } in rest select s];"
length,"int length = fieldNames.length();"
requiredFieldNames,"string[] requiredFieldNames = mat.names;"
nRequiredFields,"int nRequiredFields = requiredFieldNames.length();"
requiredFieldIndex,"map<int> requiredFieldIndex = {};"
mappingReg,"bir:Register mappingReg = insn.operands[0];"
keyOperand,"bir:StringOperand keyOperand = insn.operands[1];"
fieldIndex,"int? fieldIndex = mappingFieldIndex(scaffold.typeContext(), mappingReg.semType, keyOperand);"
fill,"boolean fill;"
rf,"RuntimeFunction rf;"
k,"llvm:Value k;"
mapping,"llvm:Value mapping = builder.load(scaffold.address(mappingReg));"
memberWithErr,"llvm:Value memberWithErr = buildRuntimeFunctionCall(builder, scaffold, rf, [mapping, k]);"
member,"llvm:Value member = fill ? buildCheckPanicCode(builder, scaffold, memberWithErr, insn.pos) : memberWithErr;"
resultType,"t:SemType resultType = insn.result.semType;"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(tc, mappingType);"
peResult,"t:SemType peResult = t:intersect(resultType, POTENTIALLY_EXACT);"
lat,"t:ListAtomicType? lat = t:listAtomicType(tc, listType);"
ty,"t:SemType ty = t:intersect(semType, within);"
mappingType,"bir:SemType mappingType = mappingReg.semType;"
tc,"t:Context tc = scaffold.typeContext();"
newMemberOperand,"bir:Operand newMemberOperand = insn.operands[2];"
memberType,"t:SemType memberType = t:mappingMemberTypeInnerVal(scaffold.typeContext(), mappingType, keyOperand.semType);"
err,"llvm:Value err = buildRuntimeFunctionCall(builder, scaffold, rf, [ builder.load(scaffold.address(mappingReg)), k, check buildWideRepr(builder, scaffold, newMemberOperand, REPR_ANY, memberType) ]);"
k,"string? k = t:singleStringShape(keyOperand.semType);"
rf,"RuntimeFunction rf = overloadsExactBit(sourceType) ? taggedMemberClearExactAnyFunction : taggedMemberClearExactPtrFunction;"
continueBlock,"llvm:BasicBlock continueBlock = scaffold.addBasicBlock();"
errorBlock,"llvm:BasicBlock errorBlock = scaffold.addBasicBlock();"
valueToExactify,"llvm:PointerValue? valueToExactify = ();"
hasType,"llvm:Value hasType;"
baseRepr,"BaseRepr baseRepr = repr.base;"
tagged,"llvm:PointerValue tagged = <llvm:PointerValue>value;"
bitSet,"t:BasicTypeBitSet? bitSet = testTypeAsBasicBitSet(scaffold.typeContext(), operand.semType, semType);"
intConstraints,"t:IntSubtypeConstraints? intConstraints = t:intSubtypeConstraints(semType);"
sub,"t:BooleanSubtype sub = <t:BooleanSubtype>t:booleanSubtype(<t:ComplexSemType>semType);"
ifTrue,"llvm:BasicBlock ifTrue = scaffold.basicBlock(insn.ifTrue);"
ifFalse,"llvm:BasicBlock ifFalse = scaffold.basicBlock(insn.ifFalse);"
sourceReg,"var sourceReg = register.underlying;"
sourceRepr,"var sourceRepr = scaffold.getRepr(sourceReg);"
value,"var value = builder.load(scaffold.address(sourceReg));"
semType,"t:SemType semType = register.semType;"
narrowed,"llvm:Value narrowed = check buildNarrowRepr(builder, scaffold, sourceRepr, value, scaffold.getRepr(register));"
unnarrowed,"bir:Register unnarrowed = bir:unnarrow(insn.operands[0]);"
semType,"t:SemType semType = insn.result.semType;"
narrowed,"llvm:Value narrowed = check buildNarrowRepr(builder, scaffold, sourceRepr, value, scaffold.getRepr(insn.result));"
sourceBaseRepr,"BaseRepr sourceBaseRepr = sourceRepr.base;"
targetBaseRepr,"BaseRepr targetBaseRepr = targetRepr.base;"
bitSet,"t:BasicTypeBitSet bitSet = t:widenToBasicTypes(targetType);"
btCode,"t:BasicTypeCode? btCode = t:basicTypeCode(bitSet);"
lestSignificant,"llvm:ConstValue lestSignificant = context.constInt(\"i64\", leastSignificantVal);"
mostSignificant,"llvm:ConstValue mostSignificant = context.constInt(\"i64\", mostSignificantVal);"
ptr,"llvm:ConstPointerValue ptr = mod.addGlobal(llvm:arrayType(\"i64\", 2), decimalDefnSymbol(defnIndex), initializer = context.constArray(\"i64\", [lestSignificant, mostSignificant]), align = 8, isConstant = true, unnamedAddr = true, linkage = \"internal\");"
nBytes,"int nBytes = bytes.length();"
nBytesPadded,"int nBytesPadded = (((nBytes + headerSize + 7) >> 3) << 3) - headerSize;"
w,"t:BasicTypeBitSet w = t:widenToBasicTypes(ty);"
constraints,"t:IntSubtypeConstraints? constraints = t:intSubtypeConstraints(ty);"
repr,"IntRepr repr = { constraints, alwaysInImmediateRange: isIntConstrainedToImmediate(constraints) };"
supported,"int supported = t:NIL|t:BOOLEAN|t:INT|t:FLOAT|t:DECIMAL|t:STRING|t:LIST|t:MAPPING|t:ERROR|t:FUNCTION;"
maximized,"int maximized = w | supported;"
repr,"TaggedRepr repr = { subtype: w, alwaysImmediate: isSemTypeAlwaysImmediate(ty, w) };"
strSubtype,"t:StringSubtype|boolean strSubtype = t:stringSubtype(ty);"
bytes,"byte[] bytes = s.toBytes();"
initValue,"llvm:ConstValue initValue = context.constStruct([funcDesc, func]);"
ptr,"llvm:ConstPointerValue ptr = llMod.addGlobal(functionValueType(signature), functionDefnSymbol(defnIndex), initializer = initValue, align = 8, isConstant=true, unnamedAddr=true, linkage= \"internal\");"
result,"bir:Register result = insn.result;"
subtype,"t:BasicTypeBitSet subtype = lhsRepr.subtype | rhsRepr.subtype;"
orderTypeMinusNil,"t:BasicTypeBitSet orderTypeMinusNil = subtype & ~t:NIL;"
lhsType,"t:SemType lhsType = lhs.semType;"
rhsType,"t:SemType rhsType = rhs.semType;"
orderTypeMinusNilCode,"var orderTypeMinusNilCode = <t:BasicTypeCode>t:basicTypeCode(orderTypeMinusNil);"
compareFunc,"RuntimeFunction compareFunc = compareFunctions.get(orderTypeMinusNilCode).optCompareFunction;"
memberType,"t:BasicTypeBitSet memberType = 0;"
memberTypeCode,"t:BasicTypeCode? memberTypeCode = t:basicTypeCode(memberType);"
tcf,"TaggedCompareFunction? tcf = compareFunctions[memberTypeCode];"
atomic,"t:ListAtomicType? atomic = t:listAtomicType(tc, semType);"
bbExact,"llvm:BasicBlock bbExact = scaffold.addBasicBlock();"
bbInexact,"llvm:BasicBlock bbInexact = scaffold.addBasicBlock();"
bbJoin,"llvm:BasicBlock bbJoin = scaffold.addBasicBlock();"
isExact,"llvm:Value isExact = builder.iBitwise(\"and\", buildIsExact(builder, scaffold, lhs), buildIsExact(builder, scaffold, rhs));"
transform,"TaggedCompareResultTransform transform = taggedCompareResultTransforms.get(insn.op);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, comparator, [lhs, rhs]);"
bbJoin,"llvm:BasicBlock bbJoin = buildCompareTaggedBasic(builder, scaffold, lhs, rhs, result);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagInt(builder, scaffold, <llvm:PointerValue>lhs);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagFloat(builder, scaffold, <llvm:PointerValue>lhs);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagBoolean(builder, <llvm:PointerValue>lhs);"
bbNil,"llvm:BasicBlock bbNil = scaffold.addBasicBlock();"
bbNotNil,"llvm:BasicBlock bbNotNil = scaffold.addBasicBlock();"
isNil,"llvm:Value isNil = builder.iCmp(\"eq\", lhs, scaffold.llContext().constNull(llvm:pointerType(\"i8\", 1)));"
diScope,"DIScope diScope = self.diBuilder.createLexicalBlock(parent.diScope, self.diFile, line, column);"
loc,"DILocation loc;"
noLineLoc,"DILocation? noLineLoc = self.noLineLocation;"
charMeta,"llvm:Metadata charMeta = diBuilder.createBasicType(name=\"char\", encoding=\"signed_char\", sizeInBits=8);"
emptyExpr,"llvm:Metadata emptyExpr = diScaffold.diBuilder.createExpression([]);"
scope,"Scope scope = addToParentScope(register.scope, register.pos, diScaffold.rootScope, diScaffold);"
tyMeta,"llvm:Metadata tyMeta = diScaffold.registerTypeToMetadata(register);"
childCount,"int childCount = parent.childScopes.length();"
addIndex,"int? addIndex = ();"
child,"Scope child = parent.childScopes[i];"
newScope,"Scope newScope = diScaffold.createScope(declPos, registerScope.endPos, parent, [child]);"
newScope,"Scope newScope = diScaffold.createScope(declPos, registerScope.endPos, parent, []);"
newChildScopes,"Scope[] newChildScopes = parent.childScopes.slice(0, addIndex);"
varMeta,"llvm:Metadata varMeta = diBuilder.createAutoVariable(ty=tyMeta, scope=diScope, name=register.name, lineNo=line, file=diFile);"
declLoc,"llvm:Metadata declLoc = diBuilder.createDebugLocation(line, column, diScope);"
intrinsicName,"llvm:IntrinsicFunctionName? intrinsicName = buildBinaryIntIntrinsic(insn.op);"
lhs,"llvm:Value lhs = buildInt(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildInt(builder, scaffold, insn.operands[1]);"
result,"llvm:Value result;"
joinBlock,"llvm:BasicBlock? joinBlock = ();"
intrinsicFunction,"llvm:FunctionDecl intrinsicFunction = scaffold.getIntrinsicFunction(intrinsicName);"
resultWithOverflow,"llvm:Value resultWithOverflow = <llvm:Value>builder.call(intrinsicFunction, [lhs, rhs]);"
overflowBlock,"llvm:BasicBlock overflowBlock = scaffold.addBasicBlock();"
zeroDivisorBlock,"llvm:BasicBlock zeroDivisorBlock = scaffold.addBasicBlock();"
op,"llvm:IntArithmeticSignedOp op;"
b,"llvm:BasicBlock b = scaffold.addBasicBlock();"
op,"llvm:IntArithmeticOp op = intArithmeticOps.get(insn.op);"
result,"llvm:Value result = builder.iArithmeticNoWrap(op, lhs, rhs);"
lhs,"llvm:Value lhs = buildFloat(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildFloat(builder, scaffold, insn.operands[1]);"
op,"llvm:FloatArithmeticOp op = floatArithmeticOps.get(insn.op);"
result,"llvm:Value result = builder.fArithmetic(op, lhs, rhs);"
lhs,"llvm:Value lhs = buildDecimal(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildDecimal(builder, scaffold, insn.operands[1]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalArithmeticFuncs.get(insn.op), [lhs, rhs]);"
operand,"llvm:Value operand = buildFloat(builder, scaffold, insn.operand);"
result,"llvm:Value result = builder.fNeg(operand);"
op,"llvm:IntBitwiseOp op = binaryBitwiseOp.get(insn.op);"
result,"llvm:Value result = builder.iBitwise(op, lhs, rhs);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, convertToIntFunction, [val]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, floatToIntFunction, [floatVal]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalToIntFunction, [decimalVal]);"
errBlock,"llvm:BasicBlock errBlock = scaffold.addBasicBlock();"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, convertToFloatFunction, [val]);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, decimalToFloatFunction, [decimalVal]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, convertToDecimalFunction, [val]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalFromFloatFunction, [floatVal]);"
operand,"llvm:Value operand = buildDecimal(builder, scaffold, insn.operand);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, decimalNegFunction, [operand]);"
funcTy,"t:SemType funcTy = funcOperand.semType;"
atomic,"t:FunctionAtomicType? atomic = t:functionAtomicType(scaffold.typeContext(), funcTy);"
argTypes,"t:SemType[] argTypes = from var arg in args select arg.semType;"
returnType,"t:SemType returnType = <t:SemType>t:functionReturnType(scaffold.typeContext(), funcTy, t:tupleTypeWrappedRo(tc.env, ...argTypes));"
signature,"t:FunctionSignature signature = t:functionSignature(scaffold.typeContext(), atomic);"
signatureDescPtr,"llvm:ConstPointerValue signatureDescPtr = scaffold.getCalledType(signature);"
isExact,"llvm:Value isExact = buildRuntimeFunctionCall(builder, scaffold, functionIsExactFunction, [signatureDescPtr, builder.addrSpaceCast(funcValuePtr, heapPointerType(llFunctionType))]);"
ifExact,"llvm:BasicBlock ifExact = scaffold.addBasicBlock();"
ifNotExact,"llvm:BasicBlock ifNotExact = scaffold.addBasicBlock();"
afterCall,"llvm:BasicBlock afterCall = scaffold.addBasicBlock();"
untaggedFuncValuePtr,"llvm:PointerValue untaggedFuncValuePtr = buildUntagPointer(builder, scaffold, scaffold.address(operand));"
funcValuePtr,"llvm:PointerValue funcValuePtr = builder.bitCast(builder.addrSpaceCast(untaggedFuncValuePtr, LLVM_TAGGED_PTR_WITHOUT_ADDR_SPACE), functionValuePtrType(scaffold, operand.semType));"
funcDescPtr,"llvm:PointerValue funcDescPtr = <llvm:PointerValue>builder.load(builder.getElementPtr(funcValuePtr, [constIndex(scaffold, 0), constIndex(scaffold, 0)], \"inbounds\"));"
funcPtr,"llvm:PointerValue funcPtr = <llvm:PointerValue>builder.load(builder.getElementPtr(funcValuePtr, [constIndex(scaffold, 0), constIndex(scaffold, 1)], \"inbounds\"));"
uniformFuncPtr,"llvm:PointerValue uniformFuncPtr = builder.getElementPtr(funcDescPtr, [constIndex(scaffold, 0), constIndex(scaffold, 1)], \"inbounds\");"
funcSymbol,"var { symbol: funcSymbol, erasedSignature, signature } = operand.value;"
func,"llvm:Function func = funcSymbol is bir:InternalSymbol ? scaffold.getFunctionDefn(funcSymbol.identifier): check buildFunctionDecl(scaffold, funcSymbol, erasedSignature);"
atomic,"t:FunctionAtomicType? atomic = t:functionAtomicType(scaffold.typeContext(), funcType);"
argValues,"llvm:Value[] argValues = check buildFunctionCallArgs(builder, scaffold, erasedSignature.paramTypes, signature.paramTypes, args);"
retValue,"llvm:Value? retValue = buildFunctionCall(builder, scaffold, func, argValues);"
args,"bir:Operand[] args = insn.operands.slice(1);"
requiredArgCount,"int requiredArgCount = insn.restParamIsList ? args.length() - 1 : args.length();"
uniformArgs,"llvm:Value[] uniformArgs = from int i in 0 ..< requiredArgCount select buildClearExact(builder, scaffold, (check buildRepr(builder, scaffold, args[i], REPR_ANY)), args[i].semType);"
nArgs,"llvm:Value nArgs;"
restArgs,"llvm:PointerValue? restArgs;"
restArrayPtr,"llvm:PointerValue restArrayPtr = buildUntagPointer(builder, scaffold, scaffold.address(<bir:TmpRegister>args[requiredArgCount]));"
restArgArray,"llvm:PointerValue restArgArray = builder.bitCast(restArrayPtr, heapPointerType(llListType));"
restArgCount,"llvm:Value restArgCount = builder.load(builder.getElementPtr(restArgArray, [constIndex(scaffold, 0), constIndex(scaffold, 1)], \"inbounds\"));"
uniformArgArray,"llvm:PointerValue uniformArgArray = <llvm:PointerValue>buildRuntimeFunctionCall(builder, scaffold, allocUniformArgArrayFunction, [nArgs]);"
returnVal,"llvm:Value? returnVal = buildFunctionCall(builder, scaffold, <llvm:PointerValue>builder.load(uniformFuncPtr), [funcPtr, uniformArgArray, nArgs]);"
op,"CmpEqOp op = insn.op[0] == \"!\" ? \"ne\" : \"eq\";"
exact,"boolean exact = insn.op.length() == 3;"
floatTagBlock,"llvm:BasicBlock floatTagBlock = scaffold.addBasicBlock();"
otherTagBlock,"llvm:BasicBlock otherTagBlock = scaffold.addBasicBlock();"
joinBlock,"llvm:BasicBlock joinBlock = scaffold.addBasicBlock();"
eqFunc,"RuntimeFunction eqFunc = exact ? floatExactEqFunction : floatEqFunction;"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, eqFunc, [lhsValue, rhsValue]);"
str,"string str = operand.value;"
bytes,"byte[] bytes = str.toBytes();"
intTagBlock,"llvm:BasicBlock intTagBlock = scaffold.addBasicBlock();"
func,"RuntimeFunction func = exact ? exactEqFunction : eqFunction;"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, func, [tagged1, tagged2]);"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, stringEqFunction, [tagged1, tagged2]);"
b,"llvm:Value b;"
subtypeArray,"llvm:ConstValue subtypeArray = cx.llContext().constArray(cx.llTypes.basicSubtypePtr, llSubtypes);"
initValue,"llvm:ConstValue initValue = cx.llContext().constStruct([constBitset(cx, all), constBitset(cx, someBits), subtypeArray]);"
llType,"llvm:StructType llType = llvm:structType([LLVM_BITSET, LLVM_BITSET, llvm:arrayType(cx.llTypes.basicSubtypePtr, llSubtypes.length())]);"
ptr,"llvm:ConstPointerValue ptr = cx.llMod.addGlobal(llType, symbol, initializer=initValue, isConstant=true, linkage=linkage);"
ptr,"llvm:ConstPointerValue ptr;"
existingDefn,"SubtypeDefn? existingDefn = cx.subtypeDefns[typeCode, semType];"
symbol,"string symbol = subtypeDefnSymbol(cx.subtypeDefns.length());"
init,"llvm:ConstValue? init = ();"
llStructTy,"llvm:StructType llStructTy;"
sub,"SubtypeStruct sub = createSubtypeStruct(cx, typeCode, semType);"
newDefn,"SubtypeDefn newDefn = { typeCode, semType, ptr, structType: cx.constructTypesComplete ? () : llStructTy };"
structType,"llvm:StructType? structType = defn.structType;"
sub,"SubtypeStruct sub = createSubtypeStruct(cx, defn.typeCode, defn.semType);"
atomic,"t:FunctionAtomicType? atomic = t:functionAtomicType(cx.tc, semType);"
signature,"t:FunctionSignature signature = t:functionSignature(cx.tc, atomic);"
nRequiredParams,"int nRequiredParams = requiredParamCount(signature);"
requiredParamBitSets,"t:BasicTypeBitSet[] requiredParamBitSets = from var paramTy in paramTypes.slice(0, nRequiredParams) where paramTy is t:BasicTypeBitSet select paramTy;"
paramBitSetArray,"llvm:ConstValue paramBitSetArray = cx.llContext().constArray(LLVM_BITSET, from t:BasicTypeBitSet b in requiredParamBitSets select constBitset(cx, b));"
sub,"t:BooleanSubtype sub = <t:BooleanSubtype>t:booleanSubtype(semType);"
ranges,"t:IntSubtype ranges = <t:IntSubtype>t:intSubtype(semType);"
sub,"t:FloatSubtype sub = <t:FloatSubtype>t:floatSubtype(semType);"
len,"int len = sub.values.length();"
sub,"t:DecimalSubtype sub = <t:DecimalSubtype>t:decimalSubtype(semType);"
sub,"t:StringSubtype sub = <t:StringSubtype>t:stringSubtype(semType);"
strs,"string[] strs = [];"
strConsts,"llvm:ConstValue[] strConsts = from var s in strs.sort() select getInitString(cx, s);"
lat,"t:ListAtomicType? lat = t:listAtomicType(cx.tc, semType);"
rest,"t:SemType rest = t:cellInnerVal(lat.rest);"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(cx.tc, semType);"
rest,"t:SemType rest = t:cellInnerVal(mat.rest);"
fieldTypes,"t:BasicTypeBitSet[] fieldTypes = [];"
tyInner,"t:SemType tyInner = t:cellInner(ty);"
tids,"llvm:ConstValue[] tids = from var itd in cx.constructTypeDefns[basic] where t:isSubtype(cx.tc, itd.semType, ty) select constTid(cx, itd.tid);"
llFieldType,"final llvm:StructType llFieldType = llvm:structType([LLVM_TAGGED_PTR, LLVM_BITSET]);"
nFields,"final int nFields = fieldNames.length();"
llFields,"llvm:ConstValue[] llFields = [];"
functionRefs,"FunctionRef[] functionRefs = [];"
prefix,"string prefix = listAtomicTypeToListReprPrefix(atomic);"
suffix,"string suffix = listDescFuncSuffixes[i];"
tentativeName,"string tentativeName = prefix + \"_\" + suffix;"
llType,"llvm:FunctionType llType = llListDescFuncTypes[i];"
ref,"FunctionRef ref;"
name,"string? name = tentativeName;"
existing,"llvm:FunctionDecl? existing = cx.typeTestFuncs[tk];"
decl,"llvm:FunctionDecl decl = cx.llMod.addFunctionDecl(mangleRuntimeSymbol(tk + \"_subtype_contains\"), cx.llTypes.subtypeContainsFunction);"
curDefn,"llvm:ConstPointerValue? curDefn = cx.stringDefns[str];"
newDefn,"llvm:ConstPointerValue newDefn = addStringDefn(cx.llContext(), cx.llMod, cx.stringDefns.length(), str);"
val,"llvm:ConstPointerValue val = addDecimalDefn(cx.llContext(), cx.llMod, cx.decimalCount, d);"
file,"DIFile file = mod.files[partIndex];"
low56,"var low56 = builder.iBitwise(\"and\", constInt(scaffold, (1 << TAG_SHIFT) - 1), value);"
tagged,"var tagged = builder.iBitwise(\"or\", constInt(scaffold, FLAG_IMMEDIATE | TAG_INT), low56);"
value,"t:SingleValue|bir:FunctionRef value = operand.value;"
repr,"TaggedRepr repr = { subtype: t:FUNCTION, alwaysImmediate: false };"
bytes,"byte[] bytes = value.toBytes();"
alwaysImmediate,"boolean alwaysImmediate = isSmallString(value.length(), bytes, nBytes);"
repr,"TaggedRepr repr = { subtype: t:STRING, alwaysImmediate };"
alwaysInImmediateRange,"boolean alwaysInImmediateRange = IMMEDIATE_INT_MIN <= value && value <= IMMEDIATE_INT_MAX;"
repr,"IntRepr repr = { constraints: { min: value, max: value, all: true }, alwaysInImmediateRange };"
func,"llvm:Function func;"
paramTypes,"llvm:Type[] paramTypes = from var ty in signature.paramTypes select (semTypeRepr(ty)).llvm;"
repr,"RetRepr repr = semTypeRetRepr(signature.returnType);"
ty,"llvm:FunctionType ty = { returnType: repr.llvm, paramTypes: paramTypes.cloneReadOnly() };"
masked,"llvm:Value masked = <llvm:Value>builder.call(scaffold.getIntrinsicFunction(\"ptrmask.p1.i64\"), [taggedPtr, constInt(scaffold, FLAG_EXACT)]);"
tests,"map<TestCase> tests = {};"
data,"json data = check io:fileReadJson(\"modules/comm.lib/tests/data/decimalTest.json\");"
testCases,"TestCase[] testCases = check data.fromJsonWithType();"
indices,"int[] indices = listSamples(cx, members, rest, neg);"
atom,"ListAtomicType atom = atoms[0];"
next,"ListAtomicType next = atoms[i];"
tmpAtom,"var tmpAtom = listIntersectWith(env, atom.members, atom.rest, next.members, next.rest);"
semType,"SemType semType = createBasicSemType(BT_LIST, bddAtom(env.listAtom(atom)));"
nt,"final ListAtomicType nt = cx.listAtomType(neg.atom);"
negLen,"int negLen = nt.members.fixedLength;"
len,"int len = memberTypes.length();"
t,"SemType[] t = memberTypes.slice(0, i);"
d,"SemType d = diff(memberTypes[i], listMemberAt(nt.members, nt.rest, indices[i]));"
t,"SemType[] t = memberTypes.clone();"
maxInitialLength,"int maxInitialLength = members.initial.length();"
fixedLengths,"int[] fixedLengths = [members.fixedLength];"
tem,"Conjunction? tem = neg;"
nNeg,"int nNeg = 0;"
lt,"ListAtomicType lt = cx.listAtomType(tem.atom);"
m,"FixedLengthArray m = lt.members;"
boundaries,"int[] boundaries = from int i in 1 ... maxInitialLength select i;"
indices,"int[] indices = [];"
lastBoundary,"int lastBoundary = 0;"
segmentLength,"int segmentLength = b - lastBoundary;"
nSamples,"int nSamples = int:min(segmentLength, nNeg);"
memberTypes,"CellSemType[] memberTypes = [];"
nRequired,"int nRequired = 0;"
index,"int index = indices[i];"
t,"CellSemType t = cellContainingInnerVal(cx.env, listMemberAt(members, rest, index));"
len1,"int len1 = members1.fixedLength;"
len2,"int len2 = members2.fixedLength;"
memberLen,"int memberLen = members.initial.length();"
i,"int i = int:min(index, memberLen - 1);"
m,"SemType m = NEVER;"
initLen,"int initLen = fixedArray.initial.length();"
fixedLen,"int fixedLen = fixedArray.fixedLength;"
m,"SemType m = cellInner(rest);"
applicable,"SemType[] applicable = [];"
ty,"SemType ty = memberTypes[i1];"
combined,"[Range, int?, int?][] combined = [];"
i1,"int i1 = 0;"
i2,"int i2 = 0;"
len1,"int len1 = ranges1.length();"
len2,"int len2 = ranges2.length();"
cur,"int cur = int:MIN_VALUE;"
next,"int? next = ();"
max,"int max = next == () ? int:MAX_VALUE : next - 1;"
in1,"int? in1 = ();"
r,"Range r = ranges1[i1];"
in2,"int? in2 = ();"
r,"Range r = ranges2[i2];"
combined,"[Range, int?, int?][] combined = combineRanges(range1, range2);"
i,"int i = r.max + 1;"
atomicType,"MappingAtomicType atomicType = { names: names.cloneReadOnly(), types: types.cloneReadOnly(), rest };"
atom,"Atom atom;"
rec,"RecAtom? rec = self.rec;"
bdd,"BddNode bdd = bddAtom(atom);"
s,"SemType s = basicSubtype(BT_MAPPING, bdd);"
cellFields,"CellField[] cellFields = from var { name, ty, ro, opt } in fields select [name, cellContaining(env, opt ? union(ty, UNDEF) : ty, ro ? CELL_MUT_NONE : mut)];"
restCell,"CellSemType restCell = cellContaining(env, union(rest, UNDEF), rest == NEVER ? CELL_MUT_NONE : mut);"
sortedFields,"CellField[] sortedFields = fields.sort(\"ascending\", fieldName);"
types,"CellSemType[] types = [];"
m,"var m = intersectMapping(cx.env, combined, cx.mappingAtomType(p.atom));"
neg,"MappingAtomicType neg = cx.mappingAtomType(negList.atom);"
pairing,"MappingPairing pairing = new (pos, neg);"
d,"CellSemType d = <CellSemType>diff(posType, negType);"
posTypes,"CellSemType[] posTypes = shallowCopyCellTypes(pos.types);"
types,"CellSemType[] types = shallowCopyCellTypes(m.types);"
atom,"MappingAtomicType atom = atoms[0];"
tmpAtom,"var tmpAtom = intersectMapping(env, atom, atoms[i]);"
semType,"SemType semType = createBasicSemType(BT_MAPPING, bddAtom(env.mappingAtom(atom)));"
t,"CellSemType t = intersectMemberSemTypes(env, type1, type2);"
rest,"CellSemType rest = intersectMemberSemTypes(env, m1.rest, m2.rest);"
p,"CellFieldPair p;"
memberType,"SemType? memberType = ();"
types,"SemType[] types = from CellSemType t in atomic.types select cellInner(t);"
rest,"SemType rest = cellInner(atomic.rest);"
memberTypes,"SemType[] memberTypes = [];"
coverage,"StringSubtypeListCoverage coverage = stringSubtypeListCoverage(key, atomic.names);"
pc,"SexprTypeParseContext pc = { env, atoms };"
ty,"SemType? ty = namedTypes[tySexpr];"
existingAtomTy,"SemType? existingAtomTy = pc.atoms[tySexpr];"
defn,"Definition? defn = pc.started[tySexpr];"
newAtomTy,"SemType newAtomTy = fromAtomSexpr(pc, tySexpr, pc.atomSexprs.get(tySexpr));"
result,"SemType result = NEVER;"
result,"SemType result = VAL;"
d,"ListDefinition d = new;"
initial,"SemType[] initial = from var member in initialSexpr select fromSexprInternal(pc, member);"
rest,"SemType rest = fromSexprInternal(pc, restSexpr);"
d,"MappingDefinition d = new;"
fields,"Field[] fields = from var [fieldName, fieldTy] in fieldsSexpr select { name: fieldName.s, ty: fromSexprInternal(pc, fieldTy) };"
d,"FunctionDefinition d = new;"
paramTypes,"SemType[] paramTypes = from var param in params select fromSexprInternal(pc, param);"
returnType,"SemType returnType = fromSexprInternal(pc, ret);"
restParamType,"SemType restParamType = rest != () ? fromSexprInternal(pc, rest) : NEVER;"
env,"Env env = pc.env;"
some,"int some = t.some;"
subtypeList,"BasicSubtype[] subtypeList = [];"
code,"var code = <BasicTypeCode>lib:numberOfTrailingZeros(some);"
loBits,"int loBits = t.some & (c - 1);"
all1,"BasicTypeBitSet all1;"
all2,"BasicTypeBitSet all2;"
some1,"BasicTypeBitSet some1;"
some2,"BasicTypeBitSet some2;"
all,"BasicTypeBitSet all = all1 | all2;"
some,"BasicTypeBitSet some = (some1 | some2) & ~<int>all;"
subtypes,"BasicSubtype[] subtypes = [];"
all,"BasicTypeBitSet all = all1 & all2;"
some,"BasicTypeBitSet some = (some1 | all1) & (some2 | all2);"
all,"BasicTypeBitSet all = all1 & ~<int>(all2 | some2);"
some,"BasicTypeBitSet some = (all1 | some1) & ~<int>all2;"
d2Complement,"SubtypeData d2Complement = complement(d2);"
subtypes,"BddNode[] subtypes = toBddSubtypes(cx, t);"
listSubtype,"boolean listSubtype = isSubtypeSimple(t, LIST);"
cyclic,"boolean cyclic = listSubtype ? listBddIsCyclic(cx, subtype) : mappingBddIsCyclic(cx, subtype);"
bits,"int bits;"
semType,"SemType semType = diff(union(t1, t2), NIL);"
nOrderings,"int nOrderings = lib:bitCount(widenToBasicTypes(semType));"
memoized,"ComparableMemo? memoized = cx.comparableMemo[t1, t2];"
memo,"ComparableMemo memo = { semType1: t1, semType2: t2 };"
members,"readonly & CellSemType[] members = atomic.members.initial;"
i,"int i = members.length();"
existing,"FillerMemo? existing = cx.fillerMemo[semType];"
memo,"FillerMemo memo = { semType, filler: () };"
f,"Filler? f = computeFiller(cx, semType);"
bitSet,"BasicTypeBitSet bitSet = widenToBasicTypes(t);"
value,"SingleValue value = ();"
wrapped,"WrappedSingleValue? wrapped = singleShape(t);"
mat,"MappingAtomicType? mat = mappingAtomicType(cx, t);"
lat,"ListAtomicType? lat = listAtomicType(cx, t);"
memberFillers,"Filler[] memberFillers = [];"
f,"Filler? f = filler(cx, cellInner(memberType));"
data,"SubtypeData data = intSubtypeWidenUnsigned(subtypeData(t, BT_INT));"
intSubtype,"var intSubtype = intSubtype(t);"
len,"int len = intSubtype.length();"
memberType,"SemType memberType = cellInnerVal(atomic.rest);"
ranges,"Range[] ranges = [];"
allRanges,"Range[] allRanges = bddListAllRanges(cx, <Bdd>getComplexSubtypeData(t, BT_LIST), []);"
m,"SemType m = listMemberTypeInnerVal(cx, t, intConst(r.min));"
listAtomicInner,"ListAtomicType listAtomicInner = LIST_ATOMIC_INNER;"
env,"Env env = cx.env;"
keyData,"IntSubtype|boolean keyData = intSubtype(k);"
indexIntType,"IntSubtype|boolean indexIntType;"
paths,"BddPath[] paths = [];"
alts,"ListAlternative[] alts = [];"
intersection,"var intersection = intersectListAtoms(cx.env, from var atom in pos select cx.listAtomType(atom));"
mappingAtomicInner,"MappingAtomicType mappingAtomicInner = MAPPING_ATOMIC_INNER;"
keyData,"StringSubtype|boolean keyData = stringSubtype(k);"
keyStringType,"StringSubtype|boolean keyStringType;"
alts,"MappingAlternative[] alts = [];"
intersection,"var intersection = intersectMappingAtoms(cx.env, from var atom in pos select cx.mappingAtomType(atom));"
cat,"CellAtomicType cat = <CellAtomicType>cellAtomicType(t);"
s,"BasicSubtype? s = singleBasicSubtype(t);"
value,"SingleValue value;"
semType,"ComplexSemType semType;"
numType,"SemType numType = intersect(semType, NUMBER);"
memo,"SemType? memo = context.jsonMemo;"
env,"Env env = context.env;"
j,"SemType j = union(SIMPLE_OR_STRING, union(listDef.getSemType(env), mapDef.getSemType(env)));"
memo,"SemType? memo = context.anydataMemo;"
tableTy,"SemType tableTy = tableContaining(env, mapDef.getSemType(env));"
ad,"SemType ad = union(union(SIMPLE_OR_STRING, union(XML, tableTy)), union(listDef.getSemType(env), mapDef.getSemType(env)));"
members,"SemType[] members = toMemberSemtypes(cx, ty);"
subtypes,"BddNode[] subtypes = toBddSubtypes(cx, ty);"
members,"SemType[] members = [];"
listSubtype,"boolean listSubtype = isSubtypeSimple(ty, LIST);"
atomicTy,"ListAtomicType atomicTy = cx.listAtomType(subtype.atom);"
atomicTy,"MappingAtomicType atomicTy = cx.mappingAtomType(subtype.atom);"
mappingSubtype,"boolean mappingSubtype = isSubtypeSimple(ty, MAPPING);"
result,"ts:Type[] result = [];"
allChars,"boolean allChars = char.values.length() == 0;"
posPrimitiveFlag,"int posPrimitiveFlag = xmlTy.primitives & ~extraAll;"
negPrimitiveFlag,"int negPrimitiveFlag = ~xmlTy.primitives & extraAll;"
pos,"ts:Type pos = joinTypeSexpr(\"|\", [...sequence, ...xmlPrimitivesToSexpr(posPrimitiveFlag)]);"
negPrimitives,"ts:Not negPrimitives = [\"!\", ...xmlPrimitivesToSexpr(negPrimitiveFlag)];"
disj,"ts:Type[] disj = [];"
extra,"int extra = 0;"
onlyNeg,"boolean onlyNeg = true;"
extraInPath,"int? extraInPath = ();"
conj,"ts:Type[] conj = [];"
extraInPos,"int extraInPos = <int>p | XML_PRIMITIVE_NEVER;"
extraInNeg,"int extraInNeg = ~<int>n & (XML_PRIMITIVE_ALL_MASK & ~XML_PRIMITIVE_NEVER);"
conjTy,"ts:Type conjTy = joinTypeSexpr(\"&\", conj);"
xmlPrimitives,"ts:Type[] xmlPrimitives = [];"
nonNeverPrimitives,"int nonNeverPrimitives = flag & ~XML_PRIMITIVE_NEVER;"
rwAndRo,"int rwAndRo = ((flags & 0xe0) >> 3) & flags;"
mask,"int mask = (rwAndRo << 3) | rwAndRo;"
f,"int f = (rwAndRo << 6) | flags & ~mask;"
names,"ts:XmlBuiltinSubtypeNames[] names = [\"text\", \"element_ro\", \"pi_ro\", \"comment_ro\", \"element_rw\", \"pi_rw\", \"comment_rw\", \"element\", \"pi\", \"comment\"];"
result,"ts:XmlBuiltinSubtypeNames[] result = [];"
lat,"ListAtomicType lat = sc.tc.listAtomType(atom);"
rest,"Bdd rest = mappingSubtype(cellInnerVal(lat.rest));"
id,"AtomId id = (atom is RecAtom) ? [top, REC_ATOM, atom] : [top, TYPE_ATOM, atom.index];"
existing,"Memo? existing = memos[id];"
name,"string name = id[0][0].toUpperAscii() + (id[1] ? \"R\" : \"T\") + \".\" + id[2].toString();"
memo,"Memo memo = { id, name };"
sexpr,"ts:Atom sexpr;"
tc,"Context tc = sc.tc;"
params,"ts:Type[] params = from var param in paramTypes select sexprFormSemTypeInternal(sc, param);"
returnTy,"ts:Type returnTy = sexprFormSemTypeInternal(sc, returnType);"
rest,"ts:Type rest = sexprFormSemTypeInternal(sc, restParamType);"
members,"ts:Type[] members = from var member in lat.members.initial select sexprFormSemTypeInternal(sc, cellInner(member));"
restSemType,"SemType restSemType = cellInnerVal(lat.rest);"
rest,"ts:Type? rest = restSemType != NEVER ? sexprFormSemTypeInternal(sc, restSemType) : ();"
compressed,"boolean? compressed = lat.members.fixedLength == 0 ? () : lat.members.initial.length() != lat.members.fixedLength;"
mat,"MappingAtomicType mat = sc.tc.mappingAtomType(atom);"
fields,"ts:Field[] fields = [];"
restSemType,"SemType restSemType = cellInnerVal(mat.rest);"
rest,"ts:Type rest = sexprFormSemTypeInternal(sc, restSemType);"
listAtom,"ListAtomicType listAtom = <ListAtomicType>listAtomicType(cx, argList);"
paramTypes,"SemType[] paramTypes = from int i in 0 ..< listAtom.members.fixedLength select listAtomicTypeMemberAtInnerVal(listAtom, i);"
restInnerVal,"SemType restInnerVal = cellInnerVal(listAtom.rest);"
restParamType,"SemType? restParamType = restInnerVal == NEVER ? () : restInnerVal;"
listDefn,"ListDefinition listDefn = new;"
signature,"FunctionSignature signature = { returnType, paramTypes: paramTypes.cloneReadOnly(), restParamType };"
atomArgListTy,"SemType atomArgListTy = cx.env.functionAtomType(b.atom)[0];"
domain,"SemType? domain = functionParamListType(cx, func);"
memo,"FunctionTypeMemo? memo = cx.functionAtomicTypeMemo[signature];"
defn,"FunctionDefinition defn = new;"
requiredParams,"SemType[] requiredParams;"
rest,"SemType rest = restParamType is () ? NEVER : restParamType;"
semType,"SemType semType = defn.define(env, defineListTypeWrapped(new(), env, requiredParams, rest=rest, mut=CELL_MUT_NONE), returnType);"
keyIndices,"int[] keyIndices;"
p,"SemType p = NEVER;"
t,"CellSemType[] t = memberTypes.slice(0, i);"
d,"SemType d = diff(cellInnerVal(memberTypes[i]), listMemberAtInnerVal(nt.members, nt.rest, indices[i]));"
t,"CellSemType[] t = memberTypes.clone();"
v,"[int, boolean][] v = from int i in indices select [i, intSubtypeContains(k, i)];"
max,"int max = range.max;"
min,"int min = int:max(0, range.min);"
indices1,"int[] indices1 = [];"
keyIndices,"int[] keyIndices = [];"
tc,"Context tc = typeContext(env);"
st1,"SemType st1 = fromSexpr(env, atoms, t1);"
st2,"SemType st2 = fromSexpr(env, atoms, t2);"
actual,"var actual = relationFromResult(isSubtype(tc, st1, st2), isSubtype(tc, st2, st1));"
expected,"string expected = relation.substring(6);"
s1,"string s1 = t1.toString();"
s2,"string s2 = t2.toString();"
endIndex,"int endIndex = lhsWrapped ? (lhs.endIndex + 2) : (lhs.endIndex + 1);"
op,"string op = regex[endIndex];"
nextIndex,"int nextIndex = skipTillEnd(regex, endIndex + 1);"
nextIndex,"int nextIndex = rhsWrapped ? (rhs.endIndex + 2) : (rhs.endIndex + 1);"
endIndex,"int endIndex = index;"
endIndex,"int endIndex = index + 1;"
openCount,"int openCount = 1;"
nextIndex,"int nextIndex = currentIndex;"
value,"string? value = ty.value;"
resolvedConst,"s:ResolvedConst resolvedConst = check resolveConstExpr(mod, defn, expr, expectedType);"
cx,"ExprContext cx = new ExprContext(mod, defn, constCode, (), ());"
operand,"bir:SingleValueConstOperand operand = <bir:SingleValueConstOperand>result;"
semType,"t:SemType semType = operand.semType;"
miTable,"table<ModuleIdImports> key(id) miTable = table [];"
id,"bir:ModuleId id = { org: decl.org ?: modId.org, names: decl.names };"
syms,"ModuleSymbols syms = { tc: t:typeContext(env) };"
files,"s:SourceFile[] files = from var p in scanned.parts select p.sourceFile();"
part,"s:ModulePart part = check s:parseModulePart(scannedPart);"
syms,"ModuleSymbols syms = { tc, allowAllTypes: true };"
parts,"s:ScannedModulePart[] parts = [];"
file,"s:SourceFile file = check loadSourcePart(sourceParts[i], i);"
directory,"string? directory = part?.directory;"
filename,"string? filename = part?.filename;"
lines,"string[]? lines = part?.lines;"
importsById,"ModuleIdImports[] importsById = scanned.importsById;"
moduleId,"var moduleId = importsById[i].id;"
resolved,"ModuleExports|string? resolved;"
partial,"boolean partial;"
msg,"d:Message msg = `unsupported module ${moduleIdToString(moduleId)}`;"
declPrefix,"string? declPrefix = decl.prefix;"
prefix,"string prefix = declPrefix == () ? moduleIdDefaultPrefix(moduleId) : declPrefix;"
defn,"s:ModuleLevelDefn? defn = mod[\"main\"];"
defn,"s:ModuleLevelDefn? defn = defns[\"init\"];"
returnType,"t:SemType returnType = (<t:FunctionSignature>defn.signature).returnType;"
env,"t:Env env = new;"
syms,"ModuleSymbols syms = { tc: t:typeContext(env), allowAllTypes: true };"
loaded,"var loaded = check loadSourcePart(sourceParts[i], 0);"
part,"s:ScannedModulePart part = check s:scanModulePart(loaded, i);"
branch,"bir:BranchInsn branch = {dest, pos: stmt.startPos, backward};"
ec,"ExprContext ec = cx.exprContext(initialBindings);"
startRegister,"final int startRegister = cx.nextRegisterNumber();"
matched,"var { result: matched, block: testBlock, binding } = check codeGenExpr(ec, startBlock, (), stmt.expr);"
testBlock,"var { result: matched, block: testBlock, binding } = check codeGenExpr(ec, startBlock, (), stmt.expr);"
tc,"t:Context tc = cx.mod.tc;"
matchedType,"t:SemType matchedType = operandSemType(tc, matched);"
defaultClauseIndex,"int? defaultClauseIndex = ();"
hadWildcardPattern,"boolean hadWildcardPattern = false;"
equalMatchTests,"table<EqualMatchTest> key(value) equalMatchTests = table [];"
matchTests,"MatchTest[] matchTests = [];"
clauseLooksLike,"t:SemType[] clauseLooksLike = [];"
clauseUnmatchedLooksLike,"t:SemType[] clauseUnmatchedLooksLike = [];"
clausePatternUnions,"t:SemType[] clausePatternUnions = [];"
precedingPatternsUnion,"t:SemType precedingPatternsUnion = t:NEVER;"
clauseBlocks,"bir:BasicBlock[] clauseBlocks = [];"
clause,"var clause = stmt.clauses[i];"
clausePatternUnion,"t:SemType clausePatternUnion = t:NEVER;"
patternType,"t:SemType patternType;"
value,"t:SingleValue value = check resolveConstMatchPattern(cx, initialBindings, pattern, matchedType);"
operand,"bir:SingleValueConstOperand operand = { value, semType: patternType };"
mt,"EqualMatchTest mt = { value, operand, clauseIndex: i, pos: clause.opPos };"
mt,"BasicTypeMatchTest mt = { bitSet: t:ANY, clauseIndex: i, pos: clause.opPos };"
clauseBindings,"BindingChain?[] clauseBindings = [];"
unmatchedReg,"bir:Register unmatchedReg = <bir:Register>matched;"
pos,"var pos = stmt.clauses[i].opPos;"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(clauseLooksLike[i], binding.reg, pos);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(clauseUnmatchedLooksLike[i], binding.reg, pos);"
nextBlock,"bir:BasicBlock nextBlock;"
branch,"bir:TypeCondBranchInsn branch = { ifTrue: clauseBlocks[i].label, ifFalse: nextBlock.label, ifTrueRegister, ifFalseRegister, operand: unmatchedReg, semType: clausePatternUnions[i], pos: pos };"
patternIndex,"int patternIndex = 0;"
clauseIndex,"int clauseIndex = mt.clauseIndex;"
testResult,"bir:TmpRegister testResult = cx.createTmpRegister(t:BOOLEAN, mt.pos);"
eq,"bir:EqualityInsn eq = { op: \"==\", pos: mt.pos, result: testResult, operands: [matched, mt.operand] };"
tt,"bir:TypeTestInsn tt = { pos: mt.pos, result: testResult, operand: <bir:Register>matched, semType: mt.bitSet, negated: false };"
nextBlock,"bir:BasicBlock nextBlock = cx.createBasicBlock(\"pattern.\" + patternIndex.toString());"
condBranch,"bir:CondBranchInsn condBranch = { operand: testResult, ifTrue: clauseBlocks[clauseIndex].label, ifFalse: nextBlock.label, pos: mt.pos } ;"
contBlock,"bir:BasicBlock? contBlock = ();"
bindings,"BindingChain? bindings = ();"
clause,"s:MatchClause clause = stmt.clauses[clauseIndex];"
stmtBlock,"bir:BasicBlock stmtBlock = clauseBlocks[clauseIndex];"
stmtBlockEnd,"var { block: stmtBlockEnd, bindings: blockBindings } = check codeGenScope(cx, stmtBlock, clauseBindings[clauseIndex] ?: initialBindings, clause.block);"
blockBindings,"var { block: stmtBlockEnd, bindings: blockBindings } = check codeGenScope(cx, stmtBlock, clauseBindings[clauseIndex] ?: initialBindings, clause.block);"
b,"bir:BasicBlock b = maybeCreateBasicBlock(ec, contBlock);"
branchToCont,"bir:BranchInsn branchToCont = { dest: b.label, pos: clause.startPos };"
branch,"bir:BranchInsn branch = { dest: clauseBlocks[defaultClauseIndex].label, pos: stmt.clauses[defaultClauseIndex].startPos };"
endPos,"Position endPos = stmt.clauses.length() > 0 ? (stmt.clauses[stmt.clauses.length() - 1].block.closeBracePos) : stmt.startPos;"
branch,"bir:BranchInsn branch = { dest: b.label, pos: endPos };"
condEffect,"CondExprEffect condEffect = check codeGenExprForCond(ec, startBlock, condition);"
errStmt,"s:Stmt? errStmt = scopeFirstStmt(notTaken);"
ifContBlock,"var { block: ifContBlock, bindings: ifBindings } = check codeGenScopeWithTypeMerger(cx, trueMerger, initialBindings, ifTrue);"
ifBindings,"var { block: ifContBlock, bindings: ifBindings } = check codeGenScopeWithTypeMerger(cx, trueMerger, initialBindings, ifTrue);"
contMerger,"TypeMerger contMerger = falseMerger;"
branch,"bir:BranchInsn branch = { dest: falseMerger.dest.label, pos: stmt.condition.startPos };"
elseContBlock,"var { block: elseContBlock, bindings: elseBindings } = check codeGenScopeWithTypeMerger(cx, falseMerger, initialBindings, ifFalse);"
elseBindings,"var { block: elseContBlock, bindings: elseBindings } = check codeGenScopeWithTypeMerger(cx, falseMerger, initialBindings, ifFalse);"
contBlock,"bir:BasicBlock contBlock = cx.createBasicBlock();"
joinPos,"Position joinPos = (ifFalse is s:StmtBlock ? ifFalse : ifFalse.ifTrue).closeBracePos;"
branch,"bir:BranchInsn branch = { dest: contBlock.label, pos: joinPos };"
combinedOrigin,"TypeMergerOrigin? combinedOrigin = { bindings: ifBindings, label: ifContBlock.label, prev: { bindings: elseBindings, label: elseContBlock.label, prev: () } };"
bindings,"BindingChain? bindings = codeGenTypeMerge(ec, contBlock, initialBindings, combinedOrigin, ifTrue.endPos);"
contBlock,"bir:BasicBlock? contBlock = ifContBlock ?: elseContBlock;"
bindings,"BindingChain? bindings = ifBindings ?: elseBindings;"
operand,"bir:Operand operand;"
insn,"bir:RetInsn insn = { operand, pos: stmt.kwPos };"
operand,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, t:ERROR, panicExpr);"
nextBlock,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, t:ERROR, panicExpr);"
insn,"bir:PanicInsn insn = { operand, pos: stmt.kwPos };"
semType,"t:SemType semType = check cx.resolveTypeDesc(td);"
result,"bir:VarRegister|bir:FinalRegister result = isFinal ? cx.createFinalRegister(semType, namePos, name) : cx.createVarRegister(semType, namePos, name);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, result, initExpr, semType, stmt.opPos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, cx.createVarRegister(semType, pos, \"_\"), expr, semType, pos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, cx.createVarRegister(t:ANY, stmt.opPos, \"_\"), expr, t:ANY, stmt.opPos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, unnarrowedReg, expr, unnarrowedReg.semType, pos);"
binding,"Binding binding = check lookupVarRefBinding(cx, varName, initialBindings, pos);"
unnarrowed,"DeclBinding unnarrowed = unnarrowBinding(binding);"
unnarrowedReg,"bir:VarRegister unnarrowedReg = <bir:VarRegister>unnarrowed.reg;"
bindings,"BindingChain? bindings;"
operand,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(block, initialBindings, semType, expr);"
nextBlock,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(block, initialBindings, semType, expr);"
insn,"bir:AssignInsn insn = { pos, result, operand };"
reg,"bir:Register reg;"
block,"bir:BasicBlock block;"
containerOperand,"bir:Operand containerOperand;"
result,"bir:Operand result;"
reg,"var { result: reg, block: block1 } = check codeGenLExpr(cx, startBlock, initialBindings, lValue.container);"
block1,"var { result: reg, block: block1 } = check codeGenLExpr(cx, startBlock, initialBindings, lValue.container);"
indexType,"t:BasicTypeBitSet indexType;"
index,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(block1, initialBindings, lValue.index);"
nextBlock,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(block1, initialBindings, lValue.index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, reg.semType, index.semType);"
insn,"bir:ListSetInsn insn = { operands: [reg, index, operand], pos: lValue.opPos };"
index,"var { result: index, block: nextBlock } = check codeGenLExprMappingKey(cx, block1, initialBindings, lValue, reg.semType);"
nextBlock,"var { result: index, block: nextBlock } = check codeGenLExprMappingKey(cx, block1, initialBindings, lValue, reg.semType);"
memberType,"t:SemType memberType = t:mappingMemberTypeInnerVal(cx.mod.tc, reg.semType, index.semType);"
insn,"bir:MappingSetInsn insn = { operands: [ reg, index, operand], pos: lValue.opPos };"
fieldName,"string fieldName = mappingLValue.fieldName;"
pos,"var { lValue, expr, op, opPos: pos } = stmt;"
container,"var { result: container, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, (), lValue.container);"
nextBlock,"var { result: container, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, (), lValue.container);"
nextBlock,"var { block: nextBlock, result: operand } = check codeGenCompoundableBinaryExpr(cx.exprContext(initialBindings), startBlock, op, pos, result, rexpr);"
operand,"var { block: nextBlock, result: operand } = check codeGenCompoundableBinaryExpr(cx.exprContext(initialBindings), startBlock, op, pos, result, rexpr);"
index,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(bb, initialBindings, lValue.index);"
nextBlock,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(bb, initialBindings, lValue.index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, list.semType, index.semType);"
member,"bir:TmpRegister member = cx.createTmpRegister(memberType, lValue.opPos);"
getInsn,"bir:ListGetInsn getInsn = { result: member, operands: [list, index], pos: lValue.opPos };"
setInsn,"bir:ListSetInsn setInsn = { operands: [list, index, result], pos: lValue.opPos };"
k,"var { result: k, block: block1 } = check codeGenLExprMappingKey(cx, bb, initialBindings, lValue, mapping.semType);"
block1,"var { result: k, block: block1 } = check codeGenLExprMappingKey(cx, bb, initialBindings, lValue, mapping.semType);"
member,"var { result: member, block: block2 } = check codeGenMappingGet(ec, block1, mapping, \"[\", k, pos);"
block2,"var { result: member, block: block2 } = check codeGenMappingGet(ec, block1, mapping, \"[\", k, pos);"
setInsn,"bir:MappingSetInsn setInsn = { operands: [ mapping, k, result], pos: lValue.opPos };"
operand,"var { result: operand, block: nextBlock } = check codeGenExpr(ec, bb, member.semType, rexpr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExpr(ec, bb, member.semType, rexpr);"
operand,"var { result: operand, block: nextBlock } = check codeGenExprForInt(ec, bb, rexpr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExprForInt(ec, bb, rexpr);"
expr,"s:CallExpr expr = stmt.callExpr;"
o,"var { result: o, block: nextBlock, binding } = check cx.codeGenExpr(bb, initialBindings, t:ERROR, expr);"
nextBlock,"var { result: o, block: nextBlock, binding } = check cx.codeGenExpr(bb, initialBindings, t:ERROR, expr);"
semType,"t:SemType semType = operandSemType(cx.mod.tc, o);"
errorType,"t:SemType errorType = t:intersect(semType, t:ERROR);"
resultType,"t:SemType resultType;"
operand,"bir:Register operand = <bir:Register>o;"
errorBlock,"bir:BasicBlock errorBlock = cx.createBasicBlock();"
okBlock,"bir:BasicBlock okBlock = cx.createBasicBlock();"
reg,"bir:Register reg = <bir:Register>operand;"
errorReg,"bir:NarrowRegister errorReg = cx.createNarrowRegister(errorType, reg);"
result,"bir:NarrowRegister result = cx.createNarrowRegister(okType, reg);"
insn,"bir:TypeCondBranchInsn insn = { operand: operand, semType: t:ERROR, ifTrue: errorBlock.label, ifFalse: okBlock.label, pos, ifTrueRegister: errorReg, ifFalseRegister: result };"
b,"var b = check lookupLocalVarRef(cx, cx.mod, name, bindings, pos);"
binding,"Binding? binding = envLookup(name, bindings);"
defn,"s:ModuleLevelDefn? defn = mod.defns[name];"
signature,"var signature = defn.signature;"
isPublic,"boolean isPublic = defn.vis == \"public\";"
symbol,"bir:InternalSymbol symbol = { identifier: name, isPublic };"
binding,"Binding? binding = bindingsLookup(name, bindings);"
tem,"BindingChain? tem = bindings;"
result,"bir:AssignTmpRegister result = cx.createAssignTmpRegister(t:BOOLEAN, pos);"
assignInsn,"bir:AssignInsn assignInsn = { operand: singletonOperand(cx, value), pos, result };"
brInsn,"bir:BranchInsn brInsn = { dest: contBlock, pos };"
operand,"bir:BooleanOperand operand;"
nextBlock,"var { result , block: nextBlock, binding } = check codeGenExpr(cx, bb, (), left);"
l,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
block1,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
lBinding,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
r,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
nextBlock,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
rBinding,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
exact,"boolean exact = op.length() == 3;"
narrowingCompare,"[Binding, t:SingleValue]? narrowingCompare = ();"
lShape,"t:WrappedSingleValue? lShape = operandSingleShape(l);"
rShape,"t:WrappedSingleValue? rShape = operandSingleShape(r);"
negated,"boolean negated = op.startsWith(\"!\");"
ty,"t:SemType ty = t:singleton(tc, value);"
result,"CondExprEffect result = check codeGenTypeTestForCond(cx, nextBlock, ty, binding, negated, pos, prevs);"
taken,"TypeMerger? taken = negated ? result.falseMerger : result.trueMerger;"
result,"bir:Register result;"
reg,"bir:TmpRegister reg = cx.createTmpRegister(t:BOOLEAN);"
insn,"bir:EqualityInsn insn;"
trueMerger,"TypeMerger trueMerger = createMerger(cx, block.label, prevs?.trueMerger);"
falseMerger,"TypeMerger falseMerger = createMerger(cx, block.label, prevs?.falseMerger);"
condBranch,"bir:CondBranchInsn condBranch = { operand: result, ifTrue: trueMerger.dest.label, ifFalse: falseMerger.dest.label, pos: expr.startPos };"
block,"bir:BasicBlock block = cx.createBasicBlock();"
nonNilResult,"bir:Operand nonNilResult = nonNilEffect.result;"
nonNilBlock,"bir:BasicBlock nonNilBlock = nonNilEffect.block;"
result,"bir:AssignTmpRegister result = cx.createAssignTmpRegister(t:union(operandSemType(cx.mod.tc, nonNilResult), t:NIL), pos);"
nilAssign,"bir:AssignInsn nilAssign = { result, operand: bir:NIL_OPERAND, pos };"
branchInsn,"bir:BranchInsn branchInsn = { dest: block.label, pos };"
valAssign,"bir:AssignInsn valAssign = { result, operand: nonNilResult, pos };"
ifNilBlock,"bir:BasicBlock? ifNilBlock = ();"
currentBlock,"bir:BasicBlock currentBlock = bb;"
newOperands,"bir:Operand[] newOperands = [];"
operand,"var { result: operand, block } = check codeGenExpr(cx, currentBlock, expected, operandExpr);"
nextBlock,"bir:BasicBlock nextBlock = currentBlock;"
operand,"bir:Operand operand = newOperands[i];"
baseType,"t:SemType baseType = t:diff(operand.semType, t:NIL);"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(t:NIL, operand);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(baseType, operand);"
ifTrueBlock,"bir:BasicBlock ifTrueBlock = maybeCreateBasicBlock(cx, ifNilBlock);"
branchInsn,"bir:TypeCondBranchInsn branchInsn = { operand, semType: t:NIL, ifTrue: ifTrueBlock.label, ifFalse: nextBlock.label, ifTrueRegister, ifFalseRegister, pos };"
memberType,"t:SemType memberType = t:mappingMemberTypeInner(cx.mod.tc, mapping.semType, k.semType);"
maybeMissing,"boolean maybeMissing = true;"
fieldName,"string fieldName = (<bir:StringConstOperand>k).value;"
name,"bir:INSN_MAPPING_FILLING_GET|bir:INSN_MAPPING_GET name = bir:INSN_MAPPING_GET;"
result,"bir:TmpRegister result = cx.createTmpRegister(memberType, pos);"
insn,"bir:Insn insn = { name, result, operands: [mapping, k], pos };"
r,"var { result: r, block: nextBlock } = check codeGenExprForInt(cx, block1, index);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExprForInt(cx, block1, index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, l.semType, r.semType);"
insn,"bir:ListGetInsn insn = { result, operands: [l, r], pos, fill };"
r,"var { result: r, block: nextBlock } = check codeGenExprForString(cx, block1, index);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExprForString(cx, block1, index);"
resultType,"t:SemType resultType = (flags & VALUE_SINGLE_SHAPE) != 0 ? t:singleton(cx.mod.tc, value) : t:INT;"
result,"bir:TmpRegister result = cx.createTmpRegister(t:INT, pos);"
insn,"bir:IntBitwiseBinaryInsn insn = { op: \"^\", pos, operands: [singletonIntOperand(cx.mod.tc, -1), operand], result };"
arith,"ArithmeticOperand? arith = arithmeticOperand(operand);"
result,"bir:TmpRegister result;"
insn,"bir:Insn insn;"
intOperand,"bir:IntOperand intOperand = arith[1];"
floatOperand,"bir:FloatOperand floatOperand = arith[1];"
resultType,"t:SemType resultType = t:FLOAT;"
decimalOperand,"bir:DecimalOperand decimalOperand = arith[1];"
resultType,"t:SemType resultType = t:DECIMAL;"
pair,"ArithmeticOperandPair? pair = arithmeticOperandPair(lhs, rhs);"
operands,"readonly & bir:IntOperand[2] operands = pair[1];"
resultFlags,"ValueFlags resultFlags = leftFlags & rightFlags;"
value,"int value = check intArithmeticEval(cx, pos, op, leftVal, rightVal);"
resultType,"t:SemType resultType = (resultFlags & VALUE_SINGLE_SHAPE) != 0 ? t:singleton(cx.mod.tc, value) : t:INT;"
operands,"readonly & bir:FloatOperand[2] operands = pair[1];"
value,"float value = floatArithmeticEval(op, leftVal, rightVal);"
insn,"bir:FloatArithmeticBinaryInsn insn = { op, pos, operands, result };"
operands,"readonly & bir:DecimalOperand[2] operands = pair[1];"
value,"decimal value = check decimalArithmeticEval(cx, pos, op, leftVal, rightVal);"
insn,"bir:DecimalArithmeticBinaryInsn insn = { op, pos, operands, result };"
operands,"readonly & bir:StringOperand[2] operands = pair[1];"
insn,"bir:StringConcatInsn insn = { operands: pair[1], result, pos };"
operandConstraints,"t:IntSubtypeConstraints?[] operandConstraints = from bir:Operand operand in operands select t:intSubtypeConstraints(operand.semType);"
constraints,"t:IntSubtypeConstraints[] constraints = [];"
noPanicMin,"int noPanicMin;"
noPanicMax,"int noPanicMax;"
operand,"var { result: operand, block: nextBlock } = check codeGenExprForBoolean(cx, bb, expr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExprForBoolean(cx, bb, expr);"
result,"bir:TmpRegister result = cx.createTmpRegister(t:BOOLEAN, pos);"
insn,"bir:BooleanNotInsn insn = { operand: <bir:Register>operand, result, pos };"
flipped,"PrevTypeMergers? flipped = prevs == () ? () : { trueMerger: prevs.falseMerger, falseMerger: prevs.trueMerger };"
isOr,"boolean isOr = op == \"||\";"
lhsEffect,"var lhsEffect = check codeGenExprForCond(cx, bb, left, prevs);"
lhsTrueMerger,"var { trueMerger: lhsTrueMerger, falseMerger: lhsFalseMerger } = lhsEffect;"
lhsFalseMerger,"var { trueMerger: lhsTrueMerger, falseMerger: lhsFalseMerger } = lhsEffect;"
dummyBlock,"bir:BasicBlock dummyBlock = cx.createDummyBasicBlock(merger.dest);"
rhsBlock,"var { block: rhsBlock, bindings: rhsBindings } = codeGenTypeMergeFromMerger(cx, rhsMerger, pos);"
rhsBindings,"var { block: rhsBlock, bindings: rhsBindings } = codeGenTypeMergeFromMerger(cx, rhsMerger, pos);"
leftWidenedType,"t:SemType leftWidenedType = t:widenUnsigned(lhs.semType);"
rightWidenedType,"t:SemType rightWidenedType = t:widenUnsigned(rhs.semType);"
value,"int value = bitwiseEval(op, leftValue, rightValue);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, pos);"
insn,"bir:IntBitwiseBinaryInsn insn = { op, pos, operands: [lhs, rhs], result };"
nextBlock,"bir:BasicBlock nextBlock = bb;"
atomicType,"t:ListAtomicType atomicType;"
requiredType,"t:SemType requiredType = t:listAtomicTypeMemberAtInnerVal(atomicType, i);"
memberSemTypes,"t:SemType[] memberSemTypes = [];"
broadType,"t:SemType broadType = t:singleShape(operand.semType) == () ? operand.semType : t:widenToBasicTypes(operand.semType);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, expr.opPos);"
insn,"bir:ListConstructInsn insn = { operands: operands.cloneReadOnly(), result, pos: expr.opPos };"
insn,"bir:ListConstructInsn|bir:MappingConstructInsn insn;"
result,"bir:TmpRegister result = cx.createTmpRegister(filler.semType);"
memberFiller,"t:Filler? memberFiller = t:filler(cx.mod.tc, t:listAtomicTypeMemberAtInner(atomicType, index));"
expectedListType,"t:SemType expectedListType = t:intersect(expectedType, t:LIST);"
lat,"t:ListAtomicType? lat = t:listAtomicType(tc, expectedListType);"
len,"int len = expr.members.length();"
alts,"t:ListAlternative[] alts = from var alt in t:listAlternatives(tc, expectedListType) where listAlternativeAllowsLength(alt, len) select alt;"
semType,"t:SemType semType = alts[0].semType;"
pos,"t:ListAtomicType? pos = alt.pos;"
minLength,"int minLength = pos.members.fixedLength;"
fieldPos,"map<Position> fieldPos = {};"
mat,"t:MappingAtomicType mat;"
name,"string name = f.name;"
prevPos,"Position? prevPos = fieldPos[name];"
insn,"bir:MappingConstructInsn insn = { fieldNames: fieldNames.cloneReadOnly(), operands: operands.cloneReadOnly(), result, pos: expr.opPos };"
expectedMappingType,"t:SemType expectedMappingType = t:intersect(expectedType, t:MAPPING);"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(tc, expectedMappingType);"
fieldNames,"string[] fieldNames = from var f in expr.fields order by f.name select f.name;"
alts,"t:MappingAlternative[] alts = from var alt in t:mappingAlternatives(tc, expectedMappingType) where mappingAlternativeAllowsFields(alt, fieldNames) select alt;"
pos,"t:MappingAtomicType? pos = alt.pos;"
len,"int len = fieldNames.length();"
operand,"var { result: operand, block } = check codeGenExprForString(cx, bb, message);"
result,"bir:TmpRegister result = cx.createTmpRegister(t:ERROR, pos);"
insn,"bir:ErrorConstructInsn insn = { result, operand, pos };"
l,"var { result: l, block: block1 } = check codeGenExpr(cx, bb, (), left);"
block1,"var { result: l, block: block1 } = check codeGenExpr(cx, bb, (), left);"
r,"var { result: r, block: nextBlock } = check codeGenExpr(cx, block1, (), right);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExpr(cx, block1, (), right);"
lType,"t:SemType lType = operandSemType(tc, l);"
rType,"t:SemType rType = operandSemType(tc, r);"
insn,"bir:CompareInsn insn = { op, pos, operands: [l, r], result };"
ad,"t:SemType ad = t:createAnydata(tc);"
value,"boolean value = negated == (leftValue != rightValue);"
value,"boolean value = negated == (leftValue !== rightValue);"
insn,"bir:EqualityInsn insn = { op, pos, operands: [l, r], result };"
binding,"Binding? binding;"
prefix,"string? prefix = ref.prefix;"
v,"var v = check lookupImportedVarRef(cx, prefix, ref.name, ref.qNamePos);"
v,"var v = check cx.lookupLocalVarRef(ref.name, ref.startPos);"
toType,"t:SemType toType = check cx.resolveTypeDesc(tcExpr.td);"
operandExpectedType,"t:SemType operandExpectedType = expected == () ? toType : t:intersect(toType, expected);"
operand,"var { result: operand, block: nextBlock } = check codeGenExpr(cx, bb, operandExpectedType, tcExpr.operand);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExpr(cx, bb, operandExpectedType, tcExpr.operand);"
fromType,"t:SemType fromType = operandSemType(cx.mod.tc, operand);"
toNumType,"t:BasicTypeBitSet? toNumType = t:singleNumericType(toType);"
resultType,"t:SemType resultType = t:intersect(fromType, toType);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, tcExpr.opPos);"
insn,"bir:TypeCastInsn insn = { operand: reg, semType: toType, pos: tcExpr.opPos, result };"
resultType,"t:SemType resultType = t:union(t:diff(fromType, t:NUMBER), toNumType);"
converted,"int|float|decimal? converted = ();"
insn,"bir:ConvertToIntInsn insn = { operand, result, pos };"
insn,"bir:ConvertToFloatInsn insn = { operand, result, pos };"
insn,"bir:ConvertToDecimalInsn insn = { operand, result, pos };"
reg,"bir:Register reg = opBinding.reg;"
curSemType,"t:SemType curSemType = reg.semType;"
diff,"t:SemType diff = t:diff(curSemType, semType);"
intersect,"t:SemType intersect;"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(intersect, reg);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(diff, reg);"
trueMerger,"TypeMerger trueMerger = createNarrowMerger(cx, opBinding, ifTrueRegister, pos, nextBlock.label, prevs?.trueMerger);"
falseMerger,"TypeMerger falseMerger = createNarrowMerger(cx, opBinding, ifFalseRegister, pos, nextBlock.label, prevs?.falseMerger);"
insn,"bir:TypeCondBranchInsn insn = { operand: reg, semType: intersect, ifTrue: trueMerger.dest.label, ifFalse: falseMerger.dest.label, ifTrueRegister, ifFalseRegister, pos };"
branch,"bir:BranchInsn branch = { dest: merger.dest.label, pos };"
newMerger,"TypeMerger newMerger = createMerger(cx, block.label, ());"
branch,"bir:BranchInsn branch = { dest: newMerger.dest.label, pos };"
nextBlock,"var { result, block: nextBlock } = check codeGenExpr(cx, bb, expected, left);"
curSemType,"t:SemType curSemType = operandSemType(tc, operand);"
insn,"bir:TypeTestInsn insn = { operand: reg, semType, result, negated, pos };"
o,"var { result: o, block: nextBlock, binding } = check codeGenExpr(cx, bb, expected, expr);"
nextBlock,"var { result: o, block: nextBlock, binding } = check codeGenExpr(cx, bb, expected, expr);"
resultType,"t:SemType resultType = t:diff(semType, t:ERROR);"
insn,"bir:RetInsn insn = { operand, pos };"
insn,"bir:PanicInsn insn = { operand, pos };"
prefix,"string? prefix = expr.prefix;"
operand,"bir:FunctionOperand operand;"
signature,"t:FunctionSignature? signature;"
curBlock,"bir:BasicBlock curBlock = bb;"
args,"bir:Operand[] args = [];"
restParamType,"t:SemType? restParamType = signature.restParamType;"
regularArgCount,"int regularArgCount = restParamType == () ? expr.args.length() : signature.paramTypes.length() - 1;"
arg,"var { result: arg, block: nextBlock } = check codeGenArgument(cx, curBlock, expr, signature, i);"
nextBlock,"var { result: arg, block: nextBlock } = check codeGenArgument(cx, curBlock, expr, signature, i);"
restArgs,"s:Expr[] restArgs = from int i in regularArgCount ..< expr.args.length() select expr.args[i];"
restParamIsList,"boolean restParamIsList = restParamType != ();"
endPos,"Position endPos;"
restArgCount,"int restArgCount = restArgs.length();"
varArgList,"s:ListConstructorExpr varArgList = { startPos, endPos, opPos: startPos, members: restArgs};"
restListTy,"t:SemType restListTy = signature.paramTypes[signature.paramTypes.length() - 1];"
arg,"var { result: arg, block: nextBlock } = check codeGenListConstructor(cx, curBlock, restListTy, varArgList);"
nextBlock,"var { result: arg, block: nextBlock } = check codeGenListConstructor(cx, curBlock, restListTy, varArgList);"
funcTy,"t:SemType funcTy = funcRegister.semType;"
paramListType,"t:SemType? paramListType = t:functionParamListType(tc, funcTy);"
argTypes,"t:SemType[] argTypes = [];"
expectedType,"t:SemType expectedType = t:listMemberTypeInnerVal(tc, paramListType, t:intConst(i));"
arg,"var { result: arg, block: nextBlock } = check codeGenExprForType(cx, curBlock, expectedType, argExpr, \"incorrect type for argument\");"
nextBlock,"var { result: arg, block: nextBlock } = check codeGenExprForType(cx, curBlock, expectedType, argExpr, \"incorrect type for argument\");"
argListType,"t:SemType argListType = t:tupleTypeWrappedRo(tc.env, ...argTypes);"
returnType,"t:SemType? returnType = t:functionReturnType(tc, funcTy, argListType);"
ref,"var ref = cx.lookupLocalVarRef(funcName, pos);"
semType,"t:SemType semType = ref.reg.semType;"
atom,"t:FunctionAtomicType? atom = t:functionAtomicType(cx.mod.tc, semType);"
signature,"t:FunctionSignature signature = t:functionSignature(cx.mod.tc, atom);"
target,"var { result: target, block: curBlock } = check codeGenExpr(cx, bb, (), expr.target);"
curBlock,"var { result: target, block: curBlock } = check codeGenExpr(cx, bb, (), expr.target);"
func,"bir:FunctionRef func = check getLangLibFunctionRef(cx, target, expr.methodName, expr.namePos);"
signature,"t:FunctionSignature signature = func.signature;"
args,"bir:Operand[] args = [target];"
reg,"bir:TmpRegister reg = cx.createTmpRegister(returnType, pos);"
insn,"bir:CallIndirectInsn|bir:CallDirectInsn insn;"
nSuppliedArgs,"int nSuppliedArgs = call is s:FunctionCallExpr ? call.args.length() : call.args.length() + 1;"
nExpectedArgs,"int nExpectedArgs = signature.paramTypes.length() - (signature.restParamType != () ? 1 : 0);"
trueBindings,"BindingChain? trueBindings = codeGenTypeMerge(cx, merger.dest, cx.bindings, merger.origins, pos);"
narrowed,"BindingChain? narrowed = bindingLimit;"
unnarrowed,"Binding unnarrowed = originGroup.unnarrowed;"
existing,"Binding existing = <Binding>envLookup(unnarrowed.name, bindingLimit);"
merged,"bir:NarrowRegister merged = cx.createNarrowRegister(originGroup.union, unnarrowed.reg, pos);"
insn,"bir:TypeMergeInsn insn = { result: merged, pos, operands: originGroup.narrowedRegs.cloneReadOnly(), predecessors: originGroup.origins.cloneReadOnly() };"
numOrigins,"int numOrigins = 0;"
origin,"TypeMergerOrigin? origin = origins;"
originGroups,"final OriginGroupTable originGroups = table [];"
bindings,"BindingChain? bindings = origin.bindings;"
added,"boolean[] added = [];"
reg,"bir:Register reg = head.reg;"
unnarrowed,"var unnarrowed = head.unnarrowed;"
number,"int number = unnarrowed.reg.number;"
originGroup,"MergeOriginGroup? originGroup = originGroups[number];"
semType,"t:SemType semType = reg.semType;"
defn,"var defn = lookupImportedVarRef(cx, prefix, identifier, pos);"
mod,"Import mod = check lookupPrefix(cx.mod, cx.defn, prefix, pos);"
moduleName,"LangLibModuleName? moduleName = operandLangLibModuleName(target);"
erasedSignature,"t:FunctionSignature? erasedSignature = getLangLibFunction(moduleName, methodName);"
symbol,"bir:ExternalSymbol symbol = { module: { org: \"ballerina\", names: [\"lang\", moduleName] }, identifier: methodName };"
signature,"t:FunctionSignature signature = erasedSignature;"
counter,"Counter counter = {};"
inst,"t:FunctionSignature inst = instantiateSignature(sig, memberType, arrayType, counter);"
atomic,"t:ListAtomicType? atomic = t:listAtomicType(tc, listType);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(tc, listType, t:INT);"
def,"t:ListDefinition def = new;"
restParamType,"bir:SemType? restParamType = sig.restParamType;"
paramTypes,"bir:SemType[] paramTypes = from var ty in sig.paramTypes select instantiateType(ty, memberType, containerType, counter);"
l,"ArithmeticOperand? l = arithmeticOperand(lhs);"
r,"ArithmeticOperand? r = arithmeticOperand(rhs);"
btc,"t:BasicTypeCode? btc = t:basicTypeCode(t:widenToBasicTypes(operand.semType));"
btc,"t:BasicTypeCode? btc = t:basicTypeCode(t:widenToBasicTypes(semType));"
ty,"t:SemType ty = reg.semType;"
wrapped,"t:WrappedSingleValue? wrapped = t:singleShape(ty);"
shape,"t:SingleValue shape = wrapped.value;"
value,"var value = operand.value;"
flags,"ValueFlags flags = VALUE_CONST;"
wrapped,"t:WrappedSingleValue? wrapped = t:singleShape(operand.semType);"
value,"float value = operand.value;"
shape,"float? shape = t:singleFloatShape(operand.semType);"
value,"decimal value = operand.value;"
shape,"decimal? shape = t:singleDecimalShape(operand.semType);"
value,"int value = operand.value;"
shape,"int? shape = t:singleIntShape(operand.semType);"
value,"boolean value = operand.value;"
shape,"boolean? shape = t:singleBooleanShape(operand.semType);"
value,"string value = operand.value;"
shape,"string? shape = t:singleStringShape(operand.semType);"
constCond,"boolean constCond;"
merger,"TypeMerger merger;"
origins,"TypeMergerOrigin origins = { bindings, label: originLabel, prev: merger?.origins };"
defn,"ExportedDefn? defn = mod.defns[identifier];"
exports,"map<ExportedDefn> exports = {};"
export,"ExportedDefn|false? export;"
names,"string[] names = id.names;"
m,"string m = \".\".'join(...id.names);"
implicitImport,"Import? implicitImport = autoImportPrefixes[prefix];"
imported,"Import? imported = mod.partPrefixes[modDefn.part.partIndex][prefix];"
defn,"ExportedDefn? defn = (check lookupPrefix(mod, modDefn, prefix, td.startPos)).defns[td.typeName];"
qName,"string qName = prefix + \":\" + td.typeName;"
loc,"d:Location loc = s:qNameLocationInDefn(modDefn, td.qNamePos);"
ty,"t:SemType ty = check resolveTypeDesc(mod, modDefn, depth, td.td);"
defn,"t:FunctionDefinition? defn = td.defn;"
d,"t:FunctionDefinition d = new;"
a,"s:TypeDesc[] a = [];"
rest,"t:SemType rest = t:NEVER;"
args,"t:SemType[] args = from var x in a select check resolveTypeDesc(mod, modDefn, depth + 1, x);"
retTy,"s:TypeDesc? retTy = td.ret;"
ret,"t:SemType ret = retTy != () ? check resolveTypeDesc(mod, modDefn, depth + 1, retTy) : t:NIL;"
td2,"s:TypeDesc td2 = td;"
ty,"t:SemType ty = check resolveTypeDesc(mod, modDefn, depth, td2.td);"
t,"t:SemType t = check resolveTypeDesc(mod, modDefn, depth, td.constituent);"
loc,"d:Location loc = d:location(modDefn.part.file, td.pos);"
t,"t:SemType t = check resolveTypeDesc(mod, modDefn, depth, td.row);"
loc,"d:Location loc = d:location(modDefn.part.file, { startPos: td.startPos, endPos: td.endPos });"
ty,"t:SemType ty = types.get(\"TyName\");"
tc,"var tc = t:typeContext(env);"
atoms,"map<ts:Atom> atoms = {};"
tySexpr,"ts:Type tySexpr = t:toSexpr(tc, ty, atoms);"
atomName,"string? atomName = t:atomRefSexpr(tySexpr);"
actual,"sexpr:Data actual = atomName != () ? atoms.get(atomName) : tySexpr;"
roundtripTy,"t:SemType roundtripTy = t:fromSexpr(env, t:atomTableFromSexpr(env, atoms), tySexpr);"
lines,"string[] lines = check io:fileReadLines(README_PATH);"
result,"map<[string, string, string?]> result = {};"
lineNo,"int lineNo = 0;"
line,"string line = unescapeMdTable(escapedLine);"
t,"int[] t = tickPos(line);"
ticks,"int[] ticks = [];"
startPos,"int startPos = 0;"
tickPos,"int? tickPos = l.indexOf(\"`\", startPos) + 1;"
chars,"int[] chars = from int c in row.toCodePointInts() where c != 0x5c select c;"
paddingContent,"string[] paddingContent = [];"
padding,"string padding = \"\".'join(...paddingContent);"
carets,"string carets = lib:stringRepeat(\"^\", contentLength);"
tc,"t:Context tc = t:typeContext(env);"
t1,"t:SemType t1 = check j:parse(tc, j1);"
t2,"t:SemType t2 = check j:parse(tc, j2);"
tem,"int tem = t:bddGetCount();"
b,"boolean b = t:isSubtype(tc, t1, t2);"
outBasename,"string outBasename = check chooseBaltCaseOutputFilename(filename, t, i);"
lines,"string[] lines = t.content;"
emitter,"LlvmEmitter emitter = new(check file:joinPath(outDir, outBasename), nbackOptions, options);"
err,"CompileError? err = compileBalFile({ lines }, basename, emitter);"
expectOutDir,"string? expectOutDir = options.expectOutDir;"
expectFilename,"string expectFilename = check file:joinPath(expectOutDir ?: outDir, outBasename) + \".txt\";"
tests,"BaltTestCase[] tests = [];"
maybeHeader,"BaltTestHeader? maybeHeader = ();"
prevFiledBody,"string? prevFiledBody = ();"
prevFiledName,"string? prevFiledName = ();"
s,"State s = BOF;"
header,"BaltTestHeader header = <BaltTestHeader>maybeHeader;"
expect,"string[] expect = [];"
comment,"int? comment = l.indexOf(\""
begin,"int begin = <int> comment + 2;"
output,"int? output = l.indexOf(OUTPUT_MARKER, begin);"
err,"int? err = l.indexOf(ERROR_MARKER, begin);"
pnk,"int? pnk = l.indexOf(PANIC_MARKER, begin);"
msg,"string msg = l.substring(pnk + PANIC_MARKER.length() + 1);"
basename,"string basename = check file:basename(filename);"
len,"int len = s.length() ;"
id,"bir:ModuleId id = birMod.getId();"
outputBasename,"string? outputBasename = self.outputBasename;"
initMod,"LlvmModule initMod = check nback:buildInitModule(env, self.programModules.reverse(), potentialEntryFuncs);"
bir,"string bir = check tback:toBirText(birMod);"
j,"Job? j = self.jobs[id];"
nj,"Job nj = { id, result: () };"
cx,"CompileContext cx = new(basename);"
entryMod,"front:ResolvedModule entryMod = check processModule(cx, DEFAULT_ROOT_MODULE_ID, [entrySrc], emitter);"
scanned,"front:ScannedModule scanned = check front:scanModule(sourceParts, id);"
resolvedImports,"ResolvedImport[] resolvedImports = [];"
ri,"ResolvedImport ri = check resolveImport(cx, mod, emitter);"
mod,"front:ResolvedModule mod = check front:resolveModule(scanned, cx.env, resolvedImports);"
job,"Job job = cx.job(id);"
result,"var result = job.result;"
processed,"var processed = check processImport(cx, id, emitter);"
parts,"var parts = check subModuleSourceParts(cx.basename, id);"
mod,"front:ResolvedModule mod = check processModule(cx, id, parts, emitter);"
directory,"string directory = check file:joinPath(basename + \".modules\", subModuleSuffix(id));"
result,"map<t:FunctionSignature> result = {};"
a1,"ReturnTypeProposition a1 = generateReturnTypePropositions(cx, path);"
a2,"ReturnTypeProposition a2 = generateReturnTypePropositions(cx, path);"
functionType,"int functionType = cx.types.union(a1.functionType, a2.functionType);"
returnType,"int returnType;"
argListType,"int argListType;"
lhsType,"t:SemType|TypeBuilderError lhsType = cx.types.semtype(lhs);"
rhsType,"t:SemType|TypeBuilderError rhsType = cx.types.semtype(rhs);"
r,"int r = cx.random.nextRange(TYPES_GENERATOR_LIST.length());"
g,"TypeGeneratorFunction g = TYPES_GENERATOR_LIST[r];"
index,"int index = g(cx.types);"
r,"int r = cx.random.next();"
r,"int r = cx.random.nextRange(128);"
right,"int|TypeBuilderError right = cx.types.intWidthSigned(8);"
l,"int l = cx.random.nextRange(cx.bounds.maxStringConstLen);"
index,"int index = cx.random.nextRange(XML_TYPES_GENERATOR_LIST.length());"
generator,"TypeGeneratorFunction generator = XML_TYPES_GENERATOR_LIST[index];"
t1,"int t1 = generateXmlType(cx);"
r,"int r = cx.random.nextRange(3);"
t2,"int t2 = generateXmlType(cx);"
p1,"SubtypeProposition p1 = generateSubtypeProposition(cx, propositionBranch(path));"
p2,"SubtypeProposition p2 = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.functionType(leftParamTypes, returnType = leftReturnType);"
right,"int right = cx.types.functionType(rightParamTypes, returnType = rightReturnType);"
left,"int left = cx.types.functionType(leftParamTypes, restType = generateRandomType(cx, path), returnType = leftReturnType);"
rightRest,"var { left: rightRest, right: leftRest } = generateSubtypeProposition(cx, propositionBranch(path));"
leftRest,"var { left: rightRest, right: leftRest } = generateSubtypeProposition(cx, propositionBranch(path));"
sliceIndex,"int sliceIndex = cx.random.nextRange(leftParamTypes.length());"
leftParamTypeSlice,"int[] leftParamTypeSlice = leftParamTypes.slice(0, sliceIndex);"
left,"int left = cx.types.functionType(leftParamTypeSlice, restType = leftRest, returnType = leftReturnType);"
right,"int right = cx.types.functionType(rightParamTypes, restType = rightRest, returnType = rightReturnType);"
leftRest,"int leftRest = generateRandomType(cx, path);"
paramCount,"int paramCount = cx.random.nextRange(cx.bounds.maxParamCount);"
subtypeRet,"var { left: subtypeRet, right: superTypeRet } = generateSubtypeProposition(cx, propositionBranch(path));"
superTypeRet,"var { left: subtypeRet, right: superTypeRet } = generateSubtypeProposition(cx, propositionBranch(path));"
p,"SubtypeProposition p = generateSubtypeProposition(cx, propositionBranch(path));"
t,"int t = p.left;"
left,"int left = cx.types.list([t], fixedLen = r);"
right,"int right = cx.types.list(rest = t);"
left,"int left = cx.types.union(cx.types.list(rest = p1.left), cx.types.list(rest = p1.right));"
right,"int right = cx.types.list(rest = cx.types.union(p1.left, p1.right));"
memberCount,"int memberCount = cx.random.nextRange(cx.bounds.maxMemberCount);"
restProposition,"SubtypeProposition restProposition = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.list(subtypes, rest = restProposition.left);"
right,"int right = cx.types.list(supertypes, rest = restProposition.right);"
rest,"SubtypeProposition rest = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.list(subtypes, rest = rest.left);"
sliceIndex,"int sliceIndex = cx.random.nextRange(supertypes.length());"
superMembers,"int[] superMembers = supertypes.slice(0, sliceIndex);"
superRest,"int superRest = rest.right;"
right,"int right = cx.types.list(superMembers, rest = superRest);"
left,"int left = cx.types.list(rest = p.left);"
right,"int right = t:NEVER;"
members,"int[] members = [];"
t,"int t = cx.types.neverType();"
rest,"int rest = -1;"
generator,"SubtypePropositionGenerator generator = AXIOMATIC_SUBTYPE_PROPOSITION_GENERATORS[cx.random.nextRange(AXIOMATIC_GENERATOR_COUNT)];"
prop,"SubtypeProposition prop = generator(cx, path);"
r,"int r = cx.random.nextRange(SUBTYPE_PROPOSITION_GENERATORS.length());"
generator,"SubtypePropositionGenerator generator = SUBTYPE_PROPOSITION_GENERATORS[r];"
generator,"ReturnTypePropositionGenerator generator = AXIOMATIC_RETURN_TYPE_PROPOSITION_GENERATORS[cx.random.nextRange(AXIOMATIC_RETURN_TYPE_PROPOSITION_GENERATORS.length())];"
prop,"ReturnTypeProposition prop = generator(cx, path);"
r,"int r = cx.random.nextRange(RETURN_TYPE_PROPOSITION_GENERATORS.length());"
generator,"ReturnTypePropositionGenerator generator = RETURN_TYPE_PROPOSITION_GENERATORS[r];"
subtypes,"int[] subtypes = [];"
supertypes,"int[] supertypes = [];"
p,"SubtypeProposition p = generateSubtypeProposition(cx, path);"
left,"int left = cx.types.mapping(rest = p.left);"
right,"int right = cx.types.mapping(rest = p.right);"
left,"int left = cx.types.union(cx.types.mapping(rest = p2.left), cx.types.mapping(rest = p2.left));"
right,"int right = cx.types.mapping(rest = cx.types.union(p1.right, p2.right));"
left,"int left = cx.types.mapping(subFields);"
right,"int right = cx.types.mapping(superFields);"
left,"int left = cx.types.mapping(subFields, rest.left);"
right,"int right = cx.types.mapping(superFields, rest.right);"
subFields,"Field[] subFields = [];"
superFields,"Field[] superFields = [];"
len,"int len = cx.random.nextRange(cx.bounds.maxStringConstLen);"
label,"string label = cx.random.randomStringValue(len);"
subtypeProp,"SubtypeProposition subtypeProp = generateSubtypeProposition(cx, { depth: 0, rands: [] });"
left,"t:SemType|TypeBuilderError left = cx.types.semtype(subtypeProp.left);"
right,"t:SemType|TypeBuilderError right = cx.types.semtype(subtypeProp.right);"
left,"NonEmptyProposition left = generateNonEmptyProposition(cx, propositionBranch(path));"
right,"NonEmptyProposition right = generateNonEmptyProposition(cx, propositionBranch(path));"
base,"NonEmptyProposition base = generateNonEmptyProposition(cx, propositionBranch(path));"
elem,"int elem = base.left;"
t,"int t = cx.types.list(rest = elem);"
rest,"int rest = base.left;"
fixedMembers,"int[] fixedMembers = from var _ in 0 ... cx.random.nextRange(cx.bounds.maxMemberCount) let var prop = generateNonEmptyProposition(cx, propositionBranch(path)) select prop.left;"
t,"int t = cx.types.list(fixedMembers, rest = rest);"
t,"int t = cx.types.list(fixedMembers);"
generator,"NonEmptyPropositionGenerator generator = AXIOMATIC_NONEMPTY_PROPOSITION_GENERATORS[cx.random.nextRange(AXIOMATIC_NONEMPTY_PROPOSITION_GENERATORS.length())];"
r,"int r = cx.random.nextRange(NONEMPTY_PROPOSITION_GENERATORS.length());"
generator,"NonEmptyPropositionGenerator generator = NONEMPTY_PROPOSITION_GENERATORS[r];"
prop,"NonEmptyProposition prop = generator(cx, path);"
left,"t:SemType|TypeBuilderError left = cx.types.semtype(p.left);"
right,"t:SemType|TypeBuilderError right = cx.types.semtype(p.right);"
result,"boolean? result = ();"
expectedReturnType,"t:SemType|TypeBuilderError expectedReturnType = cx.types.semtype(p.returnType);"
argListType,"t:SemType|TypeBuilderError argListType = cx.types.semtype(p.argListType);"
functionType,"t:SemType|TypeBuilderError functionType = cx.types.semtype(p.functionType);"
returnType,"t:SemType? returnType = t:functionReturnType(cx.typeContext, functionType, argListType);"
result,"boolean result = t:isEmpty(cx.typeContext, t:diff(returnType, expectedReturnType));"
expectedReturnType,"string|TypeBuilderError expectedReturnType = cx.types.typeToString(proposition.returnType);"
argListType,"string|TypeBuilderError argListType = cx.types.typeToString(proposition.argListType);"
functionType,"string|TypeBuilderError functionType = cx.types.typeToString(proposition.functionType);"
left,"string|TypeBuilderError left = cx.types.typeToString(proposition.left);"
right,"string|TypeBuilderError right = cx.types.typeToString(proposition.right);"
failureCount,"int failureCount = cx.failedPropositions.length();"
seed,"time:Utc seed = time:utcNow();"
cx,"PropositionGenContext cx = new PropositionGenContext(t:typeContext(new), seed[0]);"
generator,"PropositionGenerator generator = config.generator;"
prop,"Proposition prop = generator(cx, { depth, rands: [] });"
onFail,"PropositionTestOnFail? onFail = config.onFail;"
name,"string name = \"T\" + index.toString();"
vis,"s:Visibility vis = \"public\";"
defn,"s:TypeDefn defn = { startPos, endPos, name, td, namePos: startPos, vis, part: self.modulePart };"
qNamePos,"s:Position qNamePos = startPos;"
td,"s:TypeDesc td = self.createTypeDescRef(index);"
t,"t:SemType? t = self.defns[index].semType;"
ret,"error? ret = f:resolveModuleDefFromPart(self.cx, self.modulePart, self.getName(index));"
index,"int? index = self.byteIndex;"
index,"int? index = self.decimalIndex;"
index,"int? index = self.floatIndex;"
index,"int? index = self.intIndex;"
name,"string name = \"Signed\" + bits.toString();"
constituentRef,"s:TypeDescRef constituentRef = self.createTypeDescRef(constituentType);"
td,"s:XmlSequenceTypeDesc td = { startPos, endPos, pos:startPos, constituent: constituentRef };"
index,"int? index = self.xmlIndex;"
td,"s:BuiltinTypeDesc td = { startPos, endPos, builtinTypeName: \"xml\" };"
element,"s:TypeDescRef element = self.createQualifiedTypeDescRef(\"Element\", \"xml\");"
comment,"s:TypeDescRef comment = self.createQualifiedTypeDescRef(\"Comment\", \"xml\");"
pi,"s:TypeDescRef pi = self.createQualifiedTypeDescRef(\"ProcessingInstruction\", \"xml\");"
pi,"s:TypeDescRef pi = self.createQualifiedTypeDescRef(\"Text\", \"xml\");"
m,"s:TypeDescRef[] m = from var index in members select self.createTypeDescRef(index);"
restDesc,"s:TypeDescRef? restDesc = rest == -1 ? () : self.createTypeDescRef(rest);"
td,"s:TypeDesc td;"
size,"s:ExtendedLiteralExpr size = { startPos, endPos, base: 10, digits: fixedLen.toString() };"
index,"int index = self.functionType(requiredArguments, rest);"
functionSemType,"t:SemType functionSemType = checkpanic self.semtype(index);"
atomic,"t:FunctionAtomicType atomic = <t:FunctionAtomicType>t:functionAtomicType(self.cx, functionSemType);"
defn,"s:TypeDefn defn = self.defns[index];"
members,"s:TypeDescRef[] members = from var arg in requiredArguments select self.createTypeDescRef(arg);"
params,"s:FunctionTypeParam[] params = from var index in parameterTypes select self.createFunctionTypeParam(index, false);"
ret,"s:TypeDesc? ret = returnType == -1 ? () : self.createTypeDescRef(returnType);"
td,"s:FunctionTypeDesc td = { startPos, endPos, params: params, ret };"
fs,"s:FieldDesc[] fs = from var { name, index, ro } in fields select self.createField(name, index, ro);"
r,"s:TypeDesc? r = ();"
td,"s:MappingTypeDesc td = { startPos, endPos, fields: fs, rest: r };"
typeDesc,"s:TypeDescRef typeDesc = self.createTypeDescRef(index);"
index,"int? index = self.neverIndex;"
valueExpr,"s:ExtendedLiteralExpr valueExpr;"
desc,"s:SingletonTypeDesc desc = { startPos, endPos, valueExpr };"
index,"int? index = self.stringIndex;"
tds,"s:TypeDesc[] tds = [self.createTypeDescRef(i1), self.createTypeDescRef(i2)];"
union,"s:BinaryTypeDesc union = { startPos, endPos, opPos: [startPos], op: \"|\", tds };"
intersection,"s:BinaryTypeDesc intersection = { startPos, endPos, opPos: [startPos], op: \"&\", tds };"
loc,"d:Location loc = err.detail().location;"
filename,"string filename = loc.file.filename();"
lc,"d:LineColumn lc = d:locationLineColumn(loc);"
modulePath,"string? modulePath = check moduleDir(path);"
errorLocation,"FilenameLine? errorLocation = ();"
subModPath,"string subModPath = filePath.substring(0, filePath.length()-4) + \".modules\";"
fileErrorLine,"int? fileErrorLine = check errorLine(filePath);"
cases,"TestSuiteCases cases = {};"
category,"string category = check file:basename(dir.absPath);"
name,"string name = check file:basename(test.absPath);"
dash,"int? dash = base.lastIndexOf(\"-\");"
testKind,"string testKind = base.substring(1 + <int>dash);"
lineNo,"int? lineNo = ();"
test,"s:TypeTest test = check s:parseTypeTest(item);"
left,"t:SemType left = resolveTestSemtype(tc, m, test.left);"
right,"t:SemType right = resolveTestSemtype(tc, m, test.right);"
lhsStr,"string lhsStr = test.left.toString();"
rhsStr,"string rhsStr = test.right.toString();"
lsr,"boolean lsr = t:isSubtype(tc, left, right);"
rsl,"boolean rsl = t:isSubtype(tc, right, left);"
testPair,"boolean[2] testPair = [lsr, rsl];"
t,"t:SemType t = lookupSemtype(m, tn.identifier);"
index,"int|s:Identifier index = tn.index;"
kt,"t:SemType kt = lookupSemtype(m, index);"
s1,"t:SemType s1 = t:listProjInnerVal(tc, t, index);"
s2,"t:SemType s2 = t:listMemberTypeInnerVal(tc, t, index);"
t,"t:SemType? t = m[id];"
r,"t:Range r = ranges[i];"
it,"t:SemType it = types[i];"
projected,"t:SemType projected = t:listMemberTypeInnerVal(tc, t, t:intConst(r.min));"
birText,"string birText = check tback:toBirText(birMod);"
firstRoundLl,"string firstRoundLl = firstRoundLlMod.printModuleToString();"
secondRoundSexpr,"sexpr:Data[] secondRoundSexpr = checkpanic sexpr:parse(birText);"
secondRoundTypeSexpr,"bsexpr:Module secondRoundTypeSexpr = checkpanic secondRoundSexpr.cloneWithType();"
secondRoundBirMod,"bir:Module secondRoundBirMod = bsexpr:toModule(secondRoundTypeSexpr, birMod.getId());"
secondRoundLl,"string secondRoundLl = secondRoundLlMod.printModuleToString();"
outputBasename,"string outputBasename = check chooseOutputBasename(basename, opts.outDir);"
emitter,"Emitter emitter;"
err,"CompileError? err = compileBalFile({ filename }, basename, emitter);"
files,"string files = errorFileCount == 1 ? \"file\" : \"files\";"
extIndex,"int? extIndex = filename.lastIndexOf(\".\");"
entries,"var entries = from var [name, t] in m.entries() order by name select [name, t];"
results,"[string, string][] results = [];"
rels,"string[] rels = from var [name1, name2] in results let string s = name1 + \"<:\" + name2 order by s select s;"
val,"Metadata val = intAsMetadata(self.context, flag[1]);"
dBuilder,"DIBuilder? dBuilder = self.diBuilder;"
bytePointer,"BytePointer bytePointer = new (jLLVMPrintModuleToString(self.LLVMModule));"
e,"byte[] e = [];"
err,"handle err = checkpanic jarrays:toHandle(e, \"byte\");"
runtimeMemBuffer,"LLVMMemoryBuffer runtimeMemBuffer = new;"
libModule,"Module libModule = new(\"balrt_inline\", self.context);"
result,"int result = jLLVMLinkModules2(self.LLVMModule, libModule.LLVMModule);"
result,"int result = jLLVMParseBitcodeInContext2(self.context.LLVMContext, memoryBuffer.jObject, self.LLVMModule);"
optLevel,"string optLevel = opts.optLevel ?: \"Default\";"
relocMode,"string relocMode = opts.relocMode ?: \"PIC\";"
codeModel,"string codeModel = opts.codeModel ?: \"Default\";"
file,"BytePointer file = new(jBytePointerFromString(java:fromString(fileName)));"
targetTriple,"BytePointer targetTriple;"
jTargetRef,"handle jTargetRef = jLLVMGetFirstTarget();"
lookupError,"BytePointer lookupError = new(jBytePointer());"
isLookUpError,"int isLookUpError = jLLVMGetTargetFromTriple(targetTriple.jObject, jTargetRef, lookupError.jObject);"
cpu,"BytePointer cpu = new(jBytePointerFromString(java:fromString(\"generic\")));"
features,"BytePointer features = new(jBytePointerFromString(java:fromString(\"\")));"
llvmOptLevel,"int llvmOptLevel = getLLVMCodeGenOptLevel(optLevel);"
jTargetMachineRef,"handle jTargetMachineRef = jLLVMCreateTargetMachine(jTargetRef, targetTriple.jObject, cpu.jObject, features.jObject, llvmOptLevel, getLLVMRelocMode(relocMode), getLLVMCodeModel(codeModel));"
emitError,"BytePointer emitError = new(jBytePointer());"
isEmitError,"int isEmitError = jLLVMTargetMachineEmitToFile(jTargetMachineRef, self.LLVMModule, file.jObject, 1, emitError.jObject);"
functionPasses,"handle functionPasses = jLLVMCreateFunctionPassManager(jLLVMCreateModuleProviderForExistingModule(self.LLVMModule));"
modulePasses,"handle modulePasses = jLLVMCreatePassManager();"
targetDataRef,"handle targetDataRef = jLLVMCreateTargetDataLayout(jTargetMachineRef);"
targetDataBP,"handle targetDataBP = jLLVMCopyStringRepOfTargetData(targetDataRef);"
val,"ConstPointerValue val = new (jLLVMAddGlobalInAddressSpace(self.LLVMModule, typeToLLVMType(self.context, ty), java:fromString(name), props.addressSpace), pointerType(ty, props.addressSpace));"
initializer,"var initializer = props.initializer;"
val,"ConstPointerValue val = new(jLLVMAddAlias(self.LLVMModule, typeToLLVMType(self.context, aliasTy), props.addressSpace, aliasee.LLVMValueRef, java:fromString(name)), pointerType(aliasTy, props.addressSpace));"
id,"int id = intrinsicNameToId(name);"
fnType,"FunctionType fnType = name is IntegerArithmeticIntrinsicName ? {returnType: structType([\"i64\", \"i1\"]), paramTypes: [\"i64\", \"i64\"]} : {returnType: pointerType(\"i8\", 1), paramTypes: [pointerType(\"i8\", 1), \"i64\"]};"
paramTypes,"PointerPointer paramTypes = PointerPointerFromTypes(self.context, fnType.paramTypes);"
paramCount,"int paramCount = fnType.paramTypes.length();"
optimized,"int optimized = getBooleanProp(props.isOptimized);"
kind,"int kind = emissionKindToInt.get(props.kind);"
DWOId,"int DWOId = getIntProp(props.DWOId);"
splitDebugInlining,"int splitDebugInlining = getBooleanProp(props.splitDebugInlining);"
splitDebugInfoForProfiling,"int splitDebugInfoForProfiling = getBooleanProp(props.splitDebugInfoForProfiling);"
jObj,"handle jObj = jLLVMDIBuilderCreateCompileUnit(self.LLVMDIBuilder, lang, file, producer, producerLen, optimized, flags, flagsLen, props.runtimeVersion, splitName, splitNameLen, kind, DWOId, splitDebugInlining, splitDebugInfoForProfiling, sysRoot, sysRootLen, sdk, sdkLen);"
jObj,"handle jObj = jLLVMDIBuilderCreateFile(self.LLVMDIBuilder, filenameObj, filenameLen, dir, dirLen);"
scope,"handle scope = getMetadataProp(props.scope);"
file,"handle file = getMetadataProp(props.file);"
ty,"handle ty = getMetadataProp(props.ty);"
isLocalToUnit,"int isLocalToUnit = getBooleanProp(props.isLocalToUnit);"
isDefinition,"int isDefinition = getBooleanProp(props.isDefinition);"
flag,"int flag = dIFlagToInt.get(props.flag);"
isOptimized,"int isOptimized = getBooleanProp(props.isOptimized);"
jObj,"handle jObj = jLLVMDIBuilderCreateFunction(self.LLVMDIBuilder, scope, name, nameLen, linkageName, linkageNameLen, file, props.lineNo, ty, isLocalToUnit, isDefinition, props.scopeLine, flag, isOptimized);"
fileObj,"handle fileObj = getMetadataProp(file);"
parameterArr,"PointerPointer parameterArr = PointerPointerFromMetadata(parameterTypes);"
flagObj,"int flagObj = dIFlagToInt.get(flag);"
jObj,"handle jObj = jLLVMDIBuilderCreateSubroutineType(self.LLVMDIBuilder, fileObj, parameterArr.jObject, parameterTypes.length(), flagObj);"
scopeJObj,"handle scopeJObj = getMetadataProp(scope);"
inlinedAtJObj,"handle inlinedAtJObj = getMetadataProp(inlinedAt);"
jObj,"handle jObj = jLLVMDIBuilderCreateDebugLocation(self.context.LLVMContext, line, column, scopeJObj, inlinedAtJObj);"
align,"int align = getIntProp(props.alignInBits);"
jObj,"handle jObj = jLLVMDIBuilderCreatePointerType(self.LLVMDIBuilder, props.pointeeTy.llvmMetadata, props.sizeInBits, align, props.addressSpace, tyName, nameLen);"
align,"int align = getIntProp(alignInBits);"
jObj,"handle jObj = jLLVMDIBuilderCreateTypedef(self.LLVMDIBuilder, ty.llvmMetadata, tyName, nameLen, file.llvmMetadata, lineNo, scope.llvmMetadata, align);"
encoding,"int encoding = encodingToInt.get(props.encoding);"
flags,"int flags = dIFlagToInt.get(props.flag);"
jObj,"handle jObj = jLLVMDIBuilderCreateBasicType(self.LLVMDIBuilder, tyName, nameLen, props.sizeInBits, encoding, flags);"
jObj,"handle jObj = jLLVMDIBuilderCreateAutoVariable(self.LLVMDIBuilder, props.scope.llvmMetadata, name, nameLen, props.file.llvmMetadata, props.lineNo, props.ty.llvmMetadata, 1, flags, align);"
jObj,"handle jObj = jLLVMDIBuilderCreateExpression(self.LLVMDIBuilder, checkpanic jarrays:toHandle(addr, \"long\"), addr.length());"
jObj,"handle jObj = jLLVMDIBuilderCreateLexicalBlock(self.LLVMDIBuilder, scope.llvmMetadata, file.llvmMetadata, line, column);"
message,"Point message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"routeguide.RouteGuide/GetFeature\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"routeguide.RouteGuide/RecordRoute\");"
message,"Rectangle message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"routeguide.RouteGuide/ListFeatures\", message, headers);"
outputStream,"FeatureStream outputStream = new FeatureStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"routeguide.RouteGuide/RouteChat\");"
response,"var response = check self.sClient->receive();"
nextRecord,"record {|Feature value;|} nextRecord = {value: <Feature>streamValue.value};"
personInfo,"var personInfo = from var {id: personId, fname: firstName, lname: lastName} in personList select { id: personId, name: firstName + \" \" + lastName };"
profession,"var profession = \"Software Engineer\";"
greeting,"string greeting = \"Hello World\";"
response,"var response = check int:fromString(\"404\");"
message,"SMReq message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"SeparateModuleService/unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"SeparateModuleService/clientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"SeparateModuleService/serverStreaming\", message, headers);"
outputStream,"SMResStream outputStream = new SMResStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SeparateModuleService/bidirectional1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SeparateModuleService/bidirectional2\");"
nextRecord,"record {|SMRes value;|} nextRecord = {value: <SMRes>streamValue.value};"
outputStream,"StringStream outputStream = new StringStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld/lotsOfReplies\", req);"
nextRecord,"record {| string value; |} nextRecord = {value: <string>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/helloWorld\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloBallerina/helloBallerina\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/sayHello\", message, headers);"
message,"message1:ReqMessage1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.packagingService/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.packagingService/hello3\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.packagingService/hello2\", message, headers);"
outputStream,"ResMessage2Stream outputStream = new ResMessage2Stream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.packagingService/hello4\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.packagingService/hello5\");"
nextRecord,"record {|message2:ResMessage2 value;|} nextRecord = {value: <message2:ResMessage2>streamValue.value};"
message,"ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloBallerina71/hi\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloBallerina71/hello\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloBallerina71/hey\", message, headers);"
outputStream,"ResMessageStream outputStream = new ResMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloBallerina71/bye\");"
nextRecord,"record {|ResMessage value;|} nextRecord = {value: <ResMessage>streamValue.value};"
message,"message1:ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloWorld70/helloWorld70Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloWorld70/helloWorld70ClientStream\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloWorld70/helloWorld70ServerStream\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld70/helloWorld70BidiStream\");"
nextRecord,"record {|message2:ResMessage value;|} nextRecord = {value: <message2:ResMessage>streamValue.value};"
message,"messageWithService:ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloWorld71/helloWorld71Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloWorld71/helloWorld71ClientStream\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloWorld71/helloWorld71ServerStream\", message, headers);"
outputStream,"messageWithService:ResMessageStream outputStream = new messageWithService:ResMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld71/helloWorld71BidiStream\");"
message,"Order message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.OrderManagement/addOrder\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.OrderManagement/getOrder\", message, headers);"
outputStream,"Int32ArrMsgStream outputStream = new Int32ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithInt32Array\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithInt64Array\", message, headers);"
outputStream,"Int64ArrMsgStream outputStream = new Int64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithUnsignedInt64Array\", message, headers);"
outputStream,"UnsignedInt64ArrMsgStream outputStream = new UnsignedInt64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFixed32Array\", message, headers);"
outputStream,"Fixed32ArrMsgStream outputStream = new Fixed32ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFixed64Array\", message, headers);"
outputStream,"Fixed64ArrMsgStream outputStream = new Fixed64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFloatArray\", message, headers);"
outputStream,"FloatArrMsgStream outputStream = new FloatArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithDoubleArray\", message, headers);"
outputStream,"DoubleArrMsgStream outputStream = new DoubleArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithStringArray\", message, headers);"
outputStream,"StringArrMsgStream outputStream = new StringArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithBooleanArray\", message, headers);"
outputStream,"BooleanArrMsgStream outputStream = new BooleanArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithBytesArray\", message, headers);"
outputStream,"BytesArrMsgStream outputStream = new BytesArrMsgStream(result);"
nextRecord,"record {|Int32ArrMsg value;|} nextRecord = {value: <Int32ArrMsg>streamValue.value};"
nextRecord,"record {|Int64ArrMsg value;|} nextRecord = {value: <Int64ArrMsg>streamValue.value};"
nextRecord,"record {|UnsignedInt64ArrMsg value;|} nextRecord = {value: <UnsignedInt64ArrMsg>streamValue.value};"
nextRecord,"record {|Fixed32ArrMsg value;|} nextRecord = {value: <Fixed32ArrMsg>streamValue.value};"
nextRecord,"record {|Fixed64ArrMsg value;|} nextRecord = {value: <Fixed64ArrMsg>streamValue.value};"
nextRecord,"record {|FloatArrMsg value;|} nextRecord = {value: <FloatArrMsg>streamValue.value};"
nextRecord,"record {|DoubleArrMsg value;|} nextRecord = {value: <DoubleArrMsg>streamValue.value};"
nextRecord,"record {|StringArrMsg value;|} nextRecord = {value: <StringArrMsg>streamValue.value};"
nextRecord,"record {|BooleanArrMsg value;|} nextRecord = {value: <BooleanArrMsg>streamValue.value};"
nextRecord,"record {|BytesArrMsg value;|} nextRecord = {value: <BytesArrMsg>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld14/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService1/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService1/hello2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService2/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"AnonService2/hello2\", message, headers);"
outputStream,"swrappers:StringStream outputStream = new swrappers:StringStream(result);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService3/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"AnonService3/hello2\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService4/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"AnonService4/hello2\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"enum_imports.LocationService/GetLocation\", message, headers);"
message,"AnyArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/anyCall\", message, headers);"
message,"StructArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/structCall\", message, headers);"
message,"TimestampArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/timestampCall\", message, headers);"
message,"DurationArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/durationCall\", message, headers);"
message,"'any:Any message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall3\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"AnyTypeServer/clientStreamingCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"AnyTypeServer/serverStreamingCall\", message, headers);"
outputStream,"sany:AnyStream outputStream = new sany:AnyStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"AnyTypeServer/bidirectionalStreamingCall\");"
message,"AnyMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/anyCall\", message, headers);"
message,"StructMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/structCall\", message, headers);"
message,"TimestampMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/timestampCall\", message, headers);"
message,"DurationMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/durationCall\", message, headers);"
message,"HelloRequest58 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedMessageNestedEnum/hello\", message, headers);"
message,"ByeRequest58 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedMessageNestedEnum/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld52/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld29/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld29/testStringValueReturnNegative\", message, headers);"
message,"byte[] message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ByteService/checkBytes\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld36S1/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld36S2/call2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/getGreeting\", message, headers);"
message,"Greeting message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/exchangeGreeting\", message, headers);"
message,"time:Utc message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/exchangeTime\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"TimestampService/clientStreamTime\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"TimestampService/serverStreamTime\", message, headers);"
outputStream,"stimestamp:TimestampStream outputStream = new stimestamp:TimestampStream(result);"
message,"HandshakeRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/handshake\", message, headers);"
message,"MetricsPublishRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/publishMetrics\", message, headers);"
message,"TracesPublishRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/publishTraces\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"NestedMsgService/nestedMsgUnary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"NestedMsgService/nestedMsgClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"NestedMsgService/nestedMsgServerStreaming\", message, headers);"
outputStream,"NestedMsgStream outputStream = new NestedMsgStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"NestedMsgService/nestedMsgBidirectionalStreaming\");"
nextRecord,"record {|NestedMsg value;|} nextRecord = {value: <NestedMsg>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.GrpcMutualSslService/hello\", message, headers);"
message,"ProductDetail message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.ProductInfo/addProduct\", message, headers);"
message,"ProductID message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.ProductInfo/getProduct\", message, headers);"
message,"MessageInfo message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MessageService/UnaryCall\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.CheckoutService/PlaceOrder\", message, headers);"
message,"TestInt message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testIntArrayInput\", message, headers);"
message,"TestString message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStringArrayInput\", message, headers);"
message,"TestFloat message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testFloatArrayInput\", message, headers);"
message,"TestBoolean message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testBooleanArrayInput\", message, headers);"
message,"TestStruct message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStructArrayInput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testIntArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStringArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testFloatArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testBooleanArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStructArrayOutput\", message, headers);"
message,"SimpleRequestWithAnnotation message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"SimpleServiceWithAnnotation/unaryCallWithAnnotatedData\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"SimpleServiceWithAnnotation/clientStreamingWithAnnotatedData\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"SimpleServiceWithAnnotation/serverStreamingWithAnnotatedData\", message, headers);"
outputStream,"SimpleResponseWithAnnotationStream outputStream = new SimpleResponseWithAnnotationStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SimpleServiceWithAnnotation/bidirectionalStreamingWithAnnotatedData\");"
nextRecord,"record {|SimpleResponseWithAnnotation value;|} nextRecord = {value: <SimpleResponseWithAnnotation>streamValue.value};"
message,"OrderInfo message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.TestEnumService/testEnum\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld85/hello\", message, headers);"
outputStream,"HelloResponseStream outputStream = new HelloResponseStream(result);"
message,"HelloRequest message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorldServerStreaming/lotsOfReplies\", message, headers);"
nextRecord,"record {|HelloResponse value;|} nextRecord = {value: <HelloResponse>streamValue.value};"
message,"TypesMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getTypes\", message, headers);"
message,"RepeatedTypesMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getRepeatedTypes\", message, headers);"
message,"int message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getInt32Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getInt64Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getUInt32Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getUInt64Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld50/checkCancellation\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld50/sendString\");"
message,"GetClassRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"UpdatedService/GetClass\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"UpdatedService/GetGroup\", message, headers);"
display_nameCount,"int display_nameCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld16/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/getStructType1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/getStructType2\", message, headers);"
message,"map<anydata> message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/sendStructType1\", message, headers);"
message,"StructMsg message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/sendStructType2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/exchangeStructType1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/exchangeStructType2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"StructService/clientStreamStructType1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"StructService/clientStreamStructType2\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"StructService/serverStreamStructType1\", message, headers);"
outputStream,"sstruct:StructStream outputStream = new sstruct:StructStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"StructService/serverStreamStructType2\", message, headers);"
outputStream,"StructMsgStream outputStream = new StructMsgStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"StructService/bidirectionalStreamStructType1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"StructService/bidirectionalStreamStructType2\");"
nextRecord,"record {|StructMsg value;|} nextRecord = {value: <StructMsg>streamValue.value};"
message,"Person message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputNestedStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testOutputNestedStruct\", message, headers);"
message,"StockRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputStructOutputStruct\", message, headers);"
message,"StockQuote message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputStructNoOutput\", message, headers);"
message,"Empty message = {};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testNoInputOutputStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testNoInputOutputArray\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55/hello55UnaryWithCaller\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55/hello55UnaryWithReturn\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HelloWorld55/hello55ClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld55/hello55ServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld55/hello55BiDiWithCaller\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld55/hello55BiDiWithReturn\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55EmptyScope/hello55EmptyScope\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld56/hello56Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld56/hello56BiDi\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testStringValueReturn\", message, headers);"
message,"float message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testFloatValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testDoubleValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testInt64ValueReturn\", message, headers);"
message,"boolean message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testBoolValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testBytesValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testRecordValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld24/testRecordValueReturnStream\", message, headers);"
outputStream,"SampleMsg24Stream outputStream = new SampleMsg24Stream(result);"
nextRecord,"record {|SampleMsg24 value;|} nextRecord = {value: <SampleMsg24>streamValue.value};"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld45/lotsOfReplies\", message, headers);"
message,"SampleMsg31 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld31/sayHello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld28/testStringValueReturn\", message, headers);"
message,"Request1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.OneofFieldService/hello\", message, headers);"
message,"ZZZ message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.OneofFieldService/testOneofField\", message, headers);"
otherCount,"int otherCount = 0;"
nameCount,"int nameCount = 0;"
codeCount,"int codeCount = 0;"
valueCount,"int valueCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testInt\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testFloat\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testBoolean\", message, headers);"
message,"Request message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testNoRequest\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testNoResponse\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testResponseInsideMatch\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ProductCatalog/getProduct\", message, headers);"
message,"ChangedCustomer message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ProductCatalog/sendCustomer\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"DurationHandler/unaryCall1\", message, headers);"
message,"DurationMsg message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"DurationHandler/unaryCall2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"DurationHandler/clientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DurationHandler/serverStreaming\", message, headers);"
outputStream,"sduration:DurationStream outputStream = new sduration:DurationStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"DurationHandler/bidirectionalStreaming\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueNoScope\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueNegative\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld53/hello53\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld51/sendStringBiDi\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HelloWorld51/InvalidRPCCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld51/InvalidRPCCall\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld51/stringServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld51/InvalidRPCCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld25/lotsOfReplies\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld13/hello\", message, headers);"
message,"HSReq message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HeadersService/unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HeadersService/clientStr\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HeadersService/serverStr\", message, headers);"
outputStream,"HSResStream outputStream = new HSResStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HeadersService/bidirectionalStr\");"
nextRecord,"record {|HSRes value;|} nextRecord = {value: <HSRes>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld73/hello73Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"grpcservices.HelloWorld73/hello73Client\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld73/hello73Server\", message, headers);"
outputStream,"ReplyMessageStream outputStream = new ReplyMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"grpcservices.HelloWorld73/hello73Bidi\");"
nextRecord,"record {|ReplyMessage value;|} nextRecord = {value: <ReplyMessage>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld98/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld98/testInt\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"EmptyHandler/clientStrWithEmpty\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"EmptyHandler/serverStrWithEmpty\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"messagesize.HelloWorld62/msgSizeUnary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"messagesize.HelloWorld62/msgSizeClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"messagesize.HelloWorld62/msgSizeServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"messagesize.HelloWorld62/msgSizeBidiStreaming\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallAny\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallStruct\", message, headers);"
message,"time:Seconds message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallDuration\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallTimestamp\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallEmpty\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RetryService/getResult\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld39/testStringValueReturn\", message, headers);"
err,"grpc:Error? err = conn->sendString(msg);"
msg,"string msg = string `${caller.getId()} left the chat`;"
conn,"ChatStringCaller conn;"
message,"ChatMessage41 message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat41/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat41/call2\", message, headers);"
outputStream,"SampleMsg32Stream outputStream = new SampleMsg32Stream(result);"
message,"SampleMsg32 message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld32/sayHello\", message, headers);"
nextRecord,"record {|SampleMsg32 value;|} nextRecord = {value: <SampleMsg32>streamValue.value};"
message_requestCount,"int message_requestCount = 0;"
message_responseCount,"int message_responseCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld101/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld35/callWithinDeadline\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld35/callExceededDeadline\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"routeguide.RouteGuide/ListFeatures\", req);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"BalProgramAnalyzer/syntaxTree\", message, headers);"
stream_call_responseCount,"int stream_call_responseCount = 0;"
deadlineStringValue,"string|string[]? deadlineStringValue = headerMap[DEALINE_HEADER];"
deadline,"time:Utc deadline = check time:utcFromString(deadlineStringValue);"
data,"record {|Variable value;|}? data = check queryResult.next();"
variable,"Variable variable = data.value;"
data,"record {|Result value;|}? data = check queryResult.next();"
value,"Result value = data.value;"
payload,"string payload = string `grant_type=password&username=${username}&password=${password}`;"
requestConfig,"RequestConfig requestConfig;"
defaultTokenExpTime,"decimal defaultTokenExpTime = config.defaultTokenExpTime;"
clockSkew,"decimal clockSkew = config.clockSkew;"
clientConfig,"ClientConfiguration clientConfig = config.clientConfig;"
response,"json response = check sendRequest(requestConfig, tokenUrl, clientConfig);"
accessToken,"string accessToken = check extractAccessToken(response);"
refreshToken,"string? refreshToken = extractRefreshToken(response);"
expiresIn,"int? expiresIn = extractExpiresIn(response);"
encodedUserName,"string encodedUserName = check url:encode(username, UTF8);"
encodedPassword,"string encodedPassword = check url:encode(password, UTF8);"
tokenUrl,"string tokenUrl = config.tokenUrl;"
clientId,"string? clientId = config?.clientId;"
clientSecret,"string? clientSecret = config?.clientSecret;"
refreshConfig,"RefreshConfig refreshConfig = check getRefreshConfig(config);"
refreshToken,"string refreshToken = tokenCache.getRefreshToken();"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: clientId, clientSecret: clientSecret, scopes: refreshConfig?.scopes, optionalParams: refreshConfig?.optionalParams, credentialBearer: refreshConfig.credentialBearer };"
response,"json response = check sendRequest(requestConfig, refreshConfig.refreshUrl,refreshConfig.clientConfig);"
updatedRefreshToken,"string? updatedRefreshToken = extractRefreshToken(response);"
refreshConfig,"RefreshConfig|INFER_REFRESH_CONFIG? refreshConfig = config?.refreshConfig;"
refreshUrl,"string refreshUrl = config.refreshUrl;"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: config.clientId, clientSecret: config.clientSecret, scopes: config?.scopes, optionalParams: config?.optionalParams, credentialBearer: config.credentialBearer };"
response,"json response = check sendRequest(requestConfig, refreshUrl, clientConfig);"
refreshUrl,"string refreshUrl = config.tokenUrl;"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: clientId, clientSecret: clientSecret, scopes: config?.scopes, optionalParams: config?.optionalParams, credentialBearer: config.credentialBearer };"
headers,"map<string> headers = check prepareHeaders(requestConfig);"
payload,"string payload = check preparePayload(requestConfig);"
stringResponse,"string|Error stringResponse = doHttpRequest(url, clientConfig, headers, payload);"
jsonResponse,"json|error jsonResponse = stringResponse.fromJsonString();"
headers,"map<string> headers = {};"
clientIdSecret,"string clientIdSecret = clientId + \":\" + clientSecret;"
textPayload,"string textPayload = config.payload;"
scopeString,"string scopeString = \"\";"
scopes,"string|string[]? scopes = config.scopes;"
trimmedRequestScope,"string trimmedRequestScope = requestScope.trim();"
optionalParams,"map<string>? optionalParams = config.optionalParams;"
accessToken,"json|error accessToken = response.access_token;"
refreshToken,"json|error refreshToken = response.refresh_token;"
expiresIn,"json|error expiresIn = response.expires_in;"
currentTime,"[int, decimal] currentTime = time:utcNow();"
issueTime,"int issueTime = currentTime[0];"
customHeadersMap,"map<string> customHeadersMap = {};"
oauth2Provider,"ClientOAuth2Provider? oauth2Provider = clientOAuth2Provider;"
accessToken,"string|Error accessToken = oauth2Provider.generateToken();"
stringResponse,"string|Error stringResponse = doHttpRequest(config.url, config.clientConfig, customHeadersMap, textPayload);"
introspectionResponse,"IntrospectionResponse introspectionResponse = { active: false };"
payloadMap,"map<json> payloadMap = <map<json>>payload;"
keys,"string[] keys = payloadMap.keys();"
result,"cache:Error? result;"
cachedEntry,"any|cache:Error cachedEntry = oauth2Cache.get(token);"
response,"IntrospectionResponse response = <IntrospectionResponse> cachedEntry;"
expTime,"int? expTime = response?.exp;"
result,"cache:Error? result = oauth2Cache.invalidate(token);"
dbClient1,"Client dbClient1 = check new (host, user, password, database, port, options);"
dbClient2,"Client dbClient2 = check new (host, user, password, database, port, options);"
dbClient3,"Client dbClient3 = check new (host, user, password, database, port, options);"
dbClient4,"Client dbClient4 = check new (host, user, password, database, port, options);"
dbClient5,"Client dbClient5 = check new (host, user, password, database, port, options);"
resultArray,"stream<Result, error?>[] resultArray = [];"
encoded,"string|error encoded = url:encode(value, UTF8);"
stringWithUnderScore,"string stringWithUnderScore = regex:replaceAll(camelCaseString, \"([A-Z])\", \"_$1\");"
updateQuery,"string updateQuery = createQuery(message);"
url,"string url = UPDATE_MESSAGE_PATH + channelId + updateQuery;"
response,"http:Response response = check slackClient->post(<@untainted> url, EMPTY_STRING);"
payload,"json payload = check response.getJsonPayload();"
threadId,"json threadId = check payload.ts;"
response,"http:Response|error response = slackClient->post(url, EMPTY_STRING);"
ok,"json ok = check payload.ok;"
ch,"var ch = payload.'channel;"
slackCh,"Channel|error slackCh = ch.cloneWithType(Channel);"
url,"string url = CONVERSATIONS_JOIN_PATH + channelId;"
url,"string url = LEAVE_CHANNEL_PATH + channelId;"
url,"string url = GET_USER_INFO_PATH + userId;"
response,"http:Response response = check slackClient->get(url);"
userInfo,"json userInfo = check response.getJsonPayload();"
user,"json user = check userInfo.user;"
url,"string url = RENAME_CHANNEL_PATH + channelId + NAME_ARG + newName;"
ok,"json|error ok = respPayload.ok;"
errorRes,"json|error errorRes = respPayload.'error;"
url,"string url = DELETE_CONVERSATION_PATH + channelId + DELETE_CONVERSATION_TS_ARG + threadTs;"
url,"string url = DELETE_FILE_PATH + fileId;"
url,"string url = LIST_FILES_PATH;"
response,"http:Response response = check slackClient->post(url, EMPTY_STRING);"
fileList,"json fileList = check response.getJsonPayload();"
files,"json files = check fileList.files;"
fileJson,"json[] fileJson = <json[]> files;"
url,"string url = UPLOAD_FILES_PATH;"
request,"http:Request request = new;"
filePart,"mime:Entity filePart = new;"
bodyParts,"mime:Entity[] bodyParts = [<@untainted> filePart];"
response,"http:Response response = check slackClient->post(url, request);"
fileInfo,"json fileInfo = check response.getJsonPayload();"
fileInfoPayload,"json fileInfoPayload = fileInfo;"
file,"json file = check fileInfoPayload.file;"
url,"string url = GET_FILE_INFO_PATH + fileId;"
fileJson,"json fileJson = <json> check fileInfo.file;"
contentDisposition,"mime:ContentDisposition contentDisposition = new;"
lastIndex,"int? lastIndex = string:lastIndexOf(filePath, BACK_SLASH);"
mapValue,"map<json> mapValue = <map<json>>req;"
converted,"string converted = convertToCamelCase(key);"
innerJson,"json[] innerJson = <json[]>mapValue[converted];"
returnResult,"string returnResult = \"\";"
splitResult,"string[] splitResult = regex:split(input, \"_\");"
participantId,"string participantId = participant.participantId;"
notifyResult,"NotifyResult|error notifyResult = (action == COMMAND_COMMIT) ? NOTIFY_RESULT_COMMITTED : NOTIFY_RESULT_ABORTED;"
results,"future<(NotifyResult|error)?>?[] results = [];"
participantArr,"var participantArr = self.participants.toArray();"
participant,"var participant = participantArr[i];"
f,"future<(NotifyResult|error)?> f = @strand{thread:\"any\"} start participant.notify(action, protocolName);"
j,"int j = 0;"
r,"var r = results[j];"
f,"future<(NotifyResult|error)?> f;"
result,"(NotifyResult|error)? result = wait f;"
ret,"string|lang_trx:Error ret = \"\";"
result,"var result = self.notifyParticipants(COMMAND_ABORT, ());"
localAbortSuccessful,"boolean localAbortSuccessful = abortResourceManagers(self.transactionId, self.transactionBlockId);"
removed,"var removed = trap self.participants.remove(participantId);"
value,"anydata value = v is Valuer ? v() : v;"
spanContext,"map<string> spanContext = observe:getSpanContext();"
logOutput,"string logOutput = format == JSON_OUTPUT_FORMAT ? logRecord.toJsonString() : printLogFmt(logRecord);"
path,"string? path = ();"
causes,"ErrorDetail[] causes = [];"
errCause,"error? errCause = err.cause();"
stackFrames,"StackFrame[] stackFrames = [];"
stackFrameImpl,"java:StackFrameImpl stackFrameImpl = <java:StackFrameImpl>item;"
stackFrame,"StackFrame stackFrame = { callableName: stackFrameImpl.callableName, fileName: stackFrameImpl.fileName, moduleName: stackFrameImpl.moduleName, lineNumber: stackFrameImpl.lineNumber };"
errMessage,"json|error errMessage = value:fromJsonString(message);"
output,"string output = logOutput;"
result,"io:Error? result = io:fileWriteString(path, output + \"\n\", io:APPEND);"
message,"string message = \"\";"
temp,"handle temp = replaceString(java:fromString(msg), java:fromString(\"\\\"), java:fromString(\"\\\\\"));"
updatedString,"string? updatedString = java:toString(temp);"
moduleLogLevel,"string moduleLogLevel = level;"
module,"Value module = keyValues[\"module\"];"
encodedJwtComponents,"string[] encodedJwtComponents = check getJwtComponents(jwt);"
header,"Header header = check getHeader(encodedJwtComponents[0]);"
payload,"Payload payload = check getPayload(encodedJwtComponents[1]);"
jwtComponents,"string[] jwtComponents = re `\.`.split(jwt);"
decodedHeader,"byte[]|Error decodedHeader = decodeBase64Url(encodedHeader);"
result,"string|error result = 'string:fromBytes(decodedHeader);"
jsonHeader,"json|error jsonHeader = result.fromJsonString();"
decodedPayload,"byte[]|Error decodedPayload = decodeBase64Url(encodedPayload);"
result,"string|error result = 'string:fromBytes(decodedPayload);"
jsonPayload,"json|error jsonPayload = result.fromJsonString();"
signature,"byte[]|Error signature = decodeBase64Url(encodedSignature);"
header,"Header header = {};"
keys,"string[] keys = headerMap.keys();"
payload,"Payload payload = {};"
exp,"string exp = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(exp);"
nbf,"string nbf = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(nbf);"
iat,"string iat = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(iat);"
alg,"SigningAlgorithm alg = <SigningAlgorithm>header?.alg;"
validatorSignatureConfig,"ValidatorSignatureConfig? validatorSignatureConfig = validatorConfig?.signatureConfig;"
headerPayloadPart,"string headerPayloadPart = encodedJwtComponents[0] + \".\" + encodedJwtComponents[1];"
assertion,"byte[] assertion = headerPayloadPart.toBytes();"
signature,"byte[] signature = check getJwtSignature(encodedJwtComponents[2]);"
jwksConfig,"var jwksConfig = validatorSignatureConfig?.jwksConfig;"
certFile,"string? certFile = validatorSignatureConfig?.certFile;"
trustStoreConfig,"var trustStoreConfig = validatorSignatureConfig?.trustStoreConfig;"
secret,"string? secret = validatorSignatureConfig?.secret;"
kid,"string? kid = header?.kid;"
url,"string url = <string> jwksConfig?.url;"
clientConfig,"ClientConfiguration clientConfig = <ClientConfiguration> jwksConfig?.clientConfig;"
jwk,"json jwk = check getJwk(kid, url, clientConfig, jwksCache);"
publicKey,"crypto:PublicKey publicKey = check getPublicKeyByJwks(jwk);"
signatureValidation,"boolean signatureValidation = check assertRsaSignature(alg, assertion, signature, publicKey);"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:decodeRsaPublicKeyFromCertFile(certFile);"
trustStore,"crypto:TrustStore trustStore = <crypto:TrustStore> trustStoreConfig?.trustStore;"
certAlias,"string certAlias = <string> trustStoreConfig?.certAlias;"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:decodeRsaPublicKeyFromTrustStore(trustStore, certAlias);"
signatureValidation,"boolean signatureValidation = check assertHmacSignature(alg, assertion, signature, secret);"
sub,"string? sub = validatorConfig?.username;"
iss,"string? iss = validatorConfig?.issuer;"
aud,"string|string[]? aud = validatorConfig?.audience;"
jwtId,"string? jwtId = validatorConfig?.jwtId;"
keyId,"string? keyId = validatorConfig?.keyId;"
customClaims,"map<json>? customClaims = validatorConfig?.customClaims;"
exp,"int? exp = payload?.exp;"
nbf,"int? nbf = payload?.nbf;"
alg,"SigningAlgorithm? alg = header?.alg;"
certificate,"crypto:Certificate? certificate = publicKey?.certificate;"
notBefore,"[int, decimal] notBefore = certificate.notBefore;"
notAfter,"[int, decimal] notAfter = certificate.notAfter;"
modulus,"json|error modulus = jwk.n;"
exponent,"json|error exponent = jwk.e;"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:buildRsaPublicKey(modulus, exponent);"
jwk,"any|cache:Error jwk = jwksCache.get(kid);"
stringResponse,"string|Error stringResponse = getJwksResponse(url, clientConfig);"
jwksArray,"json[] jwksArray = check getJwksArray(stringResponse);"
responseKid,"json|error responseKid = jwk.kid;"
jwks,"json|error jwks = jsonResponse.keys;"
result,"boolean|crypto:Error result = crypto:verifyRsaSha256Signature(assertion, signaturePart, publicKey);"
result,"boolean|crypto:Error result = crypto:verifyRsaSha384Signature(assertion, signaturePart, publicKey);"
result,"boolean|crypto:Error result = crypto:verifyRsaSha512Signature(assertion, signaturePart, publicKey);"
signature,"byte[]|crypto:Error signature = crypto:hmacSha256(assertion, secret.toBytes());"
signature,"byte[]|crypto:Error signature = crypto:hmacSha384(assertion, secret.toBytes());"
signature,"byte[]|crypto:Error signature = crypto:hmacSha512(assertion, secret.toBytes());"
usernamePayload,"string? usernamePayload = payload?.sub;"
issuePayload,"string? issuePayload = payload?.iss;"
audiencePayload,"string|string[]? audiencePayload = payload?.aud;"
jwtIdPayload,"string? jwtIdPayload = payload?.jti;"
keyIdHeader,"string? keyIdHeader = header?.kid;"
customClaimPayload,"json customClaimPayload = payload[key].toJson();"
customClaimConfig,"json customClaimConfig = customClaims[key];"
values,"string[] values = [];"
message,"readonly & websubhub:UpdateMessage? message = dequeue(topic);"
expiaryTime,"time:Utc expiaryTime = time:utcAddSeconds(time:utcNow(), timeout);"
payload,"string payload = generateResponsePayload(hubMode, messageBody, reason);"
payload,"string payload = string `${HUB_MODE}=${hubMode}`;"
payload,"string payload = \"\";"
responseHeaders,"map<string|string[]> responseHeaders = {};"
headers,"string[]|error headers = response.getHeaders(header);"
queryParams,"string[] queryParams = re `&`.split(payload);"
index,"int? index = query.indexOf(\"=\");"
name,"string name = query.substring(0, index);"
size,"int size = query.length();"
value,"string value = query.substring(index + 1, size);"
clientEp,"http:Client|error clientEp = new (url, config);"
contentType,"string contentType = retrieveContentType(message.contentType, message.content);"
payload,"json|xml|byte[] payload = retrieveRequestPayload(contentType, message.content);"
result,"error? result = request.setContentType(contentType);"
secret,"string? secret = self.secret;"
hash,"byte[]|error hash = generateSignature(secret, payload);"
response,"http:Response|error response = self.httpClient->post(\"\", request);"
errorMsg,"string errorMsg = string `Content distribution failed for topic [${self.topic}]`;"
messageBody,"map<string> messageBody = <map<string>>payload;"
keyArr,"byte[] keyArr = 'key.toBytes();"
inputArr,"byte[] inputArr = payload.toBytes();"
inputArr,"byte[] inputArr = payload.toString().toBytes();"
inputArr,"byte[] inputArr = payload.toJsonString().toBytes();"
status,"int status = response.statusCode;"
responseContentType,"string & readonly responseContentType = response.getContentType();"
responseHeaders,"map<string|string[]> responseHeaders = getHeaders(response);"
responsePayload,"string|byte[]|json|xml|map<string>? responsePayload = retrieveResponseBody(response, responseContentType);"
errorMsg,"string errorMsg = string `Subscription to topic [${topic}] is terminated by the subscriber`;"
errorMsg,"string errorMsg = \"Error occurred distributing updated content\";"
content,"var content = subscriberResponse.getJsonPayload();"
content,"var content = subscriberResponse.getXmlPayload();"
content,"var content = subscriberResponse.getTextPayload();"
content,"var content = subscriberResponse.getBinaryPayload();"
payload,"string & readonly payload = check req.getTextPayload();"
samplePayload,"json|xml|string|byte[]? samplePayload = ();"
resp,"http:Response resp = new;"
payload,"map<string[]> payload = req.getQueryParams();"
hubMode,"string[] hubMode = <string[]> payload[\"hub.mode\"];"
challengeArray,"string[] challengeArray = <string[]> payload[\"hub.challenge\"];"
retrievedResponseHeaders,"map<string|string[]> retrievedResponseHeaders = getHeaders(response);"
isSuccess,"boolean isSuccess = check hasAllHeaders(retrievedResponseHeaders);"
retrievedResponse,"http:Response retrievedResponse = check headerRetrievalTestingClient->post(\"/addHeaders\", request);"
retrievedResponseHeaders,"map<string|string[]> retrievedResponseHeaders = getHeaders(retrievedResponse);"
retrievedResponse,"http:Response retrievedResponse = check headerRetrievalTestingClient->post(\"/addPayload\", request);"
responseBody,"string|byte[]|json|xml|map<string>? responseBody = retrieveResponseBody(retrievedResponse, retrievedResponse.getContentType());"
expectedPayload,"json expectedPayload = { \"message\": \"This is a test message\" };"
expectedPayload,"xml expectedPayload = xml `<content><message>This is a test message</message></content>`;"
expectedPayload,"byte[] expectedPayload = \"This is a test message\".toBytes();"
message,"map<string> message = { \"query1\": \"value1\", \"query2\": \"value2\" };"
generatedQuery,"string generatedQuery = generateResponsePayload(\"denied\", message, \"reason1\");"
generatedQuery,"string generatedQuery = generateResponsePayload(\"denied\", message, ());"
generatedQuery,"string generatedQuery = retrieveTextPayloadForFormUrlEncodedMessage(message);"
message,"map<string> message = { \"query1\": \"value1\", \"query2\": \"value2\", \"query3\": \"value3\" };"
generatedResponseBody,"map<string> generatedResponseBody = getFormData(\"query1=value1&query2=value2&query3=value3\");"
retrievedValue,"string|string[] retrievedValue = retrievedHeaders.get(header);"
httpsConfig,"http:ClientConfiguration httpsConfig = { secureSocket: { cert: { path: \"tests/resources/ballerinaTruststore.p12\", password: \"ballerina\" } } };"
clientEp,"var clientEp = retrieveHttpClient(\"https: test:assertTrue(clientEp is http:Client);"
params,"[string, string?][] params = [ [\"key1\", \"val1\"], [\"key2\", \"val2\"] ];"
res,"http:Response res = check sendNotification(\"http:"
payload,"string payload = check res.getTextPayload();"
hubLeaseSeconds,"var hubLeaseSeconds = params.removeIfHasKey(HUB_LEASE_SECONDS);"
retrievedLeaseSeconds,"var retrievedLeaseSeconds = 'int:fromString(hubLeaseSeconds);"
response,"http:Response response = new;"
result,"SubscriptionAccepted|Redirect|error result = adaptor.callOnSubscriptionMethod(message, headers);"
errorDetails,"CommonResponse errorDetails = result.detail();"
errorDetails,"CommonResponse errorDetails = result is InternalSubscriptionError ? result.detail() : INTERNAL_SUBSCRIPTION_ERROR.detail();"
validationResult,"error? validationResult = validateSubscription(subscriptionValidationMethodAvailable, message, headers, adaptor);"
params,"[string, string?][] params = [ [HUB_MODE, MODE_DENIED], [HUB_TOPIC, message.hubTopic], [HUB_REASON, validationResult.message()] ];"
challenge,"string challenge = uuid:createType4AsString();"
params,"[string, string?][] params = [ [HUB_MODE, MODE_SUBSCRIBE], [HUB_TOPIC, message.hubTopic], [HUB_CHALLENGE, challenge], [HUB_LEASE_SECONDS, message.hubLeaseSeconds] ];"
subscriberResponse,"http:Response subscriberResponse = check sendNotification(message.hubCallback, params, config);"
respStringPayload,"string respStringPayload = check subscriberResponse.getTextPayload();"
verifiedMessage,"VerifiedSubscription verifiedMessage = { hub: message.hub, hubMode: message.hubMode, hubCallback: message.hubCallback, hubTopic: message.hubTopic, hubLeaseSeconds: message.hubLeaseSeconds, hubSecret: message.hubSecret };"
topic,"string topic = check retrieveQueryParameter(params, HUB_TOPIC);"
hubCallback,"string hubCallback = check retrieveQueryParameter(params, HUB_CALLBACK);"
message,"Unsubscription message = { hubMode: MODE_UNSUBSCRIBE, hubCallback: hubCallback, hubTopic: topic, hubSecret: params.removeIfHasKey(HUB_SECRET) };"
result,"UnsubscriptionAccepted|error result = adaptor.callOnUnsubscriptionMethod(message, headers);"
errorDetails,"CommonResponse errorDetails = result is InternalSubscriptionError ? result.detail() : INTERNAL_UNSUBSCRIPTION_ERROR.detail();"
validationResult,"error? validationResult = validateUnsubscription(unsubscriptionValidationMethodAvailable, message, headers, adaptor);"
params,"[string, string?][] params = [ [HUB_MODE, MODE_UNSUBSCRIBE], [HUB_TOPIC, message.hubTopic], [HUB_CHALLENGE, challenge] ];"
verifiedMessage,"VerifiedUnsubscription verifiedMessage = { hubMode: message.hubMode, hubCallback: message.hubCallback, hubTopic: message.hubTopic, hubSecret: message.hubSecret };"
message,"string message = string `Unknown type \"${argumentTypeName}\".`;"
message,"string message = string `Variable \"$${variableName}\" is not defined.`;"
inputValue,"__InputValue? inputValue = getInputValueFromArray(inputValues, argumentNode.getName());"
inputFieldValues,"__InputValue[] inputFieldValues = [];"
inputFieldType,"__Type? inputFieldType = getOfType(inputValue.'type);"
inputFieldValues,"__InputValue[]? inputFieldValues = inputFieldType?.inputFields;"
value,"parser:ArgumentValue[] value = [];"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argField);"
variableName,"string variableName = <string>argumentNode.getVariableName();"
defaultValue,"parser:ArgumentNode? defaultValue = variable.getDefaultValue();"
value,"json value = self.variables.get(variableName);"
hasInvalidValue,"boolean hasInvalidValue = self.hasInvalidDefaultValue(defaultValue, variableType);"
message,"string message = getInvalidDefaultValueError(variableName, variable.getTypeName(), defaultValue);"
location,"parser:Location location = argumentNode.getLocation();"
message,"string message = string `Variable \"$${variableName}\" of required type ${variable.getTypeName()} was `+ string `not provided.`;"
memberType,"__Type memberType = getListMemberTypeFromType(variableType);"
members,"parser:ArgumentValue[] members = <parser:ArgumentValue[]>defaultValue.getValue();"
member,"parser:ArgumentValue member = members[i];"
hasInvalidValue,"boolean hasInvalidValue = self.hasInvalidDefaultValue(member, memberType);"
listError,"string listError = string `${getListElementError(self.argumentPath)}`;"
message,"string message = getInvalidDefaultValueError(listError, getTypeNameFromType(memberType), member);"
message,"string message = getInvalidDefaultValueError(listError, getTypeNameFromType(variableType), defaultValue);"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argument);"
invalidValue,"string invalidValue = value is () ? \"null\": value.toString();"
message,"string message = string `Variable ${<string> modifiedArgNode.getVariableName()} expected value of type ` + string `\"${variableTypeName}\", found ${invalidValue}`;"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argNode);"
inputValue,"__InputValue? inputValue = getInputValueFromArray(inputValues, modifiedArgNode.getName());"
message,"string message = string `Variable \"${<string>modifiedArgNode.getVariableName()}\" of type `+ string `\"${variable.getTypeName()}\" used in position expecting type `+ string `\"${getTypeNameFromType(inputValue.'type)}\".`;"
wrapperType,"__Type wrapperType = { kind: NON_NULL };"
ofTypeName,"string ofTypeName = typeName.substring(0, typeName.length() - 1);"
ofType,"__Type? ofType;"
wrapperType,"__Type wrapperType = { kind: LIST };"
ofTypeName,"string ofTypeName = typeName.substring(1, typeName.length() - 1);"
isDefinedDirective,"boolean isDefinedDirective = false;"
previouslyModifiedNode,"parser:ArgumentNode previouslyModifiedNode = self.nodeModifierContext.getModifiedArgumentNode(originalNode);"
newModifiedNode,"parser:ArgumentNode newModifiedNode = previouslyModifiedNode.modifyWith(kind, value, valueLocation, isVarDef, variableValue, containsInvalidValue);"
value,"value:Cloneable|isolated object {} value = self.attributes.get('key);"
value,"value:Cloneable|isolated object {} value = self.attributes.remove('key);"
errors,"readonly & ErrorDetail[] errors = errs.cloneReadOnly();"
engine,"Engine? engine = self.getEngine();"
interceptors,"(readonly & Interceptor)[] interceptors = engine.getInterceptors();"
next,"(readonly & Interceptor) next = interceptors[self.getInterceptorCount()];"
nextFieldInterceptor,"int nextFieldInterceptor = self.getInterceptorCount() - engine.getInterceptors().length();"
next,"readonly & Interceptor next = 'field.getFieldInterceptors()[nextFieldInterceptor];"
clonedContext,"Context clonedContext = new(self.attributes, self.engine, self.nextInterceptor);"
err,"error? err = wait 'future;"
path,"string[] path = self.getSelectionPathFromData(data);"
errorDetail,"ErrorDetail errorDetail = { message: err.message(), locations: [selection.getLocation()], path: path.clone() };"
result,"any|error result;"
schema,"__Schema schema;"
engine,"Engine engine;"
context,"Context context;"
'field,"Field 'field = getFieldObject(fieldNode, operationType, schema, engine, result);"
clonedContext,"Context clonedContext = context.cloneWithoutErrors();"
resolvedResult,"anydata resolvedResult = engine.resolve(clonedContext, 'field);"
dataMap,"map<anydata> dataMap = <map<anydata>>data;"
path,"string[] path = <string[]>dataMap[PATH];"
result,"Acknowledgement|error? result = adaptor.callOnEventNotificationMethod(message, request);"
errorDetails,"var errorDetails = result.detail();"
responseError,"http:ListenerError? responseError = caller->respond(response);"
clientEp,"http:Client|error clientEp = new (url);"
originalRequest,"http:Request originalRequest = retrieveHttpRequest(msg);"
subscriberClientEp,"SubscriptionClient subscriberClientEp = check getSubscriberClient(hub, config?.httpConfig);"
request,"SubscriptionChangeRequest request = retrieveSubscriptionRequest(topic, config, callback);"
response,"SubscriptionChangeResponse response = check subscriberClientEp->subscribe(request);"
subscriptionSuccessMsg,"string subscriptionSuccessMsg = string `Subscription Request successfully sent to Hub[${response.hub}], for Topic[${response.topic}], with Callback [${callback}]`;"
hub,"string hub;"
topic,"string topic;"
resourceDetails,"[string, string]? resourceDetails = check retrieveResourceDetails(config);"
response,"SubscriptionChangeResponse response = check subscriberClientEp->unsubscribe(request);"
subscriptionSuccessMsg,"string subscriptionSuccessMsg = string `Unubscription Request successfully sent to Hub[${response.hub}], for Topic[${response.topic}], with Callback [${callback}]`;"
target,"string|[string, string]? target = serviceConfig?.target;"
discoveryConfig,"var discoveryConfig = serviceConfig?.discoveryConfig;"
expectedMediaTypes,"string?|string[] expectedMediaTypes = discoveryConfig?.accept ?: ();"
expectedLanguageTypes,"string?|string[] expectedLanguageTypes = discoveryConfig?.acceptLanguage ?: ();"
discoveryClient,"DiscoveryService discoveryClient = check new (target, discoveryConfig?.httpConfig);"
resourceDetails,"[string, string] resourceDetails = check discoveryClient->discoverResourceUrls(expectedMediaTypes, expectedLanguageTypes);"
linkHeaders,"string[] linkHeaders = [];"
hubIndex,"int hubIndex = 0;"
hubs,"string[] hubs = [];"
topic,"string topic = \"\";"
linkHeaderConstituents,"string[] linkHeaderConstituents = [];"
linkConstituents,"string[] linkConstituents = re `;`.split(link);"
url,"string url = linkConstituents[0].trim();"
tempIntValue,"int|error tempIntValue = int:fromString(decodedValueStr);"
tempFloatValue,"float|error tempFloatValue = float:fromString(decodedValueStr);"
message,"string message = string `Invalid value: \"${value}\" for the search parameter: ${definition.name}`;"
diagMsg,"string diagMsg = string `Int or Float value is expected for the search parameter : ${definition.name}`;"
tempIntValue,"int|error tempIntValue = value.ensureType();"
tempFloatValue,"float|error tempFloatValue = value.ensureType();"
message,"string message = string `Invalid value: \"${value.toString()}\" for the search parameter: ${definition.name}`;"
sParameter,"readonly & NumberSearchParameter sParameter = { modifier: modifier, value: decodedValue, prefix: prefix };"
split,"string[] split = regex:split(value.trim(), \"\\|\");"
system,"string? system = ();"
code,"string? code = ();"
tokens,"int tokens = split.length();"
token,"readonly & TokenSearchParameter token = { modifier: modifier, system: system, code: code };"
message,"string message = string `Unsupported type : \"${(typeof value).toBalString()}\" for the search parameter: ${definition.name}`;"
civilTime,"time:Civil|error civilTime = iso8601toCivil(decodedValue);"
dateParam,"readonly & DateSearchParameter dateParam = { prefix: prefix, modifier: modifier, value: civilTime.cloneReadOnly() };"
message,"string message = string `Error occurred while parsing search parameter : \"${definition.name}\" with value : \"${value.toBalString()}}\"`;"
diagMsg,"string diagMsg = civilTime.message();"
diagMsg,"string diagMsg = string `Unexpected type for the parameter value : ${(typeof value).toBalString()}`;"
refParam,"readonly & ReferenceSearchParameter refParam = { resourceType: (), id: value, modifier: modifier, url: () };"
splitValues,"string[] splitValues = regex:split(value, \"/\");"
refParam,"readonly & ReferenceSearchParameter refParam = { resourceType: splitValues[0], id: splitValues[1], modifier: modifier, url: () };"
message,"string message = string `Unknown/Unsupported resource type : ${splitValues[0]}`;"
diagMsg,"string diagMsg = string `Search parameter : ${definition.name} of type Reference. Detected format : [parameter]=[type]/[id], but unknown/unsupported type`;"
matches,"boolean matches = regex:matches(value, CANONICAL_REGEX);"
refParam,"readonly & ReferenceSearchParameter refParam = { resourceType: (), id: (), modifier: modifier, url: value };"
valueComponents,"string[] valueComponents = regex:split(strippedValue, \"\\|\");"
prefix,"Prefix? prefix = tempPrefix;"
number,"string number;"
message,"string message = string `Invalid value for the search parameter : \"${definition.name}\"`;"
diagMsg,"string diagMsg = string `Number component missing in the value : ${value}. Expected format is [parameter]=[prefix][number]|[system]|[code]`;"
numberResult,"int|float numberResult = check stringToNumber(number);"
validateModifierResult,"FHIRValidationError? validateModifierResult = validateModifier(modifier, <FHIRSearchParameterDefinition>definition);"
quantityParam,"readonly & QuantitySearchParameter quantityParam = { prefix: prefix, number: numberResult, system: system, code: code, modifier: () };"
uriParam,"readonly & URISearchParameter uriParam = { modifier: modifier, uri: value };"
compositeParam,"readonly & CompositeSearchParameter compositeParam = { modifier: modifier, value: value };"
specialParam,"readonly & SpecialSearchParameter specialParam = { modifier: modifier, value: value };"
tempIntValue,"int|error tempIntValue = int:fromString(value);"
tempFloatValue,"float|error tempFloatValue = float:fromString(value);"
message,"string message = \"Failed to parse to an Integer or Float\";"
diagMsg,"string diagMsg = string `Value : \"${value}\" cannot be parsed to an Integer or Float`;"
paramTypes,"string[] & readonly paramTypes = SEARCH_PARAM_MODIFIER_MAP.modifierTypeMapping.get(modifier);"
message,"string message = \"Incompatible search parameter modifier\";"
diagMsg,"string diagMsg = string `The modifier \"${modifier}\" is not compatible against parameter (\"${definition.name}\") of type : ${definition.'type}`;"
message,"string message = \"Unknown search parameter modifier\";"
diagMsg,"string diagMsg = string `Incompatible modifier : \"${modifier}\" for search parameter : \"${definition.name}\"`;"
message,"string message = \"Invalid search parameter modifier\";"
diagMsg,"string diagMsg = string `Modifier : \"${modifier}\" of search parameter : \"${definition.name}\" must be a valid supported FHIR resource type`;"
resultParam,"RequestSearchParameter resultParam = check createRequestSearchParameter(definition, query.modifier, query.values[0]);"
numberParam,"NumberSearchParameter|error numberParam = resultParam.typedValue.ensureType();"
message,"string message = string `Invalid value for the search parameter: ${definition.name}`;"
diagMsg,"string diagMsg = string `The value: \"${query.values[0]}\" is invalid for the search parameter: ${definition.name}. It Expect to be an Integer.`;"
profileStr,"string profileStr = query.values[0];"
profiles,"string[] & readonly profiles = apiConfig.profiles;"
indexOf,"int? indexOf = profiles.indexOf(profileStr);"
message,"string message = string `Unsupported profile: \"${profileStr}\" for the resource: ${apiConfig.resourceType}. Supported profiles are: ${apiConfig.profiles.toString()}`;"
param,"URISearchParameter & readonly param = { modifier: (), uri: profileStr };"
wrappedParam,"RequestSearchParameter wrappedParam = createSearchParameterWrapper(definition.name, URI, profileStr, param);"
paramSplitResult,"string[] paramSplitResult = regex:split(paramName, \":\");"
qParamName,"string qParamName = paramSplitResult[0];"
modifier,"FHIRSearchParameterModifier|string? modifier = ();"
msg,"string msg = string `Unknown search parameter modifier : ${paramSplitResult[1]}`;"
prefixStr,"string prefixStr = value.substring(0, 2);"
valueStr,"string valueStr = value.substring(2, value.length());"
prefix,"Prefix prefix;"
paramNames,"string[] paramNames = [];"
jwtInfo,"readonly & JWT jwtInfo = { header: header.cloneReadOnly(), payload: payload.cloneReadOnly() };"
idp_claims,"json idp_claims = <json>payload.get(IDP_CLAIMS);"
claimList,"map<string>|error claimList = idp_claims.fromJsonWithType();"
message,"string message = \"IDP claims are not available\";"
scopeslist,"string[] scopeslist = regex:split(<string>payload.get(SCOPES), SPACE_CHARACTER);"
userName,"json|error userName = idp_claims.username;"
message,"string message = \"Username is not available\";"
fhirUserInfo,"readonly & FHIRUser fhirUserInfo = { userID: <string & readonly>userName.toString(), scopes: <string[] & readonly>scopeslist.cloneReadOnly(), claims: <map<string> & readonly>claimList.cloneReadOnly() };"
message,"string message = \"Error occured in JWT decode\";"
headers,"map<string[]> headers = {};"
headerResult,"string[]|http:HeaderNotFoundError headerResult = request.getHeaders(headerName);"
metadataHeaders,"map<string> metadataHeaders = {};"
headerNames,"string[] headerNames = response.getHeaderNames();"
fileMetadataResult,"FileMetadataResult fileMetadataResult = { metadata: getMetaDataHeaders(response), eTag: getHeaderFromResponse(response, ETAG), lastModified: getHeaderFromResponse(response, LAST_MODIFIED), responseHeaders: getResponseHeaders(response) };"
jsonResult,"json|xmldata:Error jsonResult = xmldata:toJson(input);"
properties,"Properties properties = {};"
cleanedStringXMLObject,"string cleanedStringXMLObject = regex:replaceAll(xmlObject.toString(), QUOTATION_MARK, EMPTY_STRING);"
statusCode,"int statusCode = response.statusCode;"
errorCode,"string errorCode = \"undefined\";"
message,"string message = \"unknown\";"
xmlResponse,"xml xmlResponse = check response.getXmlPayload();"
headerMap,"map<string> headerMap = {};"
headers,"map<string> headers = getHeaderMapFromResponse(response);"
responseHeaders,"ResponseHeaders responseHeaders = { Date: \"\", x\-ms\-request\-id: \"\", x\-ms\-version: \"\" };"
value,"var value = response.getHeader(headerName);"
value,"var value = request.getHeader(headerName);"
headerNames,"string[] headerNames = request.getHeaderNames();"
result,"string result = EMPTY_STRING;"
path,"string path = EMPTY_STRING;"
headerMap,"map<string> headerMap = populateHeaderMapFromRequest(request);"
sharedKeySignature,"string|error sharedKeySignature = storage_utils:generateSharedKeySignature(accountName, accessKey, verb, resourceString, uriParameters, headerMap);"
zoneId,"var zoneId = getZoneId(java:fromString(GMT));"
allHeaderNames,"string[] allHeaderNames = array:sort(headers.keys());"
allURIParams,"string[] allURIParams = array:sort(uriParameters.keys());"
canonicalozedHeaders,"string canonicalozedHeaders = generateCanonicalizedHeadersString(headers);"
uriParameterString,"string uriParameterString = generateUriParamStringForSharedKey(uriParameters);"
canonicalizedResources,"string canonicalizedResources = FORWARD_SLASH_SYMBOL + accountName + FORWARD_SLASH_SYMBOL + resourcePath + uriParameterString;"
contentEncoding,"string contentEncoding = EMPTY_STRING;"
contentLanguage,"string contentLanguage = EMPTY_STRING;"
contentLength,"string contentLength = EMPTY_STRING;"
contentMD5,"string contentMD5 = EMPTY_STRING;"
contentType,"string contentType = EMPTY_STRING;"
date,"string date = EMPTY_STRING;"
ifModifiedSince,"string ifModifiedSince = EMPTY_STRING;"
ifMatch,"string ifMatch = EMPTY_STRING;"
ifNoneMatch,"string ifNoneMatch = EMPTY_STRING;"
ifUnmodifiedSince,"string ifUnmodifiedSince = EMPTY_STRING;"
range,"string range = EMPTY_STRING;"
stringToSign,"string stringToSign = verb.toUpperAscii() + NEW_LINE + contentEncoding + NEW_LINE + contentLanguage + NEW_LINE + contentLength + NEW_LINE + contentMD5 + NEW_LINE + contentType + NEW_LINE + date + NEW_LINE + ifModifiedSince + NEW_LINE + ifMatch + NEW_LINE + ifNoneMatch + NEW_LINE + ifUnmodifiedSince + NEW_LINE + range + NEW_LINE + canonicalozedHeaders + canonicalizedResources;"
attributeName,"string attributeName = getAttributeName(key);"
xmlResponse,"var xmlResponse = httpResponse.getXmlPayload();"
xmlResponseErrorCode,"string xmlResponseErrorCode = httpResponse.statusCode.toString();"
responseErrorMessage,"string responseErrorMessage = (xmlResponse/<ns:'error>/<ns:message>/*).toString();"
errorMsg,"string errorMsg = STATUS_CODE + COLON_SYMBOL + xmlResponseErrorCode + SEMICOLON_SYMBOL + WHITE_SPACE + MESSAGE + COLON_SYMBOL + WHITE_SPACE + responseErrorMessage;"
tagNumber,"int tagNumber = 1;"
attributeNumber,"int attributeNumber = 1;"
firstLetter,"string firstLetter = attribute.substring(0, 1);"
otherLetters,"string otherLetters = attribute.substring(1);"
upperCaseFirstLetter,"string upperCaseFirstLetter = firstLetter.toUpperAscii();"
attributeName,"string attributeName = upperCaseFirstLetter + otherLetters;"
rec,"handle rec = java:fromString(str);"
del,"handle del = java:fromString(delimeter);"
arr,"handle arr = split(rec, del);"
arrEle,"handle arrEle = jarrays:get(arr, arrIndex);"
currentTime,"[int, decimal] & readonly currentTime = time:utcNow();"
amzDate,"string|error amzDate = utcToString(currentTime, ISO8601_BASIC_DATE_FORMAT);"
dateStamp,"string|error dateStamp = utcToString(currentTime, SHORT_DATE_FORMAT);"
contentType,"string contentType = \"application/x-www-form-urlencoded\";"
requestParameters,"string requestParameters = payload;"
canonicalQuerystring,"string canonicalQuerystring = EMPTY_STRING;"
canonicalHeaders,"string canonicalHeaders = \"content-type:\" + contentType + NEW_LINE + \"host:\" + self.host + NEW_LINE + \"x-amz-date:\" + amzDate + NEW_LINE + \"x-amz-target:\" + amzTarget + NEW_LINE;"
signedHeaders,"string signedHeaders = \"content-type;host;x-amz-date;x-amz-target\";"
payloadHash,"string payloadHash = array:toBase16(crypto:hashSha256(requestParameters.toBytes())).toLowerAscii();"
canonicalRequest,"string canonicalRequest = POST + NEW_LINE + canonicalUri + NEW_LINE + canonicalQuerystring + NEW_LINE + canonicalHeaders + NEW_LINE + signedHeaders + NEW_LINE + payloadHash;"
algorithm,"string algorithm = \"AWS4-HMAC-SHA256\";"
credentialScope,"string credentialScope = dateStamp + FORWARD_SLASH + self.region + FORWARD_SLASH + SQS_SERVICE_NAME + FORWARD_SLASH + \"aws4_request\";"
stringToSign,"string stringToSign = algorithm + NEW_LINE + amzDate + NEW_LINE + credentialScope + NEW_LINE + array:toBase16(crypto:hashSha256(canonicalRequest.toBytes())).toLowerAscii();"
signingKey,"byte[] signingKey = check self.getSignatureKey(self.secretKey, dateStamp, self.region, SQS_SERVICE_NAME);"
signature,"string signature = array:toBase16(check crypto:hmacSha256(stringToSign .toBytes(), signingKey)).toLowerAscii();"
authorizationHeader,"string authorizationHeader = algorithm + \" \" + \"Credential=\" + self.accessKey + FORWARD_SLASH + credentialScope + \", \" + \"SignedHeaders=\" + signedHeaders + \", \" + \"Signature=\" + signature;"
msgBody,"string msgBody = requestParameters;"
awskey,"string awskey = (\"AWS4\" + secretKey);"
kDate,"byte[] kDate = check self.sign(awskey.toBytes(), datestamp);"
kRegion,"byte[] kRegion = check self.sign(kDate, region);"
kService,"byte[] kService = check self.sign(kRegion, serviceName);"
kSigning,"byte[] kSigning = check self.sign(kService, \"aws4_request\");"
resXml,"[string, MessageAttributeValue]|DataMappingError resXml = xmlToInboundMessageMessageAttribute(msgAttributes);"
msgAttributeName,"string msgAttributeName = (msgAttribute/<ns:Name>/*).toString();"
msgAttributeValue,"xml msgAttributeValue = msgAttribute/<ns:Value>;"
binaryListValues,"string[] binaryListValues;"
stringListValues,"string[] stringListValues;"
strListVals,"[string[], string[]]|error strListVals = xmlMessageAttributeValueToListValues(msgAttributeValue);"
messageAttributeValue,"MessageAttributeValue messageAttributeValue = { binaryListValues: binaryListValues, binaryValue: (msgAttributeValue/<ns:BinaryValue>/*).toString(), dataType: (msgAttributeValue/<ns:DataType>/*).toString(), stringListValues: stringListValues, stringValue: (msgAttributeValue/<ns:StringValue>/*).toString() };"
binaryListValues,"string[] binaryListValues = [];"
stringListValues,"string[] stringListValues = [];"
topElement,"xmllib:Element topElement = <xmllib:Element> response;"
topElementName,"string topElementName = topElement.getName();"
readableByteChannel,"io:ReadableByteChannel|error readableByteChannel = io:openReadableFile(path);"
readableChannel,"io:ReadableCharacterChannel readableChannel = new(readableByteChannel, \"UTF8\");"
result,"var result = readableChannel.readJson();"
err,"FileReadFailed? err = closeReadableChannel(readableChannel);"
result,"var result = readableChannel.close();"
stringidrecord,"StringIdRecord stringidrecord = stringidrecordsTable.get(id);"
intidrecord,"IntIdRecord intidrecord = intidrecordsTable.get(id);"
keys,"float[] keys = [];"
floatidrecord,"FloatIdRecord floatidrecord = floatidrecordsTable.get(id);"
keys,"decimal[] keys = [];"
decimalidrecord,"DecimalIdRecord decimalidrecord = decimalidrecordsTable.get(id);"
keys,"boolean[] keys = [];"
booleanidrecord,"BooleanIdRecord booleanidrecord = booleanidrecordsTable.get(id);"
compositeassociationrecord,"CompositeAssociationRecord compositeassociationrecord = compositeassociationrecordsTable.get(id);"
keys,"[boolean, int, float, decimal, string][] keys = [];"
alltypesidrecord,"AllTypesIdRecord alltypesidrecord = alltypesidrecordsTable.get([booleanType, intType, floatType, decimalType, stringType]);"
alltypesClonedTable,"table<AllTypes> key(id) alltypesClonedTable;"
stringidrecordsClonedTable,"table<StringIdRecord> key(id) stringidrecordsClonedTable;"
intidrecordsClonedTable,"table<IntIdRecord> key(id) intidrecordsClonedTable;"
floatidrecordsClonedTable,"table<FloatIdRecord> key(id) floatidrecordsClonedTable;"
decimalidrecordsClonedTable,"table<DecimalIdRecord> key(id) decimalidrecordsClonedTable;"
booleanidrecordsClonedTable,"table<BooleanIdRecord> key(id) booleanidrecordsClonedTable;"
compositeassociationrecordsClonedTable,"table<CompositeAssociationRecord> key(id) compositeassociationrecordsClonedTable;"
alltypesidrecordsClonedTable,"table<AllTypesIdRecord> key(booleanType, intType, floatType, decimalType, stringType) alltypesidrecordsClonedTable;"
queryString,"string queryString = \"\";"
res,"http:Response|http:ClientError res = sourceEp->get(SEARCH + queryString);"
fhirError,"r4:FHIRError fhirError = r4:createFHIRError(\"Error occured when calling the source system.\", r4:CODE_SEVERITY_ERROR, r4:TRANSIENT_EXCEPTION);"
payload,"json|error payload = res.getJsonPayload();"
fhirError,"r4:FHIRError fhirError = r4:createFHIRError(\"Unable to extract JSON payload from the source response.\", r4:CODE_SEVERITY_ERROR, r4:TRANSIENT_EXCEPTION);"
payloadArray,"json[] payloadArray = <json[]>payload;"
fhirResources,"Patient[] fhirResources = [];"
fhirResource,"r4:Patient|error fhirResource = p.cloneWithType(r4:Patient);"
fhirError,"r4:FHIRError fhirError = r4:createFHIRError(\"Did not get a FHIR Resource from source.\", r4:CODE_SEVERITY_ERROR, r4:TRANSIENT_EXCEPTION);"
fhirError,"r4:FHIRError fhirError = r4:createFHIRError(\"Did not get a JSON[] from the source.\", r4:CODE_SEVERITY_ERROR, r4:TRANSIENT_EXCEPTION);"
fhirError,"r4:FHIRError fhirError = r4:createFHIRError(\"Not implemented\", r4:CODE_SEVERITY_ERROR, r4:TRANSIENT_EXCEPTION, httpStatusCode = 415);"
fhirResources,"Practitioner[] fhirResources = [];"
fhirResource,"r4:Practitioner|error fhirResource = p.cloneWithType(r4:Practitioner);"
fhirResources,"Encounter[] fhirResources = [];"
fhirResource,"r4:Encounter|error fhirResource = p.cloneWithType(r4:Encounter);"
fhirResources,"Organization[] fhirResources = [];"
fhirResource,"r4:Organization|error fhirResource = p.cloneWithType(r4:Organization);"
fhirResources,"Observation[] fhirResources = [];"
fhirResource,"r4:Observation|error fhirResource = p.cloneWithType(r4:Observation);"
fhirResources,"DiagnosticReport[] fhirResources = [];"
fhirResource,"r4:DiagnosticReport|error fhirResource = p.cloneWithType(r4:DiagnosticReport);"
fhirResources,"ServiceRequest[] fhirResources = [];"
fhirResource,"r4:ServiceRequest|error fhirResource = p.cloneWithType(r4:ServiceRequest);"
arr,"anydata[] arr = val;"
typeMap,"map<anydata> typeMap = compositeType;"
primitiveVal,"hl7v2:PrimitiveType primitiveVal = {value: <any[]>[key, typeMap]};"
entries,"[string, anydata][] entries = segment.entries().toArray();"
val,"anydata val;"
typeResult,"[string, anydata] typeResult = entries[fieldNum];"
segmentMap,"map<anydata> segmentMap = segment;"
primitiveVal,"hl7v2:PrimitiveType primitiveVal = {value: <any[]>[key, segmentMap]};"
segmentDefinition,"hl7v2:Hl7SegmentDefinitionRecord? segmentDefinition = (typeof segment).@hl7v2:SegmentDefinition;"
elementDefinitions,"map<hl7v2:Hl7TypeDefinitionRecord> elementDefinitions = segmentDefinition.fields ?: {};"
fieldDefinition,"hl7v2:Hl7TypeDefinitionRecord fieldDefinition = elementDefinitions.get(fieldKey);"
maxReps,"int? maxReps = fieldDefinition.maxReps;"
innerSegments,"[string, anydata][] innerSegments = segment.entries().toArray();"
innerSegmentKey,"string innerSegmentKey;"
innerSegment,"anydata innerSegment;"
encodedSegment,"string encodedSegment = self.encodeSegment(innerSegment);"
encodedSegment,"string encodedSegment = self.encodeSegment(childSegment);"
encodedSegment,"string encodedSegment = self.encodeSegment(segment);"
err,"hl7v2:HL7Error err = error hl7v2:HL7Error(hl7v2:HL7_V2_PARSER_ERROR, message = \"Invalid segment is provided with segment name:\" + key);"
encodedString,"string encodedString = \"\";"
isMSHSegment,"boolean isMSHSegment = isMshSegment(segment.name);"
numOfFields,"int numOfFields = entries.length();"
encodedTypeStr,"string encodedTypeStr = stripExtraDelimeters(self.encodeType(dataType, self.encodingCharacters.getComponentSeparator(), \"\"), self.encodingCharacters.getComponentSeparator());"
encodedTypeStr,"string encodedTypeStr = stripExtraDelimeters(self.encodeType(val, self.encodingCharacters.getComponentSeparator(), \"\"), self.encodingCharacters.getComponentSeparator());"
updatedEncodedTypeStr,"string updatedEncodedTypeStr = encodedTypeStr;"
compositeType,"hl7v2:CompositeType compositeType = <hl7v2:CompositeType>typ;"
components,"[string, anydata][] components = compositeType.entries().toArray();"
compKey,"string compKey;"
component,"anydata component;"
subComponents,"[string, anydata][] subComponents = component.entries().toArray();"
subCompKey,"string subCompKey;"
subComponent,"anydata subComponent;"
bundleEntries,"r4:BundleEntry[] bundleEntries = segmentToFhir(segment.name, segment, customMapper);"
bundleEntries,"r4:BundleEntry[] bundleEntries = segmentToFhir(segmentElem.name, segmentElem, customMapper);"
segmentComponent,"anydata segmentComponent;"
bundleEntries,"r4:BundleEntry[] bundleEntries = segmentToFhir(segmentComponent.name, segmentComponent, customMapper);"
week,"int week = 60 * 60 * 24 * 7;"
expiry,"int expiry = epochSeconds + week;"
stringToSign,"string stringToSign = checkpanic url:encode(config.resourceUri, UTF8_URL_ENCODING) + \"\n\" + expiry.toString();"
output,"byte[] output = checkpanic crypto:hmacSha256(stringToSign.toBytes(), config.sasKey.toBytes());"
signature,"string signature = output.toBase64();"
sasToken,"string sasToken = \"SharedAccessSignature sr=\" + checkpanic url:encode(config.resourceUri, UTF8_URL_ENCODING) + \"&sig=\" + checkpanic url:encode(signature, UTF8_URL_ENCODING) + \"&se=\" + expiry.toString() + \"&skn=\" + config.sasKeyName;"
stringUUID,"string? stringUUID = java:toString(createRandomUUID());"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/hello\", message, headers);"
message,"ByeRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"DurationHandler/unaryCall\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.helloWorld/testNoInputOutputStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"myproj.apis.helloWorldWithNestedMessage/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"myproj.apis.helloWorldWithNestedMessage/bye\", message, headers);"
message,"Hello message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"enum_imports.HelloWorld/hello\", message, headers);"
outputStream,"swrappers:BooleanStream outputStream = new swrappers:BooleanStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/hello\", message, headers);"
message,"MainMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService/call\", message, headers);"
message,"message:ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloWorld/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloWorld/hello3\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloWorld/hello2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld/hello\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld/hello4\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld/hello5\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld/hello10\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld/hello11\");"
nextRecord,"record {|message:ResMessage value;|} nextRecord = {value: <message:ResMessage>streamValue.value};"
message,"Msg message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Chat/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Chat/call2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"Chat/call5\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"Chat/call6\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat/call3\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat/call4\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"Chat/call7\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"Chat/call8\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Chat2/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Chat2/call2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"Chat2/call5\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"Chat2/call6\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat2/call3\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat2/call4\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"Chat2/call7\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"Chat2/call8\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RecordStore/getAlbumById\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RecordStore/storeAlbum\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"RecordStore/getTotalValue\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"RecordStore/getAlbums\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"RecordStore/updateAlbums\");"
message,"ParentMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ParentTest/callParent1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"ParentTest/callParent2\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"ParentTest/callParent3\", message, headers);"
outputStream,"ParentMessageStream outputStream = new ParentMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"ParentTest/callParent4\");"
nextRecord,"record {|ParentMessage value;|} nextRecord = {value: <ParentMessage>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ChildTest/callChild1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"ChildTest/callChild2\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"ChildTest/callChild3\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"ChildTest/callChild4\");"
outputStream,"swrappers:FloatStream outputStream = new swrappers:FloatStream(result);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithDependency/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithDependency/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ChildTest/callChild5\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedEnum/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedEnum/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloFooWithNestedEnum/foo\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloFooWithNestedEnum/bar\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/getTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/sendTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/exchangeTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/getGreeting\", message, headers);"
outputStream,"GreetingStream outputStream = new GreetingStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/sendGreeting\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/exchangeGreeting\", message, headers);"
nextRecord,"record {|Greeting value;|} nextRecord = {value: <Greeting>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructHandler/unaryCall\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"StructHandler/clientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"StructHandler/serverStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"StructHandler/bidirectionalStreaming\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructHandler/unaryCall1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructHandler/unaryCall2\", message, headers);"
outputStream,"swrappers:BytesStream outputStream = new swrappers:BytesStream(result);"
message,"MainMessage1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService1/call1\", message, headers);"
message,"messages:Message2 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService1/call2\", message, headers);"
message,"MainMessage2 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService2/call1\", message, headers);"
message,"messages:Message1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService2/call2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloBallerina/hey\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/bye\", message, headers);"
outputStream,"ByeResponseStream outputStream = new ByeResponseStream(result);"
nextRecord,"record {|ByeResponse value;|} nextRecord = {value: <ByeResponse>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"service.helloWorldWithPackage/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"service.helloWorldWithPackage/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"simplePackage.helloWorld/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"simplePackage.helloWorld/hi\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService/call1\", message, headers);"
message,"Message1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MyService/call2\", message, headers);"
outputStream,"swrappers:IntStream outputStream = new swrappers:IntStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"helloWorld/helloWorld\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"helloWorld/helloBallerina\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"helloWorld/helloGrpc\");"
message,"NestedRequestMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithNestedMessage/hello\", message, headers);"
outputStream,"message:ResMessageStream outputStream = new message:ResMessageStream(result);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloBallerina/hi\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloBallerina/hello\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloBallerina/hey\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloBallerina/bye\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithReservedNames/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithReservedNames/bye\", message, headers);"
typeCount,"int typeCount = 0;"
message,"Message2 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallEmptyInput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallEmptyOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallAny\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallDuration\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ServiceWithPredefinedNames/UnaryCallTimestamp\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"ServiceWithPredefinedNames/ClientCallEmptyInput\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"ServiceWithPredefinedNames/ClientCallEmptyOutput\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"ServiceWithPredefinedNames/ServerCallEmptyInput\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"ServiceWithPredefinedNames/ServerCallEmptyOutput\", message, headers);"
outputStream,"EmptyStream outputStream = new EmptyStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"ServiceWithPredefinedNames/BidiCallEmptyInput\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"ServiceWithPredefinedNames/BidiCallEmptyOutput\");"
nextRecord,"record {|Empty value;|} nextRecord = {value: <Empty>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/getTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/sendTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/exchangeTime\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/getGreeting\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/sendGreeting\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/exchangeGreeting\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.helloWorld/testNoInputOutputStruct\", message, headers);"
message,"Message message;"
outputStream,"MessageStream outputStream = new MessageStream(result);"
nextRecord,"record {|Message value;|} nextRecord = {value: <Message>streamValue.value};"
httpResponse,"http:Response|error httpResponse = amazonSimpleDBClient->post(\"/\", request);"
response,"xml|error response = handleResponse(httpResponse);"
zoneId,"var zoneId = getZoneId(java:fromString(\"UTC+05:30\"));"
attributeMap,"map<anydata> attributeMap = <map<anydata>>attributes;"
parameterQuery,"string parameterQuery = buildPayload(parameters);"
errorMsg,"string errorMsg = \"status code\" + \":\" + xmlResponseErrorCode + \";\" + \" \" + \"message\" + \":\" + \" \" + responseErrorMessage;"
xamzDate,"string|error xamzDate = utcToString(currentTime, \"yyyyMMdd'T'HHmmss'Z'\");"
dateStamp,"string|error dateStamp = utcToString(currentTime, \"yyyyMMdd\");"
availableSecurityToken,"string? availableSecurityToken = self.securityToken;"
canonicalHeaders,"string canonicalHeaders = EMPTY_STRING;"
signedHeaders,"string signedHeaders = EMPTY_STRING;"
canonicalRequest,"string canonicalRequest = \"POST\" + \"\n\" + \"/\" + \"\n\" + canonicalQuerystring + \"\n\" + canonicalHeaders + \"\n\" + signedHeaders + \"\n\" + payloadHash;"
credentialScope,"string credentialScope = dateStamp + \"/\" + self.region + \"/\" + \"sns\" + \"/\" + \"aws4_request\";"
stringToSign,"string stringToSign = algorithm + \"\n\" + xamzDate + \"\n\" + credentialScope + \"\n\" + array:toBase16(crypto:hashSha256(canonicalRequest.toBytes())).toLowerAscii();"
signingKey,"byte[] signingKey = check self.calculateSignature(self.secretAccessKey, dateStamp, self.region, \"sns\");"
authorizationHeader,"string authorizationHeader = algorithm + \" \" + \"Credential=\" + self.accessKeyId + \"/\" + credentialScope + \", \" + \"SignedHeaders=\" + signedHeaders + \", \" + \"Signature=\" + signature;"
kSecret,"string kSecret = secretAccessKey;"
kDate,"byte[] kDate = check crypto:hmacSha256(datestamp.toBytes(), (\"AWS4\" + kSecret).toBytes());"
kRegion,"byte[] kRegion = check crypto:hmacSha256(region.toBytes(), kDate);"
kService,"byte[] kService = check crypto:hmacSha256(serviceName.toBytes(), kRegion);"
kSigning,"byte[] kSigning = check crypto:hmacSha256(\"aws4_request\".toBytes(), kService);"
payload,"json payload = {name: worksheetName};"
response,"http:Response response = check self.excelClient->get(path, headers);"
payload,"json payload = check worksheet.cloneWithType(json);"
response,"http:Response response = check self.excelClient->delete(path, headers = headers);"
payload,"json payload = {address: address, hasHeaders: hasHeaders};"
payload,"json payload = check 'table.cloneWithType(json);"
payload,"json payload = {values: values, index: index};"
payload,"json payload = {values: values};"
payload,"map<json> payload = {index: index};"
payload,"json payload = {'type: 'type, sourceData: sourceData, seriesBy: seriesBy};"
payload,"json payload = check chart.cloneWithType(json);"
handledResponse,"map<json> handledResponse = check handleResponse(response);"
payload,"json payload = {sourceData: sourceData, seriesBy: seriesBy};"
response,"http:Response response = check self.excelClient->post(path, payload, headers);"
payload,"json payload = {startCell: startCell, endCell: endCell};"
response,"WorkbookApplication response = check self.excelClient->get(path, headers, targetType = WorkbookApplication);"
payload,"json payload = {calculationType: 'type};"
apple,"json apple = { name: \"apple\", colors: [\"red\", \"green\"], price: 5 };"
mapValue,"map<json> mapValue = <map<json>> apple;"
colors,"json[] colors = <json[]> apple.colors;"
employeeTab,"EmployeeTable employeeTab = table [ {id: 1, name: \"John\", salary: 300.50}, {id: 2, name: \"Bella\", salary: 500.50}, {id: 3, name: \"Peter\", salary: 750.0} ];"
endValue,"int endValue = 10;"
sum,"int sum = 0;"
tmAdd,"time:Time tmAdd = time:addDuration(time, 1, 1, 0, 0, 0, 1, 0);"
tmSub,"time:Time tmSub = time:subtractDuration(time, 1, 1, 0, 0, 0, 1, 0);"
t2,"time:Time t2 = check time:createTime(2017, 3, 28, 23, 42, 45, 554, \"America/Panama\");"
t3,"time:Time t3 = check time:toTimeZone(t2, \"Asia/Colombo\");"
sample,"json sample = { \"employees\": { \"employee\": [ { \"id\": \"1\", \"firstName\": \"Tom\", \"lastName\": \"Cruise\", \"photo\": \"https: }, { \"id\": \"2\", \"firstName\": \"Maria\", \"lastName\": \"Sharapova\", \"photo\": \"https: }, { \"id\": \"3\", \"firstName\": \"James\", \"lastName\": \"Bond\", \"photo\": \"https: } ] } };"
path,"string path = \"./files/sample.csv\";"
result,"var result = writeCsv(<json[]>sample.employees.employee, path);"
latitude,"float latitude;"
longitude,"float longitude;"
returnValue,"[int, int] returnValue = divideBy10(9);"
q,"int q = d / 10;"
r,"int r = d % 10;"
stringStream,"StringStream stringStream = new StringStream(result);"
ep,"grpc:Caller ep = connection;"
err,"grpc:Error? err = ep->send(msg);"
byteChannel,"var byteChannel = io:createReadableChannel(content);"
characterChannel,"io:ReadableCharacterChannel characterChannel = new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");"
str,"var str = characterChannel.read(60);"
closeResult,"var closeResult = socketClient->close();"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"Chat/chat\");"
headerValue,"string headerValue = resHeaders.get(\"server_header_key\") ?: \"none\";"
str,"var str = characterChannel.read(20);"
reply,"string reply = <@untainted>str + \" back\";"
payloadByte,"byte[] payloadByte = reply.toBytes();"
arrayLength,"int arrayLength = payloadByte.length();"
writeResult,"var writeResult = caller->write(payloadByte);"
byteChannel,"var byteChannel = io:createReadableChannel(reply);"
str,"var str = characterChannel.read(25);"
diff,"string diff = \"\";"
actualKeyArray,"string[] actualKeyArray = actualMap.keys();"
count,"int count = 0;"
expected,"anydata expected = expectedMap.get(keyVal);"
actual,"anydata actual = actualMap.get(keyVal);"
diffVal,"string diffVal;"
pf,"_StreamFunction? pf = self.prevFunc;"
pf,"_StreamFunction pf = <_StreamFunction>self.prevFunc;"
f,"function (_Frame _frame) returns _Frame|error? f = self.letFunc;"
pFrame,"_Frame|error? pFrame = pf.process();"
cFrame,"_Frame|error? cFrame = f(pFrame);"
f,"_Frame|error? f = pipelineToJoin.next();"
rhsKeyFuncResult,"any|error rhsKeyFuncResult = rhsKeyFunction(f);"
lhsKF,"function (_Frame _frame) returns any|error lhsKF = self.lhsKeyFunction;"
rhsFramesMap,"_FrameMultiMap rhsFramesMap = self.rhsFramesMap;"
lhsFrame,"_Frame|error? lhsFrame = pf.process();"
joinedFrames,"_Frame[] joinedFrames = [];"
failureAtJoin,"error? failureAtJoin = self.failureAtJoin;"
lhsKFRes,"any|error lhsKFRes = lhsKF(lhsFrame);"
lhsKey,"string lhsKey = (lhsKFRes).toString();"
rhsCandidates,"_Frame[]? rhsCandidates = rhsFramesMap.get(lhsKey);"
rhsFrame,"_Frame rhsFrame = rhsCandidates.shift();"
joinedFrame,"_Frame joinedFrame = {...lhsFrame};"
s,"stream<_Frame> s = <stream<_Frame>>self.joinedFramesStream;"
f,"record {|_Frame value;|}|error? f = s.next();"
rhsCandidates,"_Frame[]? rhsCandidates = self.rhsCandidates;"
lhsFrame,"_Frame|error? lhsFrame = self.lhsFrame;"
nilFrame,"_Frame nilFrame = self.nilFrame;"
lhsKey,"string lhsKey = \"\";"
filterFunc,"function (_Frame _frame) returns boolean|error filterFunc = self.filterFunc;"
filterResult,"boolean|error filterResult = filterFunc(pFrame);"
orderKeyFunc,"function (_Frame _frame) returns error? orderKeyFunc = self.orderKeyFunc;"
f,"_Frame|error? f = pf.process();"
directions,"boolean[] directions = [];"
oTree,"_OrderTreeNode oTree = new;"
res,"error? res = orderKeyFunc(f);"
s,"stream<_Frame> s = <stream<_Frame>>self.orderedStream;"
f,"_Frame? f = check pf.process();"
key,"anydata & readonly key = (check self.getKey(f)).cloneReadOnly();"
s,"stream<_Frame> s = <stream<_Frame>>self.groupedStream;"
next,"record {|_Frame value;|}|error? next = s.next();"
keys,"anydata[] keys = [];"
groupedFrames,"_Frame[] groupedFrames = [];"
groupedFrame,"_Frame groupedFrame = {};"
firstFrame,"_Frame firstFrame = entry.frames[0];"
sequenceValue,"any|error sequenceValue = groupedFrame[nonGroupingKey];"
val,"any|error val = f[nonGroupingKey];"
cFrame,"_Frame|error? cFrame = self.collectFunc(groupedFrame);"
f,"function (_Frame _frame) returns _Frame|error? f = self.selectFunc;"
f,"function (_Frame _frame) returns any|error f = self.doFunc;"
cFrame,"any|error cFrame = f(pFrame);"
limitFunc,"function (_Frame _frame) returns int|error limitFunc = self.limitFunc;"
lmt,"int|error lmt = limitFunc(pFrame);"
vals,"_Frame[]? vals = self.m[k];"
frames,"_Frame[] frames = [];"
l,"int l = vals.length();"
p,"_StreamPipeline p = self.pipeline;"
f,"_Frame|error? f = p.next();"
v,"Type v = <Type>f[\"$value$\"];"
currentFrames,"_Frame[]? currentFrames = self.frames;"
key,"any key = keys.shift();"
keyStr,"string keyStr = key.toString();"
o,"_OrderTreeNode o;"
orderedFrames,"_Frame[] orderedFrames = [];"
frames,"_Frame[] frames = <_Frame[]>self.frames;"
l,"int l = frames.length();"
keys,"any[] keys = self.getSortedArray(self.keys);"
o,"_OrderTreeNode o = self.nodes.get(k.toString());"
frms,"_Frame[] frms = o.get();"
res,"boolean?[] res = [];"
res,"int?[] res = [];"
res,"float?[] res = [];"
res,"decimal?[] res = [];"
res,"string?[] res = [];"
b,"byte[] b = [0, 1, 2, 100, 101, 255];"
m,"map<byte> m = { a: 3, b: 5, c: 1 };"
f,"int f = m.reduce(function (byte x, byte y) returns byte { int res = x * y; return <byte> res; }, 2);"
d,"decimal[] d = [0, 1.0, 2, 10.01, 101, 2550.1d];"
m,"map<decimal> m = { a: 30, b: 500.1, c: 1.01d };"
f,"float f = m.reduce(function (float x, decimal y) returns float { int xi = <int> x; int yi = <int> y; return <float> (xi + yi); }, 2);"
arr,"any[] arr = [];"
anyArr,"(any|error)[] anyArr = <(any|error)[]> arr[1];"
val,"any|error val = anyArr[0];"
anyMap,"map<any|error> anyMap = <map<any|error>> arr[2];"
actualValAsString,"string actualValAsString = \"\";"
expectedValAsString,"string expectedValAsString = expected is error ? expected.toString() : expected.toString();"
actualValAsString,"string actualValAsString = actual is error ? actual.toString() : actual.toString();"
x,"[int[3]...] x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];"
arr,"[int, int[]][] arr = [];"
x,"[[int, int...], [int, int, int], [int, int, int...]] x = [[1, 2], [3, 4, 5], [7, 8, 9, 10]];"
x,"[[int, int...], int[4]] x = [[1, 2, 3, 4], [7, 8, 9, 10]];"
arr,"int[][] arr = [];"
x,"[[int, int], [int, int, int...], int[2]...] x = [[1, 2], [3, 4, 5, 6], [7, 8], [9, 10]];"
t1,"[[string, Bar, boolean...], [int, boolean[]], [float, int...]] t1 = [[\"Ballerina\", {id: 34, flag: true}, false], [12, [true,false]], [1, 2, 3, 4]];"
a1,"[string|int|float, (Bar|boolean|boolean[]|int)[]][] a1 = [];"
a,"var a = [];"
b,"var b = from var x in a select 1;"
c,"var c = from var x in [] select 1;"
t1,"[int, string] t1 = [1, \"A\"];"
t2,"[int, string] t2 = [2, \"B\"];"
t3,"[int, string] t3 = [3, \"C\"];"
m,"map<[int, string]> m = { a: t1, b: t2, c: t3 };"
t1,"[int, [string, float]] t1 = [1, [\"A\", 2.0]];"
t2,"[int, [string, float]] t2 = [2, [\"B\", 3.0]];"
t3,"[int, [string, float]] t3 = [3, [\"C\", 4.0]];"
m,"map<any> m = { a: t1, b: t2, c: t3 };"
m,"map<[int, [string, float]]> m = { a: t1, b: t2, c: t3 };"
d1,"Data d1 = { i: 1, v: \"A\" };"
d2,"Data d2 = { i: 2, v: \"B\" };"
d3,"Data d3 = { i: 3, v: \"C\" };"
t1,"[int, Data] t1 = [2, d1];"
t2,"[int, Data] t2 = [3, d2];"
t3,"[int, Data] t3 = [4, d3];"
m,"map<[int, Data]> m = { a: t1, b: t2, c: t3 };"
m,"map<any> m = { a: d1, b: d2, c: d3 };"
m,"map<Data> m = { a: d1, b: d2, c: d3 };"
d11,"Data d11 = { i: 1, v: \"A\" };"
d12,"Data d12 = { i: 2, v: \"B\" };"
d13,"Data d13 = { i: 3, v: \"C\" };"
d21,"Data2 d21 = { i: 2, v: d11 };"
d22,"Data2 d22 = { i: 3, v: d12 };"
d23,"Data2 d23 = { i: 4, v: d13 };"
m,"map<any> m = { a: d21, b: d22, c: d23 };"
m,"map<Data2> m = { a: d21, b: d22, c: d23 };"
d1,"Data3 d1 = { i: 1, v: [1, \"A\"] };"
d2,"Data3 d2 = { i: 2, v: [2, \"B\"] };"
d3,"Data3 d3 = { i: 3, v: [3, \"C\"] };"
m,"map<Data3> m = { a: d1, b: d2, c: d3 };"
m,"map<any> m = {};"
x,"record {| readonly & [int, string] a; readonly & [boolean, int] b; |} x = {\"a\": [1, \"foo\"], \"b\": [false, 2]};"
arr,"(int|boolean|string)[] arr = [];"
c,"int|boolean c = a;"
d,"int|string d = b;"
x,"readonly & map<int[2]|string[3]|boolean[2]> x = {m: [1, 2], n: [\"foo\", \"bar\", \"baz\"], o: [true, false]};"
d,"int|boolean|string d = a;"
e,"int|boolean|string e = b;"
f,"int|boolean|string f = c[0];"
x,"readonly & map<[int, string, boolean...]|[boolean, int]> x = {a: [1, \"foo\"], b: [true, 2], c: [3, \"bar\", false]};"
x,"[[int, int...], [int, int, int...], int[2]] x = [[1, 2], [3, 4, 5, 6], [7, 8]];"
x,"[[int, int...], [int, int, int...], int] x = [[1, 2], [3, 4, 5, 6], 12];"
x,"[[int, int...], [int, int, int...]] x = [[1, 2], [3, 4, 5, 6]];"
data,"string[] data = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\"];"
i,"float i = 10.0;"
s,"boolean s = true;"
vals,"int vals = 1000;"
s1,"string s1 = s + s;"
p,"person p = {};"
j,"json j = [\"a\" , \"b\", \"c\"];"
jsonArray,"var jsonArray = <json[]> j;"
slist,"string[] slist = [\"a\" , \"b\", \"c\"];"
sTuple,"[[string, string], [string, string], [string, string]] sTuple = [[\"ddd\", \"d1\"], [\"rrr\", \"d1\"], [\"fef\", \"d1\"]];"
err1,"Error err1 = Error(\"Error One\", message = \"msgOne\", fatal = true);"
err2,"Error err2 = Error(\"Error Two\", message = \"msgTwo\", fatal = false);"
err3,"Error err3 = Error(\"Error Three\", message = \"msgThree\", fatal = true);"
errorArray,"Error[3] errorArray = [err1, err2, err3];"
result1,"string result1 = \"\";"
subjects,"json subjects = <json>jdata.subjects;"
d,"Employee d = { id: 1, name: \"AbuTharek\", salary: 100.0 };"
d1,"Employee d1 = { id: 1, name: \"Abu\", salary: 1000.0, \"married\": false };"
d2,"Employee d2 = { id: 2, name: \"Tharek\", salary: 1000.0, \"married\": false };"
d3,"Employee d3 = { id: 3, name: \"Kanaka\", salary: 1000.0, \"married\": false };"
data,"Employee[] data = [d1, d2, d3];"
keyValsMap,"map<anydata> keyValsMap = {foo:\"sss\", bar:\"ffff\"};"
keyValsMap,"map<any> keyValsMap = {foo:\"sss\", bar:\"ffff\"};"
x,"readonly & (int[2])[] x = [[1, 2], [3, 4], [5, 6]];"
c,"string c = a;"
d,"int[] d = b;"
x,"(readonly & int[2])[] x = [[1, 2], [3, 4], [5, 6]];"
arr,"string[] arr = [];"
x,"readonly & ([int, string, boolean])[] x = [[1, \"a\", true], [3, \"bc\", false], [5, \"def\", true]];"
d,"string d = a;"
e,"boolean e = b;"
f,"boolean f = c;"
x,"readonly & [[int, int], [int, int]...] x = [[1, 2], [3, 4], [5, 6]];"
c,"int[] c = a;"
d,"int d = b;"
x,"readonly & [int[2], string[2], boolean[3]] x = [[1, 2], [\"a\", \"b\"], [false, false, true]];"
arr,"(int|string|boolean)[] arr = [];"
d,"int|string d = a;"
e,"string|boolean e = b;"
f,"string f = c[0];"
x,"readonly & [map<int>, map<string>...] x = [{a: 1, b: 2}, {a: \"hello\", c: \"world\", d: \"ballerina\"}];"
b,"map<int> b = a;"
c,"int c = a;"
arr,"(int|boolean)[] arr = [];"
f,"int|string f = c[0];"
arr,"Bar[] arr = [];"
arr2,"Bar2[] arr2 = [];"
a,"[[int, int]] a = [[10, 20]];"
b,"[[[int, string], int[]]] b = [[[10, \"a\"], [20, 30, 40, 50]]];"
c,"[[[int, string], int[]]] c = [[[10, \"a\"], [20, 30, 40, 50]]];"
output,"string output = \"\";"
arr,"[int, string][] arr = [[1, \"A\"], [2, \"B\"], [3, \"C\"]];"
arr,"[int, [string, float]][] arr = [[1, [\"A\", 2.0]], [2, [\"B\", 3.0]], [3, [\"C\", 4.0]]];"
arr,"[int, Data][] arr = [[1, d1], [2, d2], [3, d3]];"
arr,"Data[] arr = [d1, d2, d3];"
d21,"Data2 d21 = { i: 1, v: d11 };"
d22,"Data2 d22 = { i: 2, v: d12 };"
d23,"Data2 d23 = { i: 3, v: d13 };"
arr,"Data2[] arr = [d21, d22, d23];"
arr,"Data3[] arr = [d1, d2, d3];"
arr,"int[] arr = [];"
d,"int d = a;"
e,"string e = b;"
d,"int|string|boolean d = a;"
e,"int|string|boolean e = b;"
f,"int|string|boolean f = c[0];"
arr,"(int|string)[] arr = [];"
b,"map<int|string> b = a;"
x,"(readonly & record {| int a; int b; |}|readonly & record {| string[] a; boolean? b = (); |})[] x = [{a: 1, b: 2}, {a: [\"hello\", \"world\", \"ballerina\"]}];"
arr,"(int|string[]|boolean?)[] arr = [];"
index,"int index = i;"
value,"string value = v;"
c,"T {a, b: c, ...d} = x;"
r,"T {a, b: {p, q: r, ...s}, ...d} = x;"
r,"var {a, b:{p, q:r, ...s }, ...d } = x;"
d,"Foo[]|Bar?[] d = expr;"
e,"Foo[]|Bar?[]|Baz[] e = expr;"
a,"T[][] a;"
a,"T[k1][k2] a;"
,"int[]"
r,"var {a, b: {p, q: r, ...s}, ...d} = x;"
l,"var [{a, b: [p, _, ...s], ...d}, l] = x;"
w,"[a, [b], c][d] w;"
a,"int[5 a;"
a,"int[]] a;"
a,"int[&%] a;"
a,"T 5] a;"
intArr,"int[1*2] intArr = [1];"
,"T[*] = 6;"
,"int[2] = [1,2];"
myTuple,"T[] myTuple = 6;"
k,"int k = 2;"
in test,", 3] in test"
apple,"json apple = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};"
mapValue,"map<json> mapValue = <map<json>>apple;"
colors,"json[] colors = <json[]> (checkpanic apple.colors);"
counter,"int counter = 0;"
book,"xml book = xml `<book> <name>Sherlock Holmes</name> <author>Sir Arthur Conan Doyle</author> </book>`;"
intArray,"int[5] intArray = [0, 1, 2, 3, 4];"
animals,"string[] animals = [\"Cat\", \"Canine\", \"Mouse\", \"Horse\"];"
a,"any a = \"Hello, world!\";"
b,"boolean b = a is string;"
alex,"Student alex = {name : \"Alex\"};"
x,"Student|Person|Vehicle x = alex;"
isStudent,"boolean isStudent = typeTestFunction(\"student\") is Student;"
str,"string str = value;"
i,"int i = value;"
sb,"string|boolean sb = value;"
x,"string? x = ();"
output,"string output = x is string ? \"value is string: \" + x : \"value is nil\";"
elvisOutput,"string elvisOutput = x ?: \"value is nil\";"
x,"[int, int, int, int] x = [1, 2, 3, 4];"
a,"int a;"
b,"int[] b;"
x,"[int, int, int...] x = [1, 2, 3, 4];"
x,"[int...] x = [1, 2, 3, 4];"
a,"int[] a;"
x,"[int, string, string] x = [1, \"a\", \"b\"];"
b,"string[] b;"
x,"[int, string...] x = [1, \"a\", \"b\"];"
x,"[int, string, string, string...] x = [1, \"a\", \"b\"];"
c,"string[] c;"
foo,"FooRecord foo = { field1: \"string value\", field2: [25, 12.5] };"
a,"boolean a;"
c,"[int, float] c;"
a,"any a = ();"
b,"any b = true;"
c,"any c = false;"
d,"any d = 123;"
e,"any e = -124.0f;"
f,"any f = 34.23d;"
g,"any g = \"str value\";"
err,"error err = error(\"Reason\", message = \"error message\");"
h,"any|error h = err;"
myError,"error myError = error AssertionError(ASSERTION_ERROR_REASON, message = \"second error message\");"
i,"any|error i = myError;"
ser,"service object {} ser = service object { resource function get res() { } };"
k,"any k = ser;"
employee,"Employee employee = {name: \"Jo\", intern: false};"
typeDesc,"typedesc<any> typeDesc = typeof Employee;"
l,"any l = typeDesc;"
xmlText,"'xml:Text xmlText = xml `xml text`;"
n,"any n = xmlText;"
i,"int? i = funcReturnNil();"
fa,"float?[] fa = [1.0, 5.0, 3.0, ()];"
f,"float? f = fa[0];"
s,"SearchResultType? s = RESULT_TYPE_MIXED;"
inclusiveRecord,"InclusiveRecord inclusiveRecord = {j:0, \"q\":1};"
exclusiveRecord,"ExclusiveRecord exclusiveRecord = {j:0};"
s1,"Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};"
s2,"Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};"
s3,"Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};"
studentList,"Student[] studentList = [s1, s2, s3];"
nameList,"FullName[] nameList = [];"
e,"var e = from var student in studentList do { FullName fullName = {firstName: student.firstName, lastName: student.lastName}; nameList.push(fullName); };"
f,"error? f = e;"
oddGen,"OddNumberGenerator oddGen = new;"
oddNumberStream,"var oddNumberStream = new stream<int, error?>(oddGen);"
oddNumber,"record {|int value;|}|error? oddNumber = oddNumberStream.next();"
studentStream,"stream<Student> studentStream = studentList.toStream();"
subscriptionStream,"stream<Subscription> subscriptionStream = studentStream.filter(function (Student student3) returns boolean { return student3.score > 1.0; }).'map(function (Student student4) returns Subscription { Subscription subscription = { firstName: student4.firstName, lastName: student4.lastName, score: student4.score, degree: \"Bachelor of Medicine\" }; return subscription; });"
avg,"float? avg = subscriptionStream.reduce(function (float accum, Student student2) returns float { return accum + <float>student2.score / <float>studentList.length(); }, 0.0);"
studentStream2,"stream<Student> studentStream2 = studentList.toStream();"
student,"record {|Student value;|}|error? student = studentStream2.next();"
e,"error? e = studentStream2.forEach(function (Student student1) { });"
studentStream3,"stream<Student> studentStream3 = studentList.toStream();"
iterator,"var iterator = studentStream3.iterator();"
nextStudent,"record {|Student value;|}|error? nextStudent = iterator.next();"
i,"int i = 100;"
k,"float k = 2.34;"
t1,"[int, float] t1 = [i, k];"
j,"json j = {};"
jStr,"string jStr = j.toString();"
send,"() send = i ->> w2;"
flushResult,"error? flushResult = flush w3;"
iw,"int iw;"
kw,"float kw;"
vW1,"[int, float] vW1 = [0, 1.0];"
jw,"json jw = {\"name\": \"Ballerina\"};"
lw,"int lw;"
mw,"float mw;"
s,"string s = \"WSO2\";"
m,"map<string> m = {\"name\": \"Bert\", \"city\": \"New York\", \"postcode\": \"10001\"};"
name,"string name = <string>m[\"name\"];"
city,"string city = <string>m[\"city\"];"
postcode,"string postcode = <string>m[\"postcode\"];"
street,"string street = \"Wall Street\";"
street,"string street = <string>m[\"street\"];"
f1,"future<int> f1 = start sum(40, 50);"
result,"int result = squarePlusCube(f1);"
f2,"future<()> f2 = start countInfinity();"
f3,"future <int|error> f3 = @strand {thread:\"any\"} start clientEndpoint-> remoteFunc(\"/get?test=123\");"
response,"int|error response = wait f3;"
f4,"future<int> f4 = start square(20);"
f5,"future<string> f5 = start greet(\"Bert\");"
anyResult,"int|string anyResult = checkpanic wait f4|f5;"
f6,"future<int> f6 = start sum(40, 60);"
f7,"future<int> f7 = start cube(3);"
f8,"future<string> f8 = start greet(\"Moose\");"
resultMap,"map<int|string|error> resultMap = wait {first_field: f6, second_field: f7, third_field: f8};"
rec,"record {int|error first_field; int|error second_field; string|error third_field;} rec = wait {first_field: f6, second_field: f7, third_field: f8};"
underGradTable,"table<UndergradStudentRec> underGradTable = table key(id,name) [ { id: 1, name: \"Mary\", grade: 12 }, { id: 2, name: \"John\", grade: 13 } ];"
varTable,"table<EmployeeRec> varTable = table key(id) [ { id: 1, age: 30, salary: 300.5, name: \"Mary\", married: true }, { id: 2, age: 20, salary: 300.5, name: \"John\", married: true } ];"
n,"int n = checkpanic wait f;"
sq,"int sq = square(n);"
cb,"int cb = cube(n);"
sq,"int sq;"
a,"int a = 385;"
b,"'int:Unsigned8 b = 128;"
res1,"'int:Unsigned8 res1 = a & b;"
c,"'int:Signed16 c = -32700;"
d,"int d = 249;"
res2,"int res2 = c & d;"
e,"'int:Unsigned8 e = 254;"
f,"'int:Unsigned16 f = 511;"
res3,"'int:Unsigned16 res3 = e | f;"
res4,"'int:Unsigned16 res4 = e ^ f;"
g,"int g = 12345678;"
h,"'int:Signed8 h = -127;"
res5,"int res5 = g | h;"
res6,"int res6 = g ^ h;"
a,"int a = 1;"
res1,"int res1 = a << 2;"
res2,"int res2 = b << 3;"
res3,"int res3 = c >> 2;"
d,"'int:Unsigned8 d = 255;"
e,"int e = 4;"
res4,"'int:Unsigned8 res4 = d >> e;"
f,"'int:Signed32 f = 123167;"
res5,"int res5 = f >>> 3;"
g,"'int:Unsigned16 g = 32001;"
res6,"'int:Unsigned16 res6 = g >> 2;"
statement,"string statement = \"Lion in Town. Catch the Lion\";"
s1,"string s1 = statement.toUpperAscii();"
s2,"string s2 = statement.toLowerAscii();"
s3,"string s3 = statement.substring(0, 4);"
index,"int? index = statement.indexOf(\"on\");"
length,"int length = statement.length();"
hello,"string hello = \"Hello\";"
ballerina,"string ballerina = \"Ballerina!\";"
s4,"string s4 = hello.concat(\" \", ballerina);"
s5,"string s5 = \",\".'join(hello, ballerina);"
bArray,"byte[] bArray = hello.toBytes();"
s6,"string|error s6 = 'string:fromBytes(bArray);"
toTrim,"string toTrim = \" Ballerina Programming Language \";"
s7,"string s7 = toTrim.trim();"
hasSuffix,"boolean hasSuffix = statement.endsWith(\"Lion\");"
hasPrefix,"boolean hasPrefix = statement.startsWith(\"Lion\");"
name,"string name = \"Sam\";"
marks,"int marks = 90;"
subjects,"string[] subjects = [\"English\", \"Science\"];"
average,"float average = 71.5;"
country,"string country = \"Sri Lanka\";"
c,"string c = country[4];"
a1,"'int:Signed32 a1 = 2147483647;"
a2,"'int:Signed32 a2 = -2147483648;"
b1,"'int:Signed16 b1 = 32767;"
b2,"'int:Signed16 b2 = -32768;"
c1,"'int:Signed8 c1 = 127;"
c2,"'int:Signed8 c2 = -128;"
d1,"'int:Unsigned32 d1 = 4294967295;"
d2,"'int:Unsigned32 d2 = 0;"
e1,"'int:Unsigned16 e1 = 65535;"
e2,"'int:Unsigned16 e2 = 0;"
f1,"'int:Unsigned8 f1 = 255;"
f2,"'int:Unsigned8 f2 = 0;"
g1,"byte g1 = 255;"
g2,"byte g2 = 0;"
a1,"'string:Char a1 = \"a\";"
t1,"'string t1 = a1;"
a2,"'string:Char a2 = \"\";"
t2,"'string t2 = a2;"
b,"string b = \"ab\";"
value,"Char value = \"a\";"
a,"string a = value;"
b,"'string:Char b = value;"
a,"Char a = \"a\";"
b,"Char b = \"b\";"
c,"string c = \"c\";"
x,"xml x = xml `<x/>`;"
t1,"string t1 = a + b;"
t2,"string t2 = a + c;"
t3,"string t3 = c + b;"
t4,"xml t4 = a + x;"
t5,"xml t5 = x + a;"
sa,"string sa = \"a\";"
xa,"xml xa = sa + x;"
ax,"xml ax = x + sa;"
b,"int b = 5;"
c,"int c = 2;"
numbers,"int[] numbers = [1, 3, 4, 7];"
f,"float f;"
d1,"RecData1 d1 = { i: 1, v: \"A\" };"
t1,"[int, RecData1] t1 = [2, d1];"
m,"map<[int, RecData1]> m = { a: t1 };"
newPerson,"Person newPerson = {};"
e,"SampleError e = error SampleError(\"the reason\", message=\"msg\");"
g,"string g;"
h,"string h;"
i,"Child i = new Child();"
futureIns,"int|error futureIns = wait fut;"
r,"record {int x; int y;} r = { x: 1, y: 2 };"
adr,"Address adr = object { public string city; public string country; public function init() { self.city = \"London\"; self.country = \"UK\"; } public function value() returns string { return self.city + \", \" + self.country; } };"
name1,"Name name1 = { firstName: \"Rowan\", lastName: \"Atkinson\" };"
evenNumber,"var evenNumber = evenNumberStream.next();"
teacher,"mod1:Teacher teacher = { name: \"Alex\", age: 24, salary: 8000.0 };"
entry1,"readonly & Entry entry1 = { \"munich\": {latitude: \"48.1351N\", longitude: \"11.5820E\"}, \"berlin\": {latitude: \"52.5200N\", longitude: \"13.4050E\"} };"
entry2,"readonly & Entry entry2 = { \"bordeaux\": {latitude: \"44.8378N\", longitude: \"0.5792W\"}, \"paris\": {latitude: \"48.8566N\", longitude: \"2.3522E\"} };"
roMap,"RoMap roMap = {\"germany\": entry1, \"france\": entry2};"
updateReq,"json|httpx:ClientError updateReq = <@untainted>req.getJsonPayload();"
res,"httpx:Response res = new;"
msg,"string msg = \"Update stock quote request received. \" + \"symbol:%s, price:%s\" + updateReq.toString();"
jsonRes,"json jsonRes = {\"message\": \"updating stock\"};"
pathMParams,"map<any> pathMParams = req.getMatrixParams(\"/sample/path\");"
a,"var a = <string>pathMParams[\"a\"];"
b,"var b = <string>pathMParams[\"b\"];"
pathMatrixStr,"string pathMatrixStr = string `a=${a}, b=${b}`;"
rec,"record { string a; int b; string c; int d; } rec = {a: \"\", b: 0, c: \"\", d: 1};"
err,"error<record { int b; string c; int d; }> err = error(\"error!\", b = 1, c = \"err!\", d = 2);"
a,"int|string a = 1;"
b,"int|string b = \"foo\";"
fn,"function () fn = function () { int x = <int> a; a = \"hello\"; };"
value,"string|int value = \"\";"
value,"string value = \"\";"
value,"int? value = let int length = arr.length() in length > 0 ? length : ();"
currentValue,"int currentValue = value;"
item,"int? item = arr[index];"
x,"int|string x = 1;"
res,"int? res = ();"
x,"any x = 1;"
m,"error? m = from int i in 0 ..< 2 do { if x is int { int _ = x; x = \"str\"; } };"
m,"error? m = from int i in 0 ..< 2 do { int? j = 2; if j is int { int _ = j; j = (); } int? k = 2; if k is int { k = (); int? _ = k; } };"
logRecord,"record {} logRecord = { \"module\": 1234 };"
value,"string|int value;"
y,"int|string y = 1;"
m,"error? m = from int i in 0 ..< 2 do { int _ = x; x = \"str\"; };"
m,"error? m = from int i in 0 ..< 2 do { error? n = from int j in 0 ..< 2 do { boolean b = false; if b { x = \"str\"; } x = 1; }; boolean _ = n is error; };"
m,"error? m = from int i in 0 ..< 2 do { int _ = x; if x is int { x = \"str\"; } };"
x,"(int|string)[] x = [1, 2];"
p,"int|string? p = 10;"
restData,"any[] restData = restVar;"
studentId,"myRecord {id: studentId, name: studentName, ...otherData};"
studentName,"myRecord {id: studentId, name: studentName, ...otherData};"
a,"int a = studentId;"
b,"string b = studentName;"
other,"map<anydata> other = otherData;"
message,"outOfResourceError error(message, errorNo = errorNumber, ...otherErrorDetails);"
errorNumber,"outOfResourceError error(message, errorNo = errorNumber, ...otherErrorDetails);"
a,"string a = message;"
b,"int b = <int> errorNumber;"
c,"map<anydata> c = otherErrorDetails;"
v,"any v = 1;"
k,"int k;"
v,"any | error v = 1;"
b,"int b;"
k,"int k = b;"
e,"boolean e = false;"
j,"int j = a;"
m,"int[] m = [];"
n,"int[] n;"
f1,"function () f1;"
f2,"function (int i, string j = \"\", boolean... k) f2;"
j,"string j;"
k,"boolean[] k;"
f3,"function (int m, string n = \"\", boolean... o) f3 = function (int i1, string j1 = \"\", boolean... k1) {};"
j2,"string j2 = \"\";"
k2,"boolean[] k2 = [true];"
b,"Bar b;"
arr,"int[] & readonly arr = [];"
anydataArr,"anydata[] anydataArr;"
fn2,"function () returns boolean fn2;"
anydataArr2,"anydata[] anydataArr2 = [];"
j,"final int j;"
a1,"record {| int i = j; |} a1;"
k,"final int k = 1;"
a2,"record {| int i = k; |} a2;"
t1,"typedesc<any> t1;"
t2,"typedesc t2 = int;"
condition,"boolean condition;"
a,"string a;"
a,"int? a = 10;"
a,"int a = 10;"
b,"boolean b = true;"
i,"final int i;"
b,"boolean b = false;"
d,"int? d = 10;"
i,"int i = 1;"
j,"int j = 2;"
k,"int k = 3;"
l,"int l = 4;"
a,"future<()> a = start fn();"
err,"error? err = ();"
l,"var l = 0;"
arr,"var arr = <int[]> [];"
n,"var n = \"x\";"
o,"var o = <record {int x;}> {x: 12};"
arr2,"var arr2 = <int[]> [];"
l2,"var l2 = 1;"
i,"var i = arr2[l2];"
o2,"var o2 = <record {int x;}> {x: 12};"
n2,"var n2 = \"x\";"
o3,"var o3 = <record {int x;}> {x: 12};"
a,"var a = o3[n2];"
a1,"int[] a1 = [];"
a2,"error[] a2 = [];"
m,"int m;"
a3,"Foo[] a3 = [];"
x,"int x = i + kd1;"
l,"int l = 9;"
customerList,"Customer[] customerList = [];"
personList,"Person[] personList = [];"
x,"int[] x = [];"
y,"any|error y = 1;"
s,"string s = a + c.toBalString();"
a,"int[] a = [];"
b,"int b = 1;"
j,"int j;"
j,"int j = 1;"
x,"int x = 1;"
k,"int k = j + 1;"
logRecord,"record {} logRecord = {};"
format,"string format = \"\";"
s,"string s = format == \"JSON\" ? logRecord.toJsonString() : value:toString(logRecord);"
n,"int[] n = from int k in 0 ..< 8 select 0;"
f,"Bar f = {i: 1};"
g,"int[] g = [];"
h,"int h = 1;"
i,"int[] i;"
j,"string[] j = foo.j;"
j,"json j = 1;"
y,"int[] y = x.clone();"
k,"int k = y[0];"
n3,"string n3 = \"n3\";"
k1,"[@annotOne {value: n3} int] k1 = [];"
n4,"string n4 = \"n4\";"
k2,"record {@annotOne {value: n4} string x;} k2 = {x: \"\"};"
waitResult,"error? waitResult = trap wait w1;"
err,"var err = trap errorPanicInsideLock();"
err,"var err = trap convertStringToInt();"
ddd,"int ddd;"
result,"var result = ints:fromString(lockWithinLockString1);"
w1Result,"error? w1Result = trap wait w1;"
strVal,"string strVal = \"sample blob output\";"
wrongStr,"string wrongStr = \"wrong output\";"
t2,"any t2 = results[\"W2\"];"
b0,"byte b0 = 0;"
b130,"byte b130 = 130;"
b255,"byte b255 = 255;"
mp,"map<json> mp = { a: -1, b: b0, c: 121, d: b130, e: b255, f: 300 };"
barr,"byte[] barr = [0, 1, 233, 255];"
jarr,"json[] jarr = barr;"
bmap,"map<byte> bmap = { a: 0, b: 1, c: 254, d: 255 };"
jmap,"map<json> jmap = bmap;"
bmap,"map<byte> bmap = { a: 0, b: 123, c: 255 };"
mp,"map<int> mp = { a: -1, b: b0, c: 121, d: b130, e: b255, f: 300 };"
iarr,"int[] iarr = barr;"
imap,"map<int> imap = bmap;"
barr,"byte[4] barr = [0, 1, 2, 255];"
iarr,"int[] iarr = <int[]> barr;"
iarr2,"int[4] iarr2 = <int[4]> barr;"
barr,"byte[] barr = [0, 1, 2, 255];"
barr2,"byte[] barr2 = <byte[]> iarr;"
arr1,"byte[] & readonly arr1 = <byte[] & readonly>base16 `aa bb`;"
arr2,"int[2] & readonly arr2 = <int[2] & readonly>base16 `aa bb`;"
arr3,"byte[2] & readonly arr3 = <readonly>base16 `aa bb`;"
arr4,"anydata[] & readonly arr4 = <anydata[] & readonly>base16 `aa bb`;"
arr5,"any[] arr5 = <any[] & readonly>base16 `aa bb`;"
arr6,"byte[] arr6 = <byte[]> arr5;"
expErrorReason,"final string expErrorReason = \"{ballerina/lang.array}InherentTypeViolation\";"
expErrorDetailMessage,"final string expErrorDetailMessage = \"incompatible types: expected 'byte', found 'int'\";"
fn,"var fn = function (int index, int value) { iarr[index] = value; };"
res,"error? res = trap fn(0, -1);"
err,"error err = <error> res;"
p,"TypeAliasThree p = {name:\"Anonymous name\"};"
a,"MyType a = 100;"
b,"MyType b = \"hundred\";"
s1,"string s1 = \"Anne\";"
p1,"ParamTest p1 = testVarArgs(\"John\");"
p2,"ParamTest p2 = testVarArgs(s1);"
val,"ArrayCustom val = [34, 23];"
fn,"FuncType fn = function (string s) returns int { return s.length(); };"
fn,"FuncType2 fn = function (string s) returns int { return s.length(); };"
f,"FiniteType f = 5;"
s,"FiniteType s = \"s\";"
n1,"Number n1 = 5;"
n2,"Number n2 = 5.0;"
b,"ByteType b = 5;"
f,"FloatType f = 5;"
d,"DecimalType d = 5;"
d,"DecimalType d = 5.0;"
f,"FloatType f = 5.00000000000000000001;"
f,"FloatType f = FLOAT;"
d,"DecimalType d = 5.0000000000000;"
d,"DecimalType d = DECIMAL;"
a,"State a = \"on\";"
b,"string b = a;"
assignmentSuccessful,"boolean assignmentSuccessful = a == b;"
c,"string|boolean c = a;"
a,"NumberSet a = 2;"
b,"int b = a;"
c,"string|int c = a;"
a,"FloatValue a = 2.0;"
b,"float b = a;"
c,"float|int c = a;"
a,"BooleanValue a = true;"
b,"boolean b = a;"
c,"anydata c = a;"
a,"ByteValue a = 12;"
b,"byte b = a;"
c,"byte|Person c = a;"
a,"CombinedState a = \"off\";"
b,"string|int b = a;"
d,"StringOrInt d = a;"
ab,"AB ab = A;"
s,"string s = ab;"
assignmentSuccessful,"boolean assignmentSuccessful = ab == s;"
ab,"ABInt ab = A;"
s,"AB|int s = ab;"
s2,"string|int s2 = ab;"
a,"W a = \"foo\";"
b,"X b = a;"
assignmentSuccessful,"boolean assignmentSuccessful = a == b && b == FOO;"
c,"Y c = a;"
d,"Z d = a;"
a,"X a = true;"
b,"Y b = a;"
assignmentSuccessful,"boolean assignmentSuccessful = a == b && a == true;"
c,"Z c = b;"
a,"t a = 1.0f;"
b,"t b = 1.0d;"
c,"t|t2 c = 2.22;"
d,"t|t2 d = 2.22f;"
e,"t|t2 e = 3.33d;"
n,"PositiveInt n = +3;"
comparator,"PositiveInt comparator = +3;"
n,"PositiveFloat n = +1.2;"
comparator,"PositiveFloat comparator = +1.2;"
v,"any v = CONST3;"
a,"string a = \"\";"
mah,"string mah = \"match\";"
rec1,"RecString1 rec1 = {a: \"foo\", b: 1, c: true};"
rec2,"RecString2 rec2 = rec1;"
f,"FT f = '\-;"
f1,"Mat f1 = 1;"
f2,"Mat2 f2 = 1;"
f3,"Mat3 f3 = 1;"
f4,"\"chiran\"|5.0f f4 = 5;"
f5,"0x0.00p00 f5 = 0x0.00p00;"
x1,"UnaryType1 x1 = -3;"
x2,"UnaryType2 x2 = -2;"
x3,"UnaryType3 x3 = -3;"
x7,"UnaryType3 x7 = -5;"
x4,"UnaryType4 x4 = -2;"
x5,"UnaryType4 x5 = -3;"
x6,"UnaryType5 x6 = -3;"
x8,"UnaryType1 x8 = -(3);"
x9,"UnaryType1 x9 = (-3);"
x10,"UnaryType6 x10 = -1;"
x1,"9223372036854775808f x1 = 9223372036854775808;"
tActual,"typedesc<any|error> tActual = typeof actual;"
person,"Person person = new(h1);"
el2,"'xml:Element el2 = xml `<foo>foo</foo>`;"
nextElement2,"record {| 'xml:Comment value; |}? nextElement2 = el2.iterator().next();"
comment2,"'xml:Comment comment2 = xml `<!--I am a comment-->`;"
nextComment2,"record {| 'xml:Element value; |}? nextComment2 = comment2.iterator().next();"
pi2,"'xml:ProcessingInstruction pi2 = xml `<?target data?>`;"
nextPI2,"record {| 'xml:Comment value; |}? nextPI2 = pi2.iterator().next();"
el2,"'xml:Element|'xml:Text el2 = xml `<foo>foo</foo><bar/>`;"
el3,"xml<'xml:Element>|xml<'xml:Text> el3 = xml `<foo>foo</foo><bar/>`;"
nextUnionXMLVal2,"record {| 'xml:Element|'xml:Text value; |}? nextUnionXMLVal2 = el2.iterator().next();"
nextUnionXMLVal3,"record {| 'xml:Element|'xml:Text value; |}? nextUnionXMLVal3 = el3.iterator().next();"
elements,"xml<xml:Element[]> elements = xml ``;"
elements,"xml<xml:Element[] & readonly> elements = xml ``;"
elements,"xml<[int, string]> elements = xml ``;"
m1,"var m1 = error(\"Error!\");"
arr,"(any|error)[] arr = [y, a, m, y1, a1, m1];"
errs2,"error[] errs2 = let var e1 = error(\"one\"), var e2 = {a: error(\"two\")}, var e3 = error(\"three\") in [e1, e3];"
str3,"string str3 = let var {q: [e, i], r, s: error MyError(err = err), t} = baz() in (<error> e).message() + r.message() + err.message() + t.toString();"
str4,"string str4 = let var {q: [e, i], r, s: error MyError(err = err), t} = baz() in t.toString();"
tot,"int tot = 0;"
v,"error[] v = [error(\"a\"), error(\"b\")];"
w,"int[] w = from var a in v select 1;"
x,"error? x = from var error(m, c) in v do {};"
arr1,"error[] arr1 = [error(\"a\"), error(\"b\")];"
arr2,"error[] arr2 = [error(\"a\"), error(\"c\")];"
y,"int[] y = from var e1 in arr1 join var e2 in arr2 on true equals false select 1;"
val,"int val = 0;"
z,"error? z = from var error(m1, c1) in arr1 join var error(m2, c2) in arr2 on val equals 0 do {};"
y,"error y = x;"
e1,"var e1 = error(\"\");"
e2,"var e2 = error(\"\");"
er,"error er = error(\"\");"
a1,"var a1 = y1;"
errs2,"error[] errs2 = let var e1 = error(\"one\"), var e2 = {a: error(\"two\")}, var e3 = error(\"three\") in [];"
some,"var some = some;"
name,"var name = \"name\";"
isHappy,"var isHappy = true;"
a,"any a = 5;"
s,"var s = trap <string> a;"
s,"var s = check trap <string> a;"
b,"var b = trap <boolean> a;"
b,"var b = check trap <boolean> a;"
a,"any a = \"foo\";"
b,"var b = check trap <int> a;"
b,"var b = check trap <float> a;"
b,"var b = check trap <map<any>> a;"
j,"json j = { name:\"Child\", age:25, parent:{ name:\"Parent\", age:50, parent: \"Parent\", address:{\"city\":\"Colombo\", \"country\":\"SriLanka\"}, info:null, marks:null }, address:{\"city\":\"Colombo\", \"country\":\"SriLanka\"}, info:{status:\"single\"}, marks:[87,94,72] };"
p,"var p = j.cloneWithType(Person);"
j,"json j = {name:\"supun\", age:\"25\"};"
p,"var p = j.cloneWithType(PersonA);"
a,"A a = {x: \"x-valueof-a\", y:4};"
b,"B b = {x: \"x-valueof-b\"};"
c,"var c = b.cloneWithType(A);"
a,"var a = check trap <A> b;"
v,"var v = <int|string|object {}> object { function a = function () returns error? { record {| any x = 1; |} r = {}; return; }; };"
v,"var v = <object {}&readonly> object { function a = function () returns error? { record {| any x = 1; |} r = {}; return; }; };"
x,"string[] x;"
a,"string[] a = [ \"a\", \"b\", \"c\"];"
x,"float x;"
a,"string a = \"a\";"
b,"float b = 0.0;"
x,"[int, int, int] x = [1, 2, 3];"
y,"int[][2] y = [x, [1, 2], x, [a, b]];"
x2,"string[2] x2 = [\"string 1\", \"string 2\"];"
y2,"string[][2] y2 = [x2, [\"string 1\", \"string 2\"], x2, [a2, b2]];"
x,"int[2] x = [1, 2];"
t1,"[int...] t1 = [1, 2, 3, 5];"
t2,"[int, string, boolean...] t2 = [1, \"a\", true, true];"
x1,"var x1 = t1[0];"
x2,"int x2 = x1;"
x3,"var x3 = t2[0];"
x4,"int x4 = x3;"
x5,"var x5 = t2[3];"
x6,"boolean x6 = x5;"
x7,"var x7 = t1[index];"
x8,"int x8 = x7;"
x9,"var x9 = t2[index];"
x10,"int|string|boolean x10 = x9;"
x11,"var x11 = t2[index + 2];"
x12,"int|string|boolean x12 = x11;"
x13,"int x13 = t1[0];"
x14,"int x14 = t2[0];"
x15,"boolean x15 = t2[3];"
x16,"int x16 = t1[index];"
x17,"int|string|boolean x17 = t2[index];"
x18,"int|string|boolean x18 = t2[index + 2];"
e,"int e = 44;"
tuple1,"[any...] tuple1 = [];"
tuple2,"[anydata...] tuple2 = [];"
tuple3,"[int...] tuple3 = [];"
tuple4,"[string...] tuple4 = [];"
t1,"CustomTupleWithRestTypes1 t1 = [1, 2, 3, 5];"
t2,"CustomTupleWithRestTypes2 t2 = [1, \"a\", true, true];"
t3,"[int, string, boolean] t3 = [1, \"a\", true];"
t4,"CustomTupleWithRestTypes1 t4 = [1, 2, 3, 5];"
t5,"CustomTupleWithRestTypes2 t5 = [1, \"a\", true, true];"
t6,"CustomTuple t6 = [1, \"a\", true];"
byteIndex,"byte byteIndex = 0;"
x1,"var x1 = t1[byteIndex];"
x3,"var x3 = t2[byteIndex];"
x4,"int|string|boolean x4 = x3;"
x5,"var x5 = t2[byteIndex + 2];"
x6,"int|string|boolean x6 = x5;"
x7,"var x7 = t3[byteIndex];"
x8,"int|string|boolean x8 = x7;"
x9,"var x9 = t3[byteIndex + 2];"
x11,"var x11 = t4[byteIndex];"
x12,"int x12 = x11;"
x13,"var x13 = t5[byteIndex];"
x14,"int|string|boolean x14 = x13;"
x15,"var x15 = t5[byteIndex + 2];"
x16,"int|string|boolean x16 = x15;"
x17,"var x17 = t6[byteIndex];"
x18,"int|string|boolean x18 = x17;"
x19,"var x19 = t6[byteIndex + 2];"
x20,"int|string|boolean x20 = x19;"
x1,"var x1 = t1[constantIndex];"
x3,"var x3 = t2[constantIndex];"
x5,"var x5 = t2[constantIndex + 2];"
x7,"var x7 = t3[constantIndex];"
x9,"var x9 = t3[constantIndex + 2];"
x11,"var x11 = t4[constantIndex];"
x13,"var x13 = t5[constantIndex];"
x15,"var x15 = t5[constantIndex + 2];"
x17,"var x17 = t6[constantIndex];"
x19,"var x19 = t6[constantIndex + 2];"
o,"(int|error)[2] o = [1, 2];"
A,"xml A = xml `xml string`;"
B,"[string, int, xml...] B = [\"text1\", 1, A];"
jsonTest,"json jsonTest = B;"
C,"[string, int|xml, string...] C = [\"text1\", 1, A.toString()];"
f,"[1, \"hello\"]|[1] f;"
T1,"[@typeParam int, string...] T1 = [1, \"d\"];"
T2,"[@annot int, string] T2 = [1, \"d\"];"
T3,"[@member @annot int, string] T3 = [1, \"d\"];"
T4,"[@member int, @annot string] T4 = [1, \"d\"];"
f,"[string,int] f = [\"test4\", 4];"
foo5,"FooStruct foo5 = {x:\"foo test5\"};"
i,"[string, FooStruct] i = [\"test5\",foo5];"
i,"[string, float, string] i = [\"y\", 5.0, \"z\"];"
x,"string x = testTuples(\"x\", i);"
x,"[string, float, string] x = testReturnTuples(\"x\");"
x,"[string, float, string] x = [a, 5.0, \"z\"];"
x,"[string, int] x = [\"foo\", 1];"
x,"[string, int, int] x = [\"foo\", 1, 2];"
c,"int c;"
x,"[string, [int, [int, boolean]]] x = [\"foo\", [1, [2, true]]];"
b,"boolean b;"
x,"[boolean, int, string] x = [true, 3, \"abc\"];"
tempBool,"boolean tempBool = x[0];"
tempInt,"int tempInt = x[1];"
tempString,"string tempString = x[2];"
p1,"Person p1 = { name: \"Foo\" };"
p2,"Person p2 = { name: \"Bar\" };"
e1,"Employee e1 = { name: \"FooBar\", intern: false };"
x,"[Person, Employee, Person, float] x = [p1, e1, p2, 12.0];"
p3,"Person p3 = x[0];"
e2,"Employee e2 = x[1];"
p4,"Person p4 = x[2];"
p5,"Person p5 = { name: \"NewFoo\" };"
p6,"Person p6 = { name: \"NewBar\" };"
e3,"Employee e3 = { name: \"NewFooBar\", intern: true };"
x,"[boolean, int, string, float] x = [false, 0, \"\", 0.0];"
x,"[string...] x = [\"a\", \"b\", \"c\"];"
y,"string[] y = x;"
x,"[string, string, string] x = [\"a\", \"b\", \"c\"];"
y,"string[3] y = x;"
x,"string[] x = [\"a\", \"b\", \"c\"];"
y,"[string...] y = x;"
x,"string[3] x = [\"a\", \"b\", \"c\"];"
y,"[string, string...] y = x;"
y,"[string, string, string] y = x;"
st,"someOtherType st = [y, \"a\", new(1)];"
st1,"someOtherType st1 = [\"y\", \"str\"];"
val,"anotherType val = <anotherType> st;"
val2,"oneMoreType val2 = <oneMoreType> st1;"
x,"[int, string|boolean...] x = [1, \"hi\", true];"
tup,"[string, record {| string name; |}[]...] tup = [\"foo\", [{name: \"Pubudu\"}]];"
arr,"int[] arr = <int[]> b2[1][1];"
intVar2,"var [[intVar], {a: intVar2}, ...restBp] = getComplexTuple1();"
val1,"int|error val1 = restBp[1];"
val2,"int|error val2 = restBp[2];"
objects,"[BarObj, FooObj] objects = <[BarObj, FooObj]> b2[0][1];"
x,"[[int, int]...] x = [[1, 2], [3, 4], [7, 8]];"
A,"[json, json...] A = [];"
jsonTest,"json jsonTest = A;"
C,"MyTupleType C = [1, 2, 3];"
B,"[int, int...] B = [];"
D,"[string, int] D = [\"text1\", 1];"
E,"[string, int, boolean...] E = [\"text1\", 1, true, false];"
F,"[float[]] F = [[10.5]];"
G,"[map<string>...] G = [];"
H,"[float, [\"json\"], map<json>, int, json[], string...] H = [10.5];"
testXml,"xml testXml = xml `<elem>text1</elem>`;"
J,"[string, xml]|json J = [\"Anne\", testXml];"
K,"[string, xml[]|int]|json K = [\"text1\", [testXml]];"
x1,"T1 x1 = [1, 2, \"hello\", \"world\"];"
x2,"T2 x2 = [1, 2, \"a\"];"
x3,"T3 x3 = [1, \"hello\"];"
x4,"T4 x4 = [1, \"a\"];"
newp,"map<any> newp = p.'map(function ([string, any] entry) returns [string, any] { return [\"\", \"\"]; });"
invMap,"ClosedPerson invMap = p.'map(function ([string, any] entry) returns [string, any] { return [\"\", \"\"]; });"
newp,"map<any> newp = p.filter(function ([string, any] entry) returns boolean { return true; });"
invFil,"ClosedPerson invFil = p.filter(function ([string, any] entry) returns boolean { return false; });"
f,"ClosedGrades f = {maths: 80, physics: 75, chemistry: 65};"
m,"map<int> m = f.'map(function ([string, int] entry) returns [string, int] { var [subj, grade] = entry; return [subj, grade + 10]; }) .'map(function ([string, int] entry) returns [string, string] { var [s, g] = entry; if (g > 75) { return [s, \"PASS\"]; } return [s, \"FAIL\"]; }) .filter(function ([string, string] entry) returns boolean { var [s, status] = entry; if (status == \"PASS\") { return true; } return false; }) .'map(function ([string, string] entry) returns [string, float] { var [s, status] = entry; if (status == \"PASS\") { return [s, 4.2]; } return [s, 0.0]; });"
ar,"int[] ar = f.'map(function ([string, int] value) returns int { return value[1] + 10; }) .'map(function (int grade) returns string { if (grade > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
p,"Person p = { name: \"John Doe\", age: 25, address: { street: \"Palm Grove\", city: \"Colombo 3\" }, \"height\": 5.9 };"
values,"any[] values = [];"
p,"Person p = { name: \"John Doe\", age: 25, address: { street: \"Palm Grove\", city: \"Colombo 3\" } };"
p,"Person p = { name: \"John Doe\", age: 25, address: { street: \"Palm Grove\", city: \"Colombo 3\" }, \"profession\": \"Software Engineer\" };"
newp,"map<anydata> newp = p.'map(function (anydata value) returns anydata { if value is string { return value.toLowerAscii(); } return value; });"
f,"Foo f = {a: \"A\", b: \"B\", c: \"C\", d: \"D\", e: \"E\", \"f\": \"F\"};"
newf,"map<anydata> newf = f.filter(function (anydata value) returns boolean { if (value !== \"A\" && value !== \"E\") { return true; } return false; });"
f,"Foo f = {a: \"AA\", b: \"BB\", c: \"CC\", d: \"DD\", e: \"EE\", \"f\": \"FF\"};"
newf,"map<anydata> newf = f.'map(function (anydata value) returns anydata { if value is string { return value.toLowerAscii(); } return value; }) .filter(function (anydata value) returns boolean { if (value !== \"aa\" && value !== \"ee\") { return true; } return false; });"
f,"RestrictedFoo f = {a: \"AA\", b: \"BB\", c: \"CC\", d: \"DD\", e: \"EE\", \"f\": \"FF\"};"
modFooMap,"map<string> modFooMap = f.'map(function (string val) returns string { return val.toLowerAscii(); });"
grades,"RestrictedGrades grades = {maths: m, physics: p, chemistry: c, \"english\": e};"
adjGrades,"map<int> adjGrades = grades.'map(function (int grade) returns int { return grade + 10; });"
bar,"RestrictedBar bar = {x: a, y: b, z: c, \"p\": 9.9};"
modBar,"map<float> modBar = bar.'map(function (float val) returns float { return val + 10.0; });"
modFooMap,"map<string> modFooMap = f.filter(function (string v) returns boolean { if (v == \"AA\" || v == \"EE\" || v == \"FF\") { return true; } return false; });"
grades,"RestrictedGrades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 78};"
adjGrades,"map<int> adjGrades = grades.filter(function (int grade) returns boolean { if (grade > 70) { return true; } return false; });"
modBar,"map<float> modBar = bar.filter(function (float val) returns boolean { if (val > 6.0) { return true; } return false; });"
count1,"int count1 = grades.reduce(function (int count, int v) returns int { return count + 1; }, 0);"
max1,"int max1 = grades.reduce(function (int max, int v) returns int { return v > max ? v : max; }, 0);"
min1,"int min1 = grades.reduce(function (int min, int v) returns int { return v < min ? v : min; }, 1000000);"
sum1,"int sum1 = grades.reduce(function (int sum, int v) returns int { return sum + v; }, 0);"
avg1,"float avg1 = grades.reduce(function (float avg, int v) returns float { return avg + <float>v / <float>grades.length(); }, 0.0);"
grades,"RestrictedGrades grades = {maths: m, physics: p, \"english\": e};"
m,"map<float> m = grades.'map(function (int grade) returns int { return grade + 10; }) .'map(function (int g) returns string { if (g > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
grades,"Grades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 78};"
m,"map<float> m = grades.'map(function (anydata grade) returns int { if grade is int { return grade + 10; } return -1; }) .'map(function (int g) returns string { if (g > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
f,"RestrictedGrades f = {maths: m, physics: p, chemistry: c, \"english\": 78};"
count1,"int count1 = f.'map(mapTo).filter(filter).reduce(function (int count, int v) returns int { return count + 1; }, 0);"
sum1,"int sum1 = f.'map(mapTo).filter(filter).reduce(function (int sum, int v) returns int { return sum + v; }, 0);"
max1,"int max1 = f.'map(mapTo).filter(filter).reduce(function (int max, int v) returns int { return v > max ? v : max; }, 0);"
min1,"int min1 = f.'map(mapTo).filter(filter).reduce(function (int min, int v) returns int { return v < min ? v : min; }, 100000);"
length,"int length = f.'map(mapTo).filter(filter).length();"
avg1,"float avg1 = f.'map(mapTo).filter(filter).reduce(function (float avg, int v) returns float { return avg + <float>v / <float>length; }, 0.0);"
invMap,"Person invMap = p.'map(function (anydata entry) returns anydata { return \"\"; });"
invFil,"Person invFil = p.filter(function (anydata entry) returns boolean { return false; });"
f,"RestrictedGrades f = {maths: 80, physics: 75, chemistry: 65, \"english\": 78};"
m,"map<int> m = f.'map(function (int grade) returns int { return grade + 10; }) .'map(function (int g) returns string { if (g > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
ar,"int[] ar = f.'map(function (int grade) returns int { return grade + 10; }) .'map(function (int grade) returns string { if (grade > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
p,"ClosedPerson p = { name: \"John Doe\", age: 25, address: { street: \"Palm Grove\", city: \"Colombo 3\" } };"
p,"ClosedPerson p = { name: \"John Doe\", age: 25, address: { street: \"Palm Grove\", city: \"Colombo 3\" }};"
newp,"map<any> newp = p.'map(function (any value) returns any { if value is string { return value.toLowerAscii(); } return value; });"
f,"ClosedFoo f = {a: \"A\", b: \"B\", c: \"C\", d: \"D\", e: \"E\"};"
newf,"map<string> newf = f.filter(function (string value) returns boolean { if (value == \"A\" || value == \"E\") { return true; } return false; });"
f,"ClosedFoo f = {a: \"AA\", b: \"BB\", c: \"CC\", d: \"DD\", e: \"EE\"};"
newf,"map<string> newf = f.'map(function (string value) returns string { return value.toLowerAscii(); }) .filter(function (string value) returns boolean { if (value != \"aa\" && value != \"ee\") { return true; } return false; });"
modFooMap,"map<string> modFooMap = f.'map(function (string value) returns string { return value.toLowerAscii(); });"
grades,"ClosedGrades grades = {maths: m, physics: p, chemistry: c};"
bar,"ClosedBar bar = {x: a, y: b, z: c};"
modFooMap,"map<string> modFooMap = f.filter(function (string v) returns boolean { if (v == \"AA\" || v == \"EE\") { return true; } return false; });"
grades,"ClosedGrades grades = {maths: 80, physics: 75, chemistry: 65};"
counta,"int counta = grades.reduce(function (int count, int v) returns int { return count + 1; }, 0);"
maxa,"int maxa = grades.reduce(function (int max, int v) returns int { return v > max ? v : max; }, 0);"
mina,"int mina = grades.reduce(function (int min, int v) returns int { return v < min ? v : min; }, 1000000);"
suma,"int suma = grades.reduce(function (int sum, int v) returns int { return sum + v; }, 0);"
avga,"float avga = grades.reduce(function (float avg, int v) returns float { return avg + <float>v / <float>grades.length(); }, 0.0);"
grades,"ClosedGrades grades = {maths: m, physics: p};"
m,"map<float> m = f.'map(function (int grade) returns int { return grade + 10; }) .'map(function (int grade) returns string { if (grade > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
f,"ClosedGrades f = {maths: m, physics: p, chemistry: c};"
counta,"int counta = f.'map(mapTo).filter(filter).reduce(function (int count, int v) returns int { return count + 1; }, 0);"
suma,"int suma = f.'map(mapTo).filter(filter).reduce(function (int sum, int v) returns int { return sum + v; }, 0);"
maxa,"int maxa = f.'map(mapTo).filter(filter).reduce(function (int max, int v) returns int { return v > max ? v : max; }, 0);"
mina,"int mina = f.'map(mapTo).filter(filter).reduce(function (int min, int v) returns int { return v < min ? v : min; }, 100000);"
avga,"float avga = f.'map(mapTo).filter(filter).reduce(function (float avg, int v) returns float { return avg + <float>v / <float>length; }, 0.0);"
m,"map<float> m = grades.'map(function (int grade) returns int { return grade + 10; }) .'map(function (int grade) returns string { if (grade > 75) { return \"PASS\"; } return \"FAIL\"; }) .filter(function (string status) returns boolean { if (status == \"PASS\") { return true; } return false; }) .'map(function (string status) returns float { if (status == \"PASS\") { return 4.2; } return 0.0; });"
empTwo,"EmployeeTwo empTwo = {age: 4, name: {first:\"Joe\"}};"
empAge,"int empAge;"
empName,"string empName;"
b,"decimal b;"
c,"boolean c;"
arr,"any[] arr = let int[] v = y in [v];"
'self,"int[] 'self = [];"
y,"map<int>[] y = [];"
z,"map<int> z;"
y2,"map<int>[] y2 = [];"
resp,"Response resp;"
val,"any val = `arr: ${intArr}`;"
a,"NonIsolatedClassWithNonPrivateMutableFields a = new NonIsolatedClassWithNonPrivateMutableFields(1, {});"
c,"NonIsolatedClassNotOverridingMutableFieldsInIncludedIsolatedObject c = new;"
d,"NonIsolatedClassAccessingMutableFieldsOutsideLock d = new ([]);"
e,"NonIsolatedClassWithNonUniqueInitializerExprs e = checkpanic new (());"
f,"NonIsolatedClassWithInvalidCopyIn f = new ({}, 1, []);"
g,"NonIsolatedClassWithInvalidCopyOut g = new;"
h,"NonIsolatedClassWithNonIsolatedFunctionInvocation h = new;"
i,"NonIsolatedClassWithInvalidObjectFields i = new;"
j,"NonIsolatedClassWithCopyInInsideBlock j = new;"
k,"NonIsolatedClassWithInvalidCopyingWithClone k = new;"
l,"CurrentConfig l = new;"
m,"NonIsolatedClassWithInvalidVarRefs m = new;"
n,"NonIsolatedServiceClassWithNonPrivateMutableFields n = new (1, {});"
o,"InvalidIsolatedClientClassWithCopyInInsideBlock o = new;"
p,"NonIsolatedServiceClassNotOverridingMutableFieldsInIncludedIsolatedServiceObject p = new;"
q,"ServiceClass q = new;"
r,"NonIsolatedClassWithInvalidCopyInInMethodCall r = new;"
s,"IsolatedClassWithInvalidCopyOut2 s = new;"
t,"NonIsolatedClassWithQueryExprAsTransferOut t = new;"
u,"NonIsolatedClassWithInvalidRawTemplateTransfer u = new;"
modules,"string[] modules = [\"Science\", \"History\"];"
student,"Student4 student = new(...modules);"
nameBeforeChange,"string[] nameBeforeChange = student.modules;"
newModules,"string[] newModules = [\"Maths\", \"Physics\"];"
nameAfterChange,"string[] nameAfterChange = student.modules;"
v,"error? v = self.init(0);"
marksBeforeChange,"int marksBeforeChange = 0;"
marksAfterChange,"int marksAfterChange = 0;"
student,"Student5|error student = new(id, ...modules);"
s,"Student5 s = student;"
modules,"string[] modules = [\"Math\", \"Physics\"];"
student,"Student6 student = new;"
err,"error err = error(\"ID should be an integer\");"
student,"Student7 student = new(4);"
student,"Student8 student = new(4);"
newError,"AddError newError = new;"
e,"var e = newError.getError();"
err,"error err = error(\"Returned value should be an error\");"
student,"Student9 student = new;"
cal,"Calculate1 cal = new(2, 3, 4);"
e,"error e = error(\"unsupported operation\", op = operation);"
cal,"Calculate2|error cal = new(\"SUB\", 2, 3, 4);"
s,"Student10 s = new(\"Andrew\");"
details,"[string , int, TYPE, TYPE ] details = s.getDetails();"
s1,"Student11 s1 = new(\"Anne\", getData);"
s2,"Student11 s2 = new(\"Anne\");"
s1,"Student12 s1 = new(10, 20, getTotalMarks);"
s2,"Student12 s2 = new(10, 20);"
f,"float f = obj.someFloat;"
g,"float g = obj.someFloat();"
count,"int count = self.age + add;"
val2,"string val2 = value1 + self.month;"
e,"SampleError e = error SampleError(\"Sample Error\", info = \"Detail Info\", fatal = true);"
p,"Person p = {id:1, name:\"ABC\"};"
a,"[int, int] a = [3, 4];"
m,"var [[k, l], m] = [a, 4];"
a,"[NoFillerObject, int] a = [];"
b,"[[int, int], [NoFillerObject, NoFillerObject]] b = [];"
tup,"var tup = [ {id: 123, name: \"Anne\", city: \"Colombo\"}, {id: 456, name: \"Jo\", age: 40}, 1, \"abc\" ];"
tup2,"[record {| int id; string name; int city; |}, record {}, boolean, string] tup2 = tup;"
v1,"record {| int id; string name; string age; |} v1 = tup[1];"
v2,"float v2 = tup[2];"
arr,"int[] arr = [1, 2];"
ft,"future<()> ft = start testInferringForReadOnlyNonReadOnlyMemberNegative();"
rd,"readonly rd = [1, arr, ft];"
mp,"map<boolean|int> mp = { i: 1, b: true };"
rd,"readonly|int[] rd = [1, mp];"
arr,"boolean[] & readonly arr = [];"
br,"boolean[][]|readonly br = [arr];"
f,"Foo f = [\"hello\", <string> 1];"
g,"string[]|Foo g = [<string> 1, \"hello\"];"
s,"string[] s = [\"1\", \"a\"];"
i,"int i = 10;"
s,"string[] s = [\"foo\", \"bar\"];"
arr,"int[] arr = [-5, 2, 4, 5, 7, -8, -3, 2];"
a,"int[] a = arr.map(function (int v) returns (any) { return v + 1; });"
a,"int[] a = arr.map(function (int v) returns (int) { return v + 1; }).map(function (int v) returns (string) { return \"Test\" + v.toString(); });"
a,"int[] a = arr.map(function (int v) returns (int) { return v + 1; }).map(function (int v) returns (string) { return \"Test\" + v.toString(); }).filter(function (string s) returns boolean { return true;});"
z,"map<any> z = {a:\"1\", b:\"2\"};"
m,"map<any> m = z.filter(function (string s) returns boolean { return s == \"\"; });"
x,"string x = z.filter(function (any s) returns boolean { return s == (); });"
numbers,"int[] numbers = [-5, -3, 2, 7, 12];"
filtered,"var filtered = numbers.filter(function (int i) returns boolean { return i; });"
mapped,"var mapped = numbers.filter(function (int value) returns boolean { return value > 0; }).map(function (int value) returns [string, float] { return [value.toString(), value]; });"
x,"var x = numbers.filter(function (int i) returns boolean { return i >= 0; })[0];"
mapped,"anydata mapped = globalNumbers.filter(function (int value) returns boolean { return value > 0; }).map(function (int value) returns [string, float] { return [value.toString(), value]; });"
value,"string value = index.toString() + s;"
m,"map<string> m = {a:\"A\", b:\"B\", c:\"C\", d:\"D\", e:\"E\"};"
count,"int count = m.length();"
values,"map<string> values = m.'map(function (string value) returns string { return value.toLowerAscii(); }) .filter(function (string v) returns boolean { if (v == \"a\" || v == \"e\") { return true; } return false; });"
array,"string[] array = [];"
values,"string[] values = m.entries() .filter(function ([string, string] v) returns boolean { var [k, t] = v; if (k == \"a\" || k == \"e\") { return true; } return false; }) .'map(concatString) .reduce(function (string[] acc, string v) returns string[] { acc.push(v); return acc; }, array);"
xdata,"'xml:Element xdata = <'xml:Element> xml `<p:person xmlns:p=\"foo\" xmlns:q=\"bar\"> <p:name>bob</p:name> <p:address> <p:city>NY</p:city> <q:country>US</q:country> </p:address> <q:ID>1131313</q:ID> </p:person>`;"
nodeCount,"int nodeCount = (xdata/*).length();"
elementCount,"int elementCount = (xdata/*).elements().length();"
ch,"xml ch = xdata.getChildren().elements()[1];"
che,"'xml:Element che = <'xml:Element> ch;"
m,"xml m = che.getChildren().elements() .'map(function ('xml:Element x) returns ('xml:Element) { index += 1; return x; });"
bob,"person bob = {name:\"bob\", age:30};"
tom,"person tom = {name:\"tom\", age:20};"
sam,"person sam = {name:\"sam\", age:24};"
p,"person[] p = [bob, tom, sam];"
count,"int count = p.filter(isBellow25).length();"
names,"string[] names = p.'map(getName);"
s,"string[] s = [\"abc\", \"cd\", \"pqr\"];"
s,"var s = <string>a;"
r,"float[] r = [1.1, -2.2, 3.3, 4.4];"
i,"int i = s.length() + r.length();"
m,"map<string> m = {a:\"abc\", b:\"cd\", c:\"pqr\"};"
i,"int i = v.length();"
count,"any count = m.length();"
a,"int[] a = [-5, 2, 4, 5, 7, -8, -3, 2];"
c,"any c = a[0].min(...a);"
d,"any d = a[0].max(...a);"
e,"any e = ints:sum(...a);"
words,"map<string> words = { a: \"ant\", b: \"bear\", c: \"tiger\"};"
lambdaArray,"(function (int) returns boolean)[] lambdaArray = [];"
str1,"string str1 = \"\";"
values,"string[] values = m.keys() .'map(function (string key) returns string { count = count + 10; var k = key; return k.toLowerAscii(); }) .filter(function (string v) returns boolean { if (v == \"a\" || v == \"e\" && count != 0) { count = count + 10; return true; } return false; });"
str,"string str = \"start\";"
modified,"map<string> modified = m.entries() .'map(function ([string, string] tuple) returns [string, string] { var [key, value] = tuple; str = str + \"-\" + key + \" : \" + value; count = count + 10; return [key, value]; }) .filter(function ([string, string] v) returns boolean { var [k, t] = v; if (k == \"a\" || k == \"e\") { count = count + 10; return true; } return false; }) .'map(function ([string, string] v) returns string { var [v1, v2] = v; count = count + 10; return v1 + v2; });"
xdata,"xml xdata = xml `<p:person xmlns:p=\"foo\" xmlns:q=\"bar\"> <p:name>bob</p:name> <p:address> <p:city>NY</p:city> <q:country>US</q:country> </p:address> <q:ID>1131313</q:ID> </p:person>`;"
m,"xml m = (xdata/<*>[1]/<*>).'map(function (xml x) returns (xml) { index += 1; str = str + \"-\" + index.toString(); return x; });"
status,"boolean status = true;"
randomNum,"int randomNum = 0;"
s1,"Student s1 = {fname:\"aa\", age:30};"
s2,"Student s2 = {fname:\"bb\", age:20};"
s3,"Student s3 = {fname:\"cc\", age:24};"
studentArr,"Student[] studentArr = [s1, s2, s3];"
count,"int count = studentArr.filter(function (Student stu) returns boolean { randomNum = randomNum + 2; return status && stu.age < 25; }).length();"
names,"string[] names = studentArr.'map(function (Student stu) returns string { return stu.fname; });"
str,"string str = \"The start-\";"
s,"string[] s = [\"abc\", \"cde\", \"pqr\", \"xy\"];"
filteredArr,"string [] filteredArr = s.filter(function (string s1) returns boolean { return s1.length() == 3; }) .'map(function (string s1) returns string { str = str + \" hello \" + s1 + \" :) bye :) \"; return (str + s1); });"
str,"string str = \"\";"
strArr,"string[] strArr = [\"abc\", \"cde\", \"pqr\", \"xyz\"];"
floatArr,"float[] floatArr = [1.1, -2.2, 3.3, 4.4];"
x,"var x = function (any a) { var s = <string>a; str = s; strArr[4] = \"mno\"; };"
i,"int i = strArr.length() + floatArr.length();"
count,"int count = 2;"
v,"var v = value;"
j,"json j = { \"address_components\": [ { \"long_name\": \"1823\", \"short_name\": \"1823\", \"types\": [ \"street_number\" ] }, { \"long_name\": \"Bonpland\", \"short_name\": \"Bonpland\", \"types\": [ \"street_number\" ] }, { \"long_name\": \"Palermo\", \"short_name\": \"Palermo\", \"types\": [ \"sublocality_level_1\", \"sublocality\", \"political\" ] }, { \"long_name\": \"Comuna 14\", \"short_name\": \"Comuna 14\", \"types\": [ \"administrative_area_level_2\", \"political\" ] }, { \"long_name\": \"Buenos Aires\", \"short_name\": \"CABA\", \"types\": [ \"administrative_area_level_1\", \"political\" ] }, { \"long_name\": \"Argentina\", \"short_name\": \"AR\", \"types\": [ \"country\", \"political\" ] }, { \"long_name\": \"C1414\", \"short_name\": \"C1414\", \"types\": [ \"postal_code\" ] }, { \"long_name\": \"CMW\", \"short_name\": \"CMW\", \"types\": [ \"postal_code_suffix\" ] } ] };"
filteredResults,"json[] filteredResults = [];"
filterFrom,"string filterFrom = \"street_number\";"
addressComp,"json[] addressComp = <json[]> checkpanic j.address_components;"
compTypes,"json[] compTypes = <json[]> checkpanic comp.types;"
bookstore,"xml bookstore = xml `<bookstore> <book category=\"cooking\"> <title lang=\"en\">Everyday Italian</title> <author>Giada De Laurentiis</author> <year>2005</year> <price>30.00</price> </book> <book category=\"children\"> <title lang=\"en\">Harry Potter</title> <author>J. K. Rowling</author> <year>2005</year> <price>29.99</price> </book> <book category=\"web\"> <title lang=\"en\">XQuery Kick Start</title> <author>James McGovern</author> <author>Per Bothner</author> <author>Kurt Cagle</author> <author>James Linn</author> <author>Vaidyanathan Nagarajan</author> <year>2003</year> <price>49.99</price> </book> <book category=\"web\" cover=\"paperback\"> <title lang=\"en\">Learning XML</title> <author>Erik T. Ray</author> <year>2003</year> <price>39.95</price> </book> </bookstore>`;"
titles,"[int, string][] titles = [];"
bal1,"Balance bal1 = {asset:\"BTC\", free:\"12\", locked:\"8\"};"
bal2,"Balance bal2 = {asset:\"LTC\", free:\"2\", locked:\"1\"};"
bal3,"Balance bal3 = {asset:\"BTC\", free:\"20\", locked:\"3\"};"
wal,"Wallet wal = {balances:[bal1, bal2, bal3]};"
BTC,"string BTC = \"BTC\";"
bal,"Balance[] bal = wal.balances.filter( function (Balance b) returns boolean { return b.asset == BTC; } );"
strArr,"string[] strArr = [];"
currency,"string currency = \"USD\";"
closure,"var closure = function (string key) { strArr[index] = currency; index += 1; };"
currencies,"map<int> currencies = { USD: 318, EUR: 322, GBP: 400 };"
yearAndAge1,"[int, Age] yearAndAge1 = [1992, {age: 26, format: \"Y\"}];"
yearAndAge2,"[int, Age] yearAndAge2 = [1994, {age: 24, format: \"x\"}];"
yearAndAge3,"[int, Age] yearAndAge3 = [1996, {age: 22, format: \"Z\"}];"
ch1,"Child ch1 = {name: \"A\", yearAndAge: yearAndAge1};"
ch2,"Child ch2 = {name: \"B\", yearAndAge: yearAndAge2};"
ch3,"Child ch3 = {name: \"C\", yearAndAge: yearAndAge3};"
namesOfChildren,"string[] namesOfChildren;"
children,"Child[] children;"
child,"map<anydata|error> child = {};"
parent,"Parent parent = {namesOfChildren: [\"A\", \"B\"], children: [ch1, ch2], child: ch3};"
name,"string name;"
yearInt,"int yearInt;"
age,"int age;"
format,"string format;"
other1,"map<anydata|error> other1 = {};"
other2,"map<any> other2 = {};"
rec1,"IntRestRecord rec1 = { name: \"A\", married: true, \"age\": 19, \"token\": 200 };"
a1,"any a1 = other1;"
empDetails,"EmployeeDetails empDetails = { emp\:name: \"Joy\", id: 12 };"
emp\:name,"string emp\:name;"
id,"int id;"
prodDetails,"ProductDetails prodDetails = {quantity: 1234};"
details,"[EmployeeDetails, ProductDetails] details = [{id: 234, emp\:name: \"Amy\"}, {x\:code: \"basic\", quantity: 324}];"
d,"string d;"
f1,"ReadOnlyRecord f1 = {x: [1, 2], y: \"s1\"};"
x,"int[] & readonly x;"
y,"string y;"
r,"readonly & record { int[] a; ReadOnlyRecord b; } r = {a: [12, 34, 56], b: f1};"
a,"int[] & readonly a;"
x2,"int[] & readonly x2;"
y2,"string y2;"
c,"int[] c;"
d,"int[] d;"
x,"record {| string a; string b; |} x = {a: \"foo\", b: \"bar\"};"
y,"ClosedRec y = {a: \"foo2\", b: \"bar2\"};"
v,"record { string a; string b; } v = {a: \"foo3\", b: \"bar3\"};"
w,"OpenRec w = {a: \"foo4\", b: \"bar4\"};"
foo,"Foo foo = {name:\"Test\", age:23};"
bar,"Bar bar = {id:34, flag:true};"
fooObj,"FooObj fooObj = new (\"Fooo\", 3.7, 23);"
barObj,"BarObj barObj = new (true, 56);"
b,"[[Foo, [BarObj, FooObj]], Bar] [[f, [bo, fo]], b] = [[foo, [barObj, fooObj]], bar];"
br,"[int, Foo, [BarObj, string, FooObj], Bar, boolean] [i, fr, [bo, s, fo], br, b] = [12, foo, [barObj, \"DDD\", fooObj], bar, true];"
b,"[int, Foo, [BarObj, string, FooObj], Bar, boolean] [i, fr, [bo, s, fo], br, b] = [12, foo, [barObj, \"DDD\", fooObj], bar, true];"
t,"[[string, [int, [boolean, int]]], [float, int]] t = [[\"Bal\", [3, [true, 34]]], [5.6, 45]];"
a,"any a = t;"
t1,"[int, [string, boolean]] t1 = [2002, [\"S1\", true]];"
m,"map<anydata> m = {};"
a1,"[int, string, boolean...] a1 = [12, \"ABC\", false, true, false];"
x,"boolean[] x = b;"
y,"[int, string, string] y = c;"
e,"[[string, int], float] [[c, d], e] = [[c, d], 6.7];"
l,"[[string, [int, [boolean, string], float[]], int[]], float] [[h, [i, [j, k], l], m], n] = [[\"A\", [i, [j, \"B\"], l], m], n];"
m,"[[string, [int, [boolean, string], float[]], int[]], float] [[h, [i, [j, k], l], m], n] = [[\"A\", [i, [j, \"B\"], l], m], n];"
n,"[[string, [int, [boolean, string], float[]], int[]], float] [[h, [i, [j, k], l], m], n] = [[\"A\", [i, [j, \"B\"], l], m], n];"
t1,"ReadOnlyTuple t1 = [[1, 2], \"s1\"];"
a,"string[] & readonly a;"
t2,"readonly & [int[], ReadOnlyTuple] t2 = [[12, 34, 56], t1];"
c,"readonly & string[] c;"
d,"readonly & int[] d;"
a,"[int, int] a = [10, 20];"
b,"[[int, string], int[]] b = [[10, \"a\"], [20, 30, 40, 50]];"
c,"[[int, string], int[]] c = [[10, \"a\"], [20, 30, 40, 50]];"
c4,"var [[c1, c2, ...c3], c4] = c;"
x,"[int, [int, int]] x = [1, [2, 3]];"
e,"FileOpenError e = error FileOpenError(FILE_OPN, message=\"file open failed\", targetFileName=\"/usr/bhah/a.log\", errorCode=45221, flags=128);"
reason2,"string reason2;"
messageX,"string messageX;"
rest2,"map<any> rest2;"
e,"error e = error(\"reasonPhrase\", other = \"other value\");"
reason,"string reason;"
other,"anydata|readonly other;"
errWithMap,"StrError errWithMap = error StrError(\"Error\", message = \"Fatal\", fatal = \"true\");"
detailMap,"map<string|readonly> detailMap;"
detail,"map<string|readonly> detail;"
e,"SampleError e = error(\"the reason\");"
e,"FooError e = error(\"the reason\", message=\"msg\", fatal = false);"
message,"value:Cloneable message;"
fatal,"boolean fatal;"
rest,"map<value:Cloneable> rest;"
causeErr,"error causeErr = error(\"c\");"
e,"FileOpenError e = error FileOpenError(FILE_OPN, message=\"file open failed\", targetFileName=\"/usr/bhah/a.log\", errorCode=45221, flags=128, cause=causeErr);"
fileName,"string fileName;"
errorCode,"int errorCode;"
flags,"int flags;"
upcast,"error upcast = e;"
rest2,"map<string|int|error> rest2;"
e,"FooError e = error(\"errorCode\", message = \"message\", fatal = false);"
other,"anydata|error other;"
intArray,"int[] intArray = [1, 2, 3, 4];"
fooArray,"Foo[2] fooArray = [{a : 1, b : \"1\"}, {a: 2, b : \"2\"}];"
a,"Foo a;"
b,"Foo b;"
fooArray,"Foo[] fooArray = [{a : 1, b : \"1\"}, {a: 2, b : \"2\"}];"
a,"Foo[] a;"
c,"string c;"
d,"map<anydata|error> d;"
a,"Bar[] a;"
tupleArray,"[int, int][3] tupleArray = [[1, 1], [2, 2], [3, 3]];"
a,"[int, int] a;"
b,"[int, int] b;"
d,"int d;"
t,"[string, [int, boolean]] t = [\"Ballerina\", [123, true]];"
foo2,"Foo foo2 = {name:\"TestUpdate\", age:24};"
bar2,"Bar bar2 = {id:35, flag:false};"
fooObj2,"FooObj fooObj2 = new (\"FoooUpdate\", 4.7, 24);"
barObj2,"BarObj barObj2 = new (false, 66);"
foo1,"Foo foo1 = {name:\"Test\", age:23};"
bar1,"Bar bar1 = {id:34, flag:true};"
fooObj1,"FooObj fooObj1 = new (\"Fooo\", 3.7, 23);"
barObj1,"BarObj barObj1 = new (true, 56);"
v1,"string|int|float v1 = 34;"
v2,"string|float v2 = 6.7;"
v3,"string v3 = \"Test\";"
v,"[string|int|float, [string|float, string]] v = [34, [6.7, \"Test\"]];"
c,"[[string|int, int|boolean], float|[int, boolean], [string|float, string]] [[a, b], c, [d, e]] = [[12, true], [45, false], [\"Hello\", \"World\"]];"
v3,"[[string|int, int|boolean], float|[int, boolean], [string|float, string]] [[v1, v2], v3, [v4, v5]] = [[\"TestUpdated\", 23], 4.5, [5.7, \"FooUpdated\"]];"
c,"[[string|int, int|boolean], float|[int, boolean], [string|float, string]] [[a, b], c, [d, e]] = [[\"Test\", 23], [45, false], [\"Hello\", \"World\"]];"
t1,"[string, int, float...] t1 = [\"A\", 100, 200.5, 300.5];"
x1,"[int, float...] x1;"
x2,"float[] x2;"
t2,"[[int...]...] t2 = [[1, 2, 3, 4], [5, 6]];"
t3,"[int, string] t3 = [12, \"A\"];"
x3,"[string] x3 = d2;"
e4,"Bar e4;"
e5,"int[] e5;"
t4,"[[string, Bar, boolean...], string, boolean[]] t4 = [[\"Ballerina\", {id: 34, flag: true}, false], \"A\", [true, false]];"
t5,"[[string, [error, map<string>, int, (FooObj|BarObj)...], Bar, (byte|float)...], string, boolean...] t5 = [[\"Ballerina\", [error(\"Error\", detail1= 12, detail2= true), {firstName: \"John\", lastName: \"Damon\"}, 12, fooObj1, barObj1], {id: 34, flag: true}, 10.5, 20], \"A\", true, false];"
fooObj2,"FooObj fooObj2 = new (\"Foo2\", 10.2, 30);"
barObj2,"BarObj barObj2 = new (false, 56);"
barObj3,"BarObj barObj3 = new (true, 58);"
t6,"int[5] t6 = [10, 20, 30, 40, 50];"
t7,"(int|Bar)[5] t7 = [10, 20, {id: 34, flag: true}, 40, {id: 35, flag: false}];"
c,"readonly & int[] c;"
e,"string e;"
f,"int[] f;"
g,"int[] g;"
sampleErr,"SampleError sampleErr = error(\"Transaction Failure\", error(\"Database Error\"), code = 20, reason = \"deadlock condition\");"
message1,"var error(message1, _, code = code1, reason = reason1) = sampleErr;"
code1,"var error(message1, _, code = code1, reason = reason1) = sampleErr;"
reason1,"var error(message1, _, code = code1, reason = reason1) = sampleErr;"
code2,"var error(_, _, code = code2, reason = reason2) = sampleErr;"
reason2,"var error(_, _, code = code2, reason = reason2) = sampleErr;"
message3,"SampleError error(message3, _, code = code3, reason = reason3) = sampleErr;"
code3,"SampleError error(message3, _, code = code3, reason = reason3) = sampleErr;"
reason3,"SampleError error(message3, _, code = code3, reason = reason3) = sampleErr;"
code4,"SampleError error(_, _, code = code4, reason = reason4) = sampleErr;"
reason4,"SampleError error(_, _, code = code4, reason = reason4) = sampleErr;"
testRecord,"TestRecord testRecord = {errorNum2: 1223, errorString2: \"ERROR\", err: sampleErr};"
firstName,"TestRecord {errorNum2: _, errorString2: firstName, err: error(message6, _, code = code6, reason = reason6)} = testRecord;"
message6,"TestRecord {errorNum2: _, errorString2: firstName, err: error(message6, _, code = code6, reason = reason6)} = testRecord;"
code6,"TestRecord {errorNum2: _, errorString2: firstName, err: error(message6, _, code = code6, reason = reason6)} = testRecord;"
reason6,"TestRecord {errorNum2: _, errorString2: firstName, err: error(message6, _, code = code6, reason = reason6)} = testRecord;"
myErr,"MyError myErr = error(\"Illegal Return\", sampleErr, errNum = 20, errReason = \"empty content\");"
message7,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
message8,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
code8,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
reason8,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
code7,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
reason7,"var error(message7, error(message8, _, code = code8, reason = reason8), errNum = code7, errReason = reason7) = myErr;"
message9,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
message10,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
code10,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
reason10,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
code9,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
reason9,"MyError error(message9, error(message10, _, code = code10, reason = reason10), errNum = code9, errReason = reason9) = myErr;"
t2,"[string?, [float, boolean], int...] t2 = [\"hi\", [1.0, true], 1, 2];"
z1,"string z1 = let map<string> z2 = {z1} in z2[\"ar\"] ?: \"nil\";"
v1,"string v1 = let string v2 = \"A\" in let string[] v3 = [func(v3)] in v3[0];"
pr,"Person pr = new;"
a1,"string a1 = let [string, string] [a2, a3] = [pr.getName(a1)] in a2;"
a4,"string a4 = let [string, string] [a2, a3] = [pr.getName(a4), getString(a3)] in a2;"
a5,"string a5 = let [string, string] [a2, a3] = [getString(a5), getString(a3)] in a2;"
a6,"string a6 = let [string, string] a2 = [getString(a2), \"A\"] in a2[0];"
a7,"string a7 = let map<string> a8 = {a7} in getString(a7);"
a9,"string a9 = let map<string> a8 = {\"1\": a8} in pr.getName(a9);"
a10,"string a10 = let map<string> a8 = {\"1\": getString(a10)} in a8[\"1\"] ?: \"nil\";"
a11,"string a11 = let map<string> a8 = {\"1\": getString(a8)} in pr.getName(a11);"
result,"var result = foo();"
x,"PreparedResult x = \"ss\";"
m,"map<any> m = {a:\"1A\", b:\"2B\", c:\"3C\", d:\"4D\"};"
val,"string val;"
m,"map<any> m = {a:\"1A\", b:\"2B\", c:\"3C\"};"
val1,"string val1;"
val2,"string val2;"
name,"int name;"
c,"Client c = new();"
a,"int a = c->foo();"
sm,"map<string> sm = c->foo1();"
d,"var { a: d } = c->foo2();"
ea,"error[] ea = [];"
j,"any[] j = ea;"
anyArray,"any[] anyArray = [];"
errorArray,"error[] errorArray = anyArray;"
err,"CLError?[] err = [];"
errs,"error?[] errs = err;"
e1,"error e1 = error(\"E1\");"
x,"error[] x = [e1];"
y,"error|int[] y = x;"
y,"int|error[] y = e1;"
func,"function (any|error...) returns () func = function (any... y) {};"
a,"Type a = [\"tuple\", \"A\", \"A\", \"A\"];"
b,"List b = a;"
b,"record{int a;} b = {a: 1};"
a,"[int, string] a = [1, \"a\"];"
t,"Topt t = {a: 2, c: [{b: 4}]};"
d,"var { a: d } = c->foo1();"
r,"var error(r) = c->foo2();"
r2,"var error(r2, failedAttempts = failedAttempts) = c->foo3();"
failedAttempts,"var error(r2, failedAttempts = failedAttempts) = c->foo3();"
errorReason,"string errorReason = \"TestError\";"
testError,"error testError = error(errorReason);"
errorArray,"error[] errorArray = [testError];"
anyVal,"any anyVal = errorArray;"
errorArrayBack,"error[] errorArrayBack = <error[]>anyVal;"
intArray,"int[*] intArray = [1, 2];"
jsonVar,"json jsonVar = intArray;"
arr,"int[2] arr = <int[2]> jsonVar;"
arr1,"int[]|string[] arr1 = <int[]>[1, 2];"
arr2,"(int|float)[]|string[] arr2 = arr1;"
x,"any x = 4;"
y,"any|error y = x;"
t,"Topt1 t = {x: 2, y: 4};"
t,"Topt2 t = {a: 2, c: [{b: 4}]};"
t3,"Topt3 t3 = {x: 2, y: 4};"
t1,"Topt1 t1 = {x: 21, y: 41};"
t,"Topt4 t = {x: 2, y: 4};"
x,"int|string x = 5;"
y,"int|string y = 8;"
z,"int z = x;"
s,"string s = x;"
x,"int|string|boolean x = 5;"
y,"int y = 8;"
x,"int|string|boolean|float x = 5;"
y,"int y = x;"
s,"Student s = {name:\"John\", age:20, gpa:3.5};"
x,"Person|Student x = s;"
y,"string y = x;"
z,"string z = x;"
x,"int|string|boolean x = 8;"
y,"int|string|boolean y = 8;"
a,"int|string a = x;"
b,"int b = x;"
c,"int c = x;"
d,"int d = x;"
e,"int e = x;"
f,"int f = x;"
g,"int g = x;"
h,"string h = y;"
i,"int i = x;"
j,"string j = y;"
j,"int|string j = x;"
i,"int|string|boolean i = x;"
s2,"string s2 = si;"
i,"int i = si;"
strVal,"string strVal = s;"
intVal,"int intVal = i;"
s,"var error(s, message = message, code = code) = errorReturningFunc(1);"
message,"var error(s, message = message, code = code) = errorReturningFunc(1);"
code,"var error(s, message = message, code = code) = errorReturningFunc(1);"
intVal,"int intVal = code;"
i,"int? i = ();"
j,"int j = 100;"
n,"() n = i;"
k,"int k = j;"
x,"record {| boolean b; |} x = {b: true};"
y,"record {| byte i?; boolean b?; |} y = x;"
rec,"record {| byte...; |} rec = y;"
cr,"ClosedRec cr = {i: 1, b: true};"
rec,"record {| byte...; |} rec = cr;"
cr2,"ClosedRecTwo cr2 = {i: 1, b: true};"
rec,"record {| byte...; |} rec = cr2;"
a,"int a = y;"
r1,"RecordWithNonReadOnlyField r1 = {i: 1};"
x,"RecordWithReadOnlyFieldAndNonReadOnlyField x = r1;"
x,"readonly x = r1;"
e,"RecordWithDefaultValue e = {};"
rec2,"record {| byte i; |} rec2 = e;"
m,"map<stream<int>> m = j;"
a,"boolean[] a = j;"
bar,"Bar? & readonly bar = ();"
t,"var t = bar?.t;"
x,"boolean x = bar?.baz;"
y,"(record {| string s; |} & readonly)? y = bar.baz;"
a,"string:Char a = \"r\";"
a2,"\"r\"|\"g\" a2 = a;"
b,"int:Unsigned16 b = 1;"
b2,"1 b2 = b;"
c,"Kinds c = 1;"
c2,"2|3 c2 = c;"
d,"Kinds d = \"g\";"
d2,"\"r\" d2 = d;"
e,"string:Char e = \"r\";"
e2,"\"r\"|\"g\"|\"x\" e2 = e;"
rec,"record {| byte i = 101; boolean b; |} rec = {b: true};"
f,"Quux f = rec;"
x,"var x = [f];"
x,"int|string|boolean x = a;"
f,"FooBarOneTwoBoolean f = 2.0;"
f,"FooBarOneTwoBoolean f = true;"
f,"FooBarOneTwoBoolean f = \"bar\";"
f,"FooBarOneTwoBoolean f = 1;"
f,"FooBarOneTwoBoolean f = false;"
x,"FooBarBaz x = f;"
x,"OneTwo x = f;"
x,"boolean x = f;"
x,"FooBarInt x = f;"
f,"TrueBazOne f = 1;"
g,"OneTrue g = f;"
f,"TrueBazOne f = \"baz\";"
b,"Baz b = f;"
s,"string s = \"hello world\";"
st,"string|typedesc<any> st = s;"
s2,"string s2 = st;"
s,"CyclicComplexUnion s = 1;"
ma,"anydata ma = <anydata> s;"
m,"float|CyclicComplexUnion m = <CyclicComplexUnion>ma;"
f2,"CyclicComplexUnion f2 = m;"
x,"xml x = xml `Hello World`;"
st,"string|xml st = x;"
t2,"xml t2 = st;"
t,"record{} t = { \"name\": \"Maryam\" };"
st,"string|record{} st = t;"
t2,"record{} t2 = st;"
s,"string s = \"bar\";"
f,"FooBar f = s;"
s2,"string s2 = s;"
f,"float f = 11.0;"
f2,"FooBarOneTwoBoolean f2 = f;"
f3,"float f3 = f;"
f,"FooBarTen f = \"bar\";"
g,"[FooBarTen, FloatFive, boolean] g = [f, FIVE, true];"
a,"any a = g;"
g,"[string|float|int, FloatFive, boolean] g = [f, FIVE, true];"
j,"IntTen j = i;"
k,"int k = i;"
q,"Foo|Bar|X|int q = 1;"
w,"Foo|Bar|int w = q;"
q,"Foo|Bar|X|int q = \"x\";"
a1,"any|error a1 = <error> error(reason);"
a2,"any|error a2 = <error> error(reason, code = 11, detail = \"detail message\");"
e3,"error e3 = a1;"
e4,"error e4 = a2;"
m,"map<value:Cloneable> m = <map<value:Cloneable>> e4.detail();"
d,"Details d = { message: \"detail message\" };"
e3,"MyError e3 = error MyError(ERR_REASON, message = d.message);"
e4,"MyErrorTwo e4 = error MyErrorTwo(ERR_REASON_TWO, message = \"detail message\");"
a1,"any|error a1 = e3;"
a2,"any|error a2 = e4;"
isSpecificError,"boolean isSpecificError = false;"
e5,"MyError e5 = a1;"
e6,"MyErrorTwo e6 = a2;"
m1,"Details m1 = e5.detail();"
m2,"Details m2 = e6.detail();"
isGenericError,"boolean isGenericError = a1 is error && a2 is error;"
d,"Details d = {message: \"detail message\"};"
e,"MyError|MyErrorTwo e = error MyError(ERR_REASON, message = d.message);"
e1,"MyErrorTwo|MyError e1 = error MyError(ERR_REASON, message = d.message);"
e3,"error e3 = error(ERR_REASON);"
e4,"error e4 = error(\"error reason x\", message = \"detail message\");"
a3,"any|error a3 = a1;"
a4,"any|error a4 = a2;"
s,"var {s: s, i: i, ...rest} = recordReturningFunc(1);"
i,"var {s: s, i: i, ...rest} = recordReturningFunc(1);"
s,"error<Detail> error(s, message = message, code = code) = errorReturningFunc(1);"
message,"error<Detail> error(s, message = message, code = code) = errorReturningFunc(1);"
code,"error<Detail> error(s, message = message, code = code) = errorReturningFunc(1);"
val,"string|int val = \"hello \";"
bool,"boolean bool = false;"
s,"string s = \"you\";"
s,"string s = \"world\";"
sampleValue,"XYZ|string sampleValue = {x: \"X\", y :\"Y\", z: -1};"
i,"int|string? i = 1;"
jo,"int jo = 0;"
qo,"int|string? qo = 0;"
ro,"int|string? ro = 0;"
j,"int j = i;"
s,"string s = i;"
q,"int|string? q = i;"
r,"int|string? r = i;"
jarr,"json[] jarr = [jo, i, qo, ro];"
result,"string result = testType(json);"
result,"string result = testType(XmlType);"
val,"AnydataOrObjectOpenRecord|int val = 11;"
val2,"AnydataOrObjectOpenRecord|int val2 = {};"
val3,"AnydataOrObjectOpenRecord|int val3 = <OpenRecordWithObjectField> {code: new (10)};"
cl,"Class cl = val3.code;"
val4,"OpenRecordWithObjectField val4 = {code: new (20)};"
val5,"OpenRecordWithObjectField val5 = <ClosedRecordWithObjectAndIntFields> {code: new (30), index: 0};"
val6,"OpenRecordWithIntField val6 = {i: 1, \"s\": \"hello\"};"
v,"record {| int i; string s; |} v = {i: 2, s: \"world\"};"
val7,"OpenRecordWithIntField val7 = v;"
val8,"ClosedRecordWithIntField val8 = {i: 10};"
val9,"int|ClosedRecordWithIntField val9 = <record {| byte i; |}> {i: 10};"
b,"byte b = 10;"
rec,"record {| byte i?; boolean b; |} rec = y;"
rec2,"record {| byte i?; boolean...; |} rec2 = y;"
x,"record {| int i; |} x = {i: 1};"
y,"record {| int i; boolean b?; |} y = x;"
z,"record {| int i; |} z = y;"
cr1,"ClosedRec cr1 = {i: 1, b: true};"
rec2,"record {| byte i?; boolean b = false; |} rec2 = {i: 100};"
cr2,"ClosedRec cr2 = rec2;"
rec,"record {| byte i?; boolean b; |} rec = cr2;"
cr3,"ClosedRec cr3 = <record {| byte i; boolean b; |}> {i: 45, b: true};"
rec,"record {| byte i; boolean b; |} rec = cr3;"
cr4,"ClosedRecThree cr4 = {i: 1, b: true};"
rec3,"record {| byte i?; boolean b = false; |} rec3 = {i: 100};"
cr5,"ClosedRecThree cr5 = rec3;"
rec,"record {| byte i?; boolean b; |} rec = cr5;"
cr6,"ClosedRecThree cr6 = <record {| byte i; boolean b = false; |}> {i: 45, b: true};"
rec,"record {| byte i; boolean b; |} rec = cr6;"
rec,"record {| byte i = 101; |} rec = {};"
f,"RecordWithDefaultValue f = rec;"
rec2,"record {| byte i; boolean b?; |} rec2 = f;"
rec3,"record {| byte i = 101; boolean b; |} rec3 = {b: true};"
g,"RecordWithDefaultValue g = rec3;"
rec2,"record {| byte i; boolean b?; |} rec2 = g;"
x,"record {| byte i; |} x = {i: 123};"
m,"map<int|string> m = x;"
rec,"record {| int i; |} rec = m;"
r1,"record {| int i; |} & readonly r1 = {i: 1};"
r2,"RecordWithNonReadOnlyField r2 = r1;"
x,"readonly x = r2;"
y,"record {| readonly int i; |} y = r2;"
r3,"record {| readonly int i; string s; |} r3 = {i: 123, s: \"hello\"};"
r4,"RecordWithNonReadOnlyField r4 = r3;"
x,"record {| readonly int i; string s; |} x = r2;"
m,"map<int|string> m = {a: 1, b: 2};"
m2,"map<int> m2 = {a: 1, b: 2};"
m3,"map<int|string> m3 = m2;"
m4,"map<int> m4 = m3;"
m,"map<int> m = j;"
a,"(int|boolean)[] a = j;"
y,"record {| string s; |}? y = bar?.baz;"
a2,"Colour a2 = a;"
b2,"Ints b2 = b;"
c2,"Ints c2 = c;"
d2,"Colour d2 = d;"
e2,"Colour e2 = e;"
rec,"Grault rec = {};"
v,"any v = x[0];"
c,"SomeRecord? c = {intField: 10};"
f,"SomeRecord? f = ();"
x,"any x = true;"
g,"SomeRecord|int|() g = 4;"
w,"SomeRecord|int w = 4;"
s,"SomeRecord|int|() s = 5;"
s,"SomeRecord s = g;"
x,"R x = r;"
a,"Type a = [\"list\", 1, \"C\"];"
b,"Type b = [\"tuple\", \"C\", \"C\", \"C\"];"
c,"Type c = \"C\";"
err,"int|error err = otherValues[0];"
err0,"error err0 = <error> err;"
val1,"int|error val1 = otherValues[1];"
val2,"int|error val2 = otherValues[2];"
td,"typedesc<function ()> td = typeof testVariableDeclaredInTupleAsAnnotationValue;"
xVal,"record {int i;}? xVal = td.@x;"
c,"string c = \"Duplicate string\";"
td,"typedesc<function ()> td = typeof testVariableDeclaredInRecordAsAnnotationValue;"
x,"int x = a;"
an,"any an = 112;"
k,"any k = 1;"
bar1,"ClosedBar1 bar1 = {var1: \"Ballerina\", var2: 500};"
bar2,"ClosedBar2 bar2 = {var1: \"Language\", var2: bar1};"
a1,"[string, int] | ClosedBar1 | ClosedBar2 | [int, boolean] | int | float a1 = [\"Hello\", 45];"
a2,"[string, int] | ClosedBar1 | ClosedBar2 | [int, boolean] | int | float a2 = bar1;"
a3,"[string, int] | ClosedBar1 | ClosedBar2 | [int, boolean] | int | float a3 = bar2;"
a4,"[string, int] | ClosedBar1 | ClosedBar2 | [int, boolean] | int | float a4 = [455, true];"
a5,"[string, int] | ClosedBar1 | ClosedBar2 | [int, boolean] | int | float a5 = 5.6;"
result,"string[] result = [typeGuard1(a1), typeGuard1(a2), typeGuard1(a3), typeGuard1(a4), typeGuard1(a5)];"
a1,"ClosedBar1 | ClosedBar2 | int | float a1 = bar1;"
a2,"ClosedBar1 | ClosedBar2 | int | float a2 = bar2;"
result,"string[] result = [typeGuard2(a1), typeGuard2(a2), typeGuard2(true)];"
foo,"FooRec foo = {var1: [12, \"Bal\"], var2: [12.5, true]};"
bar,"BarRec bar = {var1: [12.1, 100], var2: [400.1, foo]};"
result,"string[] result = [typeGuard3(foo), typeGuard3(bar), typeGuard3(true)];"
foo1,"RestParam foo1 = {var1: 500};"
foo2,"RestParam foo2 = {var1: 500, \"var2\": true};"
foo3,"RestParam foo3 = {var1: 500, \"var2\": true, \"var3\": true};"
bar1,"ClosedRec bar1 = {var1: \"Bal\"};"
result,"string[] result = [typeGuard4(foo1), typeGuard4(foo2), typeGuard4(foo3), typeGuard4(bar1)];"
rec,"RestParam rec = {var1: 500};"
rec2,"RestParam rec2 = {var1: 500, \"var2\": true};"
results,"string[] results = [matchClosedRecordPattern(rec), matchClosedRecordPattern(rec2)];"
rec,"record {} rec = {};"
result,"string[] result = [];"
foo,"ClosedFoo foo = {s: \"S\", i: 23};"
t,"[string, int, ClosedFoo] t = [\"A\", 12, foo];"
t1,"[int, string, [int...]] t1 = [12, \"ABC\", [10, 20, 30, 40]];"
matched,"string matched = \"Not Matched\";"
t1,"int[] t1 = [10, 20, 30, 40];"
t1,"[int, string[], map<string>] t1 = [1, [\"A\", \"B\", \"C\", \"D\"], {name: \"John\"}];"
err,"error err = error(\"Transaction Error\", error(\"Internal Error\", cause= {reason: \"Connection failure\", level: 3}, retryCount= 5), flag=true, commitCount= 2, reportTo= \"John\");"
t2,"[[string, [error, map<string>, int, (FooObj|BarObj)...], Bar, (byte|float)...], string, boolean...] t2 = [[\"Ballerina\", [error(\"Error\", detail1= 12, detail2= true), {firstName: \"John\", lastName: \"Damon\"}, 12, fooObj1, barObj1], {id: 34, flag: true}, 10.5, 20], \"A\", true, false];"
a1,"string a1;"
a2,"error a2;"
a3,"[map<string>, int, (FooObj|BarObj)...] a3;"
a4,"[Bar, (byte|float)...] a4;"
a5,"[string, boolean...] a5;"
a6,"map<string> a6;"
a7,"[int, (FooObj|BarObj)...] a7;"
b1,"string b1;"
b2,"error b2;"
b3,"[map<string>, int, (FooObj|BarObj)...] b3;"
b4,"[Bar, (byte|float)...] b4;"
b5,"[string, boolean...] b5;"
b6,"map<string> b6;"
b7,"[int, (FooObj|BarObj)...] b7;"
t3,"int[5] t3 = [1, 2, 3, 4, 5];"
a1,"int a1;"
a2,"[int, int, int, int] a2;"
a3,"int a3;"
a4,"[int, int, int] a4;"
t4,"int[] t4 = [1, 2, 3, 4, 5];"
a1,"int a1 = 10;"
a2,"[int...] a2 = [];"
a3,"[int...] a3 = [];"
err1,"error err1 = error(\"Error Code\");"
t1,"[string, map<any>] | error t1 = err1;"
er1,"ER1 er1 = error(\"Error 1\", fatal = true, message = \"message\");"
er2,"error er2 = error(\"Error 2\", message = \"It's fatal\", fatal = \"fatal string\");"
results,"string[] results = [foo(er1), foo(er2)];"
f,"Foo f = {fatal: true};"
err1,"error err1 = error(\"Error Code 1\");"
err2,"error err2 = error(\"Error Code 1\", message = \"Something Wrong\");"
err3,"error err3 = error(\"Error Code 1\", err2);"
fe1,"Foo | error fe1 = err1;"
fe2,"Foo | error fe2 = err2;"
results,"string[] results = [foo2(f), foo2(fe1), foo2(fe2), foo3(fe1), foo3(fe2)];"
m,"map<string> m = {key: \"value\"};"
mRes,"var mRes = trap panik();"
results,"string[] results = [foo4(m.get(\"key\")), foo4(mRes)];"
e,"error e = error(\"Just Panic\", message = \"Bit of detail\");"
err1,"error err1 = error(\"Error One\");"
results,"string[] results = [foo5(err1)];"
err3,"error<ErrorData2> err3 = error(\"Error Code 1\", message = \"Something Wrong\", fatal = true);"
results,"string[] results = [foo6(f), foo6(fe1), foo6(fe2)];"
err1,"error<ErrorData2> err1 = error(\"Error One\", message = \"msgOne\", fatal = true);"
err2,"error<ErrorData2> err2 = error(\"Error Three\", message = \"msgTwo\", fatal = false);"
err3,"error<ErrorData2> | error<ErrorData2> err3 = err1;"
err4,"error<ErrorData2> | error<ErrorData2> err4 = err2;"
results,"string[] results = [matching(err3), matching(err4)];"
err1,"error<ErrorData> err1 = error(\"Error Code\", message = \"Msg\");"
err1,"ER err1 = error(\"Error Code\", message = \"Msg\");"
se,"string|error se = error(\"test reason\", message=\"error detail message\");"
a,"[string, [int, float]] a = [\"S\", [23, 5.6]];"
a1,"[string, int] | [float, boolean] | [float, string, boolean] | float a1 = 66.6;"
a2,"[string, int] | [float, boolean] | [float, string, boolean] | float a2 = [\"Hello\", 12];"
a3,"[string, int] | [float, boolean] | [float, string, boolean] | float a3 = [4.5, true];"
a4,"[string, int] | [float, boolean] | [float, string, boolean] | float a4 = [6.7, \"Test\", false];"
result,"string[] result = [foo1(a1), foo1(a2), foo1(a3), foo1(a4)];"
a1,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a1 = 66.6;"
a2,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a2 = [\"Hello\", 34];"
a3,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a3 = [66.6, [\"Test\", [true, 456]]];"
a4,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a4 = [5.6, [\"Ballerina\", false]];"
a5,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a5 = [\"Bal\", 543, new(4)];"
result,"string[] result = [bar1(a1), bar1(a2), bar1(a3), bar1(a4), bar1(a5)];"
result,"string[] result = [baz1(a1), baz1(a2), baz1(a3), baz1(a4), baz1(a5)];"
result,"string[] result = [bar2(a1), bar2(a2), bar2(a3), bar2(a4), bar2(a5)];"
a5,"[string, int] | [float, [string, boolean]] | [float, [string, [boolean, int]]] | float | [string, int, NoFillerObject] a5 = [\"Bal\", 543, new(2)];"
result,"string[] result = [baz2(a1), baz2(a2), baz2(a3), baz2(a4), baz2(a5)];"
a1,"[string, int] | [float, boolean] | [boolean, int] | [int, boolean] | int | float a1 = [\"Hello\", 45];"
a2,"[string, int] | [float, boolean] | [boolean, int] | [int, boolean] | int | float a2 = [4.5, true];"
a3,"[string, int] | [float, boolean] | [boolean, int] | [int, boolean] | int | float a3 = [false, 4];"
ib,"[int, boolean] ib = [455, true];"
a4,"[string, int] | [float, boolean] | [boolean, int] | [int, boolean] | int | float a4 = ib;"
a5,"[string, int] | [float, boolean] | [boolean, int] | [int, boolean] | float a5 = 5.6;"
result,"string[] result = [foo3(a1), foo3(a2), foo3(a3), foo3(a4), foo3(a5)];"
a1,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | float a1 = [\"Hello\", 45, 5.6];"
a2,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | float a2 = [5.7, [true, 67]];"
a3,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | float a3 = [[true, 67], 7.8];"
a4,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | float a4 = [678, false];"
a5,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | float a5 = 67.89;"
result,"string[] result = [foo4(a1), foo4(a2), foo4(a3), foo4(a4), foo4(a5)];"
result,"string[] result = [foo5(a1), foo5(a2), foo5(a3), foo5(a4), foo5(a5)];"
fooRec1,"FooRec fooRec1 = {s: \"S\", i: 23, f: 5.6};"
barRec1,"BarRec barRec1 = {b: 12, f: fooRec1};"
a1,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a1 = [fooRec1, barRec1];"
a2,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a2 = [fooRec1, 4.5];"
a3,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a3 = [barRec1, fooRec1];"
a4,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a4 = [barRec1, 543];"
a5,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a5 = [5.2, fooRec1];"
a6,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a6 = [15, barRec1];"
a7,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a7 = [65, 7.4];"
a8,"[FooRec | int, BarRec | float] | [BarRec | float, FooRec | int] a8 = [3.6, 42];"
a1,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a1 = [\"Hello\", 45, 5.6];"
a2,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a2 = [5.7, [true, 67]];"
a3,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a3 = [[true, 67], 7.8];"
a4,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a4 = [678, false];"
a5,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a5 = 876;"
a6,"[string, int, float] | [float, [boolean, int]] | [[boolean, int], float] | [int, boolean] | int | float a6 = 67.89;"
result,"string[] result = [foo7(a1), foo7(a2), foo7(a3), foo7(a4), foo7(a5), foo7(a6)];"
foo,"Foo2 foo = {s: \"S\", i: 23, f: 5.6};"
bar,"Bar bar = {b: 12, f: foo};"
tuple,"[Foo2, [int, Bar], byte] tuple = [foo, [100, bar], 200];"
v,"any|error v = error(\"{UserGenError}Error\");"
foo1,"OpenedFoo foo1 = {s: \"S\", i: 23};"
m2,"string m2 = m;"
c2,"error? c2 = c;"
x1,"value:Cloneable x1 = d;"
x2,"value:Cloneable x2 = e;"
details,"map<any|error> details = {};"
e1,"MyErrorX|MyErrorY e1 = error MyErrorX(\"MyErrorX\", x = 2);"
e2,"MyErrorX|MyErrorY e2 = error MyErrorY(\"MyErrorY\", y = 2);"
v2,"any v2 = 0;"
v3,"int v3 = 2;"
v5,"[int, int] v5 = [1, 2];"
v1,"[int, int] v1 = [1, 2];"
v2,"[int, int] v2 = [1, 2];"
v,"[any, any] v = [1, 2];"
v,"[int, int] v = [1, 3];"
v,"[int, [string]] v = [1, [\"3\"]];"
v,"[int, [any]] v = [1, [\"3\"]];"
v,"[[int, [string]]] v = [[1, [\"3\"]]];"
m,"string[] m = p;"
n,"(int)[][] n = oth;"
c,"A c = [a, b];"
c,"B c = {a: x, b: y};"
a1,"[string, int]|[float, boolean]|[float, string, boolean]|float a1 = 66.6;"
a2,"[string, int]|[float, boolean]|[float, string, boolean]|float a2 = [\"Hello\", 12];"
a3,"[string, int]|[float, boolean]|[float, string, boolean]|float a3 = [4.5, true];"
a4,"[string, int]|[float, boolean]|[float, string, boolean]|float a4 = [6.7, \"Test\", false];"
a1,"float a1 = 66.6;"
a2,"[string, int] a2 = [\"Hello\", 34];"
a3,"[float, [string, [boolean, int]]] a3 = [66.6, [\"Test\", [true, 456]]];"
a4,"[float, [string, boolean]] a4 = [5.6, [\"Ballerina\", false]];"
a1,"[string, int]|[float, boolean]|[boolean, int]|[int, boolean]|int|float a1 = [\"Hello\", 45];"
a2,"[string, int]|[float, boolean]|[boolean, int]|[int, boolean]|int|float a2 = [4.5, true];"
a3,"[string, int]|[float, boolean]|[boolean, int]|[int, boolean]|int|float a3 = [false, 4];"
a4,"[string, int]|[float, boolean]|[boolean, int]|[int, boolean]|int|float a4 = ib;"
a5,"[string, int]|[float, boolean]|[boolean, int]|[int, boolean]|float a5 = 5.6;"
a1,"[string, int, float]|[float, [boolean, int]]|[[boolean, int], float]|[int, boolean]|float a1 = [\"Hello\", 45, 5.6];"
a2,"[string, int, float]|[float, [boolean, int]]|[[boolean, int], float]|[int, boolean]|float a2 = [5.7, [true, 67]];"
a3,"[string, int, float]|[float, [boolean, int]]|[[boolean, int], float]|[int, boolean]|float a3 = [[true, 67], 7.8];"
a4,"[string, int, float]|[float, [boolean, int]]|[[boolean, int], float]|[int, boolean]|float a4 = [678, false];"
a5,"[string, int, float]|[float, [boolean, int]]|[[boolean, int], float]|[int, boolean]|float a5 = 67.89;"
a1,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a1 = [fooRec1, barRec1];"
a2,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a2 = [fooRec1, 4.5];"
a3,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a3 = [barRec1, fooRec1];"
a4,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a4 = [barRec1, 543];"
a5,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a5 = [5.2, fooRec1];"
a6,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a6 = [15, barRec1];"
a7,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a7 = [65, 7.4];"
a8,"[int|FooRec, float|BarRec]|[float|BarRec, int|FooRec] a8 = [3.6, 42];"
v,"[boolean, string]|[int, string, decimal] v = [1, \"A\", 1.1d];"
sealedArray,"boolean[3] sealedArray = [];"
returnedBoolArray,"boolean[3] returnedBoolArray = [];"
returnedStrArray,"string[2] returnedStrArray = [\"\"];"
sealedStrArray,"string[*] sealedStrArray = [\"Sam\", \"Smith\"];"
x1,"boolean[3] x1 = [true, false, true];"
x2,"boolean x2 = x1[index];"
x1,"int[3] x1 = [1, 2, 3];"
x2,"int[] x2 = x1;"
x1,"int[3] x1 = [1, 2];"
unionArray,"myUnion[3] unionArray = [];"
unionArray,"myFloatUnion[2] unionArray = [];"
unionArray,"myBooleanUnion[2] unionArray = [];"
unionArray,"myNullableUnion[3] unionArray = [];"
unionArray,"multiTypeUnion[3] unionArray = [];"
sealedArray,"json[5] sealedArray = [false, \"abc\", \"12\", -12, \".\"];"
sealedArray,"json[*] sealedArray = [false, \"abc\", \"12\", -12, \".\"];"
x1,"json[3] x1 = [true, 12, false];"
x1,"json[3] x1 = [1, true, \"3\"];"
x2,"json[] x2 = x1;"
sealedArray,"json[5] sealedArray = [(), (), (), (), ()];"
sealedArray,"json[5] sealedArray = [(), ()];"
x,"map<int[]> x = {};"
arr,"int[] arr = <int[]>x[\"v1\"];"
a,"xml a = xml `<name>Ballerina</name>`;"
sealedArray,"xml[5] sealedArray = [a, a];"
a,"Bar a = 1;"
sealedArray,"Bar[5] sealedArray = [a, a];"
sealedArray,"int[constLength] sealedArray = [1];"
actual,"int actual = arr.length();"
actual,"anydata actual = arr[index];"
actual,"string actual = arr.toString().trim();"
r,"boolean r = reason;"
m,"string m = message;"
err,"error err = error(\"Error Code\", message = \"Fatal\");"
reason,"var error (reason, message = message) = err;"
message,"var error (reason, message = message) = err;"
f3,"[[string, int], float] [[s3, [i3, r3]], f3] = [[\"D\", 4], 6.7];"
b,"[[Foo, [BarObj, FooObj]], Bar] [[f, [bo, fo]], b] = [[bar, [fooObj, barObj]], foo];"
b,"[Foo, [BarObj, FooObj], Bar] [f, [bo, fo], b] = [bar, fooObj, foo];"
br,"[int, Foo, [BarObj, string, FooObj], Bar, boolean] [i, fr, [bo, s, fo], br, b] = [bar, 12, [fooObj, \"DD\", barObj], foo, true];"
b,"[int, Foo, [BarObj, string, FooObj], Bar, boolean] [i, fr, [bo, s, fo], br, b] = [bar, 12, [fooObj, \"DD\", barObj], foo, true];"
t,"T t = [1];"
i,"[int, int] i = [1, 2];"
f,"Foo f = { message: \"fooMsg\", fatal: false };"
t1,"[int, string, error, [error, Foo]] t1 = [12, \"Bal\", error(\"Err\", message = \"Something Wrong\"), [error(\"Err2\", message = \"Something Wrong2\"), f]];"
t1,"[int, string, [error, boolean]] t1 = [12, \"Bal\", [error(\"Err2\", message = \"Something Wrong2\"), true]];"
b,"Bar b = { x: 1000, e: error(\"Err3\", message = \"Something Wrong3\") };"
reason,"Bar { x, e: error(reason, ...detail) } = b;"
err,"SealedError err = error(\"Error Code\", message = \"Fatal\");"
reason,"error <simpleError> error(reason, message = message) = err;"
message,"error <simpleError> error(reason, message = message) = err;"
reason,"error error (reason) = err;"
reason2,"error error (reason2) = err;"
err1,"SMS err1 = error SMS(\"Error One\", message = \"Msg One\", detail = \"Detail Msg\");"
reason3,"SMS error (reason3) = err1;"
reason4,"SMS error (reason4) = err1;"
err2,"FooError err2 = error FooError(\"Error Two\", message = \"Something Wrong\", fatal = true);"
reason5,"FooError error (reason5) = err2;"
reason6,"FooError error (reason6) = err2;"
reason7,"var error (reason7) = err2;"
reason8,"var error (reason8) = err2;"
e,"BeeError e = error BeeError(R, message=\"Msg\", fatal=false, other=\"k\");"
m,"var error(_, message=m, fatal=f, ...rest) = e;"
f,"var error(_, message=m, fatal=f, ...rest) = e;"
e,"SealedError e = error SealedError(\"sealed\", message=\"Msg\");"
reason,"var error(reason, ...rest) = e;"
info,"SampleError error(info=info, fatal=fatal) = error SampleError(\"Sample Error\", info = \"Detail Info\", fatal = true);"
fatal,"SampleError error(info=info, fatal=fatal) = error SampleError(\"Sample Error\", info = \"Detail Info\", fatal = true);"
transactionData,"error error(data=transactionData) = error BazError(\"TransactionError\", data = {\"A\":\"a\", \"B\":\"b\"});"
reason,"error<record {| value:Cloneable...; |}> error(reason, message = message) = err;"
message,"error<record {| value:Cloneable...; |}> error(reason, message = message) = err;"
e,"ReadOnlyIntersectionError e = error(\"Sample Error\", info = [\"Detail Info 1\", \"Detail Info 2\"]);"
message,"var error ReadOnlyIntersectionError(message, cause, info = [info1, info2]) = e;"
cause,"var error ReadOnlyIntersectionError(message, cause, info = [info1, info2]) = e;"
a,"record {| int i; int...; |} a = {i: 1};"
e,"Student1 e = {name: \"Jo\", id: 1234};"
eName,"var {name: eName, id: eId, age: eAge} = e;"
eId,"var {name: eName, id: eId, age: eAge} = e;"
eAge,"var {name: eName, id: eId, age: eAge} = e;"
newAge,"int newAge = eAge;"
id,"var {name, id: id, age} = e;"
topt,"Topt1 topt = {a: 4, c: [{b: 5}]};"
x,"int? x = 1;"
y,"string? y = \"2\";"
f,"[[string, int], float] [[s, i], f] = [[\"Fooo\", 4], 6.7];"
a,"[[string, [int, [boolean, byte]]], [float, int]] a = [[\"Bal\", [3, [true, 34]]], [5.6, 45]];"
fullName,"string fullName = a + \" \" + name;"
c,"[[string|int, int|boolean], float|[int, boolean], [string|float, string]] [[a, b], c, [d, e]] = [[\"Test\", 23], 4.5, [5.7, \"Foo\"]];"
c,"[[string|int, int|boolean], float|[int, boolean], [string|float, string]] [[a, b], c, [d, e]] = fn3();"
t,"T t = [1, 2];"
rArr,"int[] & readonly rArr = a;"
str,"string str = b;"
t2,"ReadOnlyTuple t2 = [[3], \"s2\"];"
r,"readonly & [int[], ReadOnlyTuple] r = [[12, 34, 56], t1];"
a1,"readonly & int[] a1 = e;"
b1,"ReadOnlyTuple b1 = f;"
details,"PersonDetails details = [{name: \"Jack\", married: true}, 10];"
p1,"PersonWithAge p1 = { name: \"John\", age: {age:30, format: \"YY\"}, married: true, \"work\": \"SE\" };"
p2,"PersonWithAge p2 = { name: \"Doe\", age: {age:15, format: \"MM\"}, married: true, \"work\": \"SE\" };"
p3,"PersonWithAge p3 = { name: \"Peter\", age: {age:5, format: \"DD\"}, married: true, \"work\": \"SE\" };"
fName1,"PersonWithAge {name: fName1, age: {age: theAge1, format: format1}, married: married1} = p1;"
theAge1,"PersonWithAge {name: fName1, age: {age: theAge1, format: format1}, married: married1} = p1;"
format1,"PersonWithAge {name: fName1, age: {age: theAge1, format: format1}, married: married1} = p1;"
married1,"PersonWithAge {name: fName1, age: {age: theAge1, format: format1}, married: married1} = p1;"
fName2,"PersonWithAge {name: fName2, age: {age: theAge2, format: format2}, married: married2} = p2;"
theAge2,"PersonWithAge {name: fName2, age: {age: theAge2, format: format2}, married: married2} = p2;"
format2,"PersonWithAge {name: fName2, age: {age: theAge2, format: format2}, married: married2} = p2;"
married2,"PersonWithAge {name: fName2, age: {age: theAge2, format: format2}, married: married2} = p2;"
fName3,"PersonWithAge {name: fName3, age: {age: theAge3, format: format3}, married: married3} = p3;"
theAge3,"PersonWithAge {name: fName3, age: {age: theAge3, format: format3}, married: married3} = p3;"
format3,"PersonWithAge {name: fName3, age: {age: theAge3, format: format3}, married: married3} = p3;"
married3,"PersonWithAge {name: fName3, age: {age: theAge3, format: format3}, married: married3} = p3;"
stringAddition,"string stringAddition = fName1 + fName2 + fName3 + format1 + format2 + format3;"
intAddition,"int intAddition = theAge1 + theAge2 + theAge3;"
fName,"Person {name: fName, married} = getPersonRecord();"
name,"string name = fName + \" Jill\";"
person,"Person person = {name: \"Jack\", married: true};"
person,"PersonWithAge person = {name: \"Peter\", age: getAgeRecord(), married: true, \"work\": \"SE\"};"
fName,"PersonWithAge {name: fName, age: {age: theAge, format}, married} = person;"
theAge,"PersonWithAge {name: fName, age: {age: theAge, format}, married} = person;"
name,"string name = fName + \" Parker\";"
a,"Age a = {age: 99, format:\"MM\"};"
p,"PersonWithAge p = {name: \"John\", age: {age:30, format: \"YY\"}, married: true, \"work\": \"SE\", \"other\": getAgeRecord()};"
p,"PersonWithAge p = { name: \"John\", age: { age: 30, format: \"YY\", \"year\": 1990 }, married: true, \"work\": \"SE\" };"
person,"PersonWithAge person = { name: \"Peter\", age: { age: 29, format: \"Y\" }, married: true, \"work\": \"SE\" };"
fName,"var {name: fName, age: {age, format}, married, ...rest} = person;"
person,"PersonWithAge person = { name: \"Peter\", age: { age: 29, format: \"Y\" }, married: true, \"work\": \"SE\"};"
st1,"Student st1 = {name: \"Mark\", dob: [1, 1, 1990], gender: 1};"
sName,"Student {name: sName, dob: [a, b, c]} = st1;"
yearAndAge2,"[int, Age] yearAndAge2 = [1994, {age: 24, format: \"X\"}];"
yearAndAge3,"[int, Age] yearAndAge3 = [1998, {age: 20, format: \"A\"}];"
ch3,"Child ch3 = {name: \"D\", yearAndAge: yearAndAge3};"
u1,"UnionOne u1 = { var1: false, var2: 12, \"restP1\": \"stringP1\", \"restP2\": true };"
u3,"UnionThree u3 = {var1: 50, var2: 51.1, var3: u1};"
rec,"UnionRec1 rec = {var1: \"A\", var2: \"B\"};"
p,"PersonWithAge p = { name: \"John\", age: { age:30, format: \"YY\", \"year\": 1990 }, married: true, \"work\": \"SE\" };"
p,"PersonWithAge p = { name: \"John\", age: { age:30, format: \"YY\", \"year\": 1990}, married: true, \"work\": \"SE\" };"
name1,"IntRestRecord { name: name1, ...other1 } = rec1;"
name2,"var { name: name2, ...other2 } = rec1;"
rec3,"IntRestRecord|ObjectRestRecord rec3 = rec1;"
name5,"IntRestRecord|ObjectRestRecord { name: name5, ...other5 } = rec3;"
map1,"IntStringMap map1 = { name: \"A\", \"age\": 19, \"token\": 200 };"
map2,"IntStringMap|ObjectMap map2 = map1;"
name8,"IntStringMap|ObjectMap { name: name8, ...other9 } = map2;"
a2,"any a2 = other2;"
a5,"any a5 = other5;"
a9,"any a9 = other9;"
extra,"NotXY extra = testInferredType({x: 10, y: 20, \"foo\": \"bar\"});"
s,"var {s: s, i: i, ...rest} = recordReturningFunc(10);"
i,"var {s: s, i: i, ...rest} = recordReturningFunc(10);"
num1,"int num1 = <int>rest.get(\"f\");"
num2,"int num2 = <int>rest[\"f\"];"
stdName,"string stdName;"
details,"map<string> details;"
recA,"SchemaA recA = {name: \"David\", age:10, \"foo\":\"bar\"};"
age,"var age = rest.age;"
fooVal,"var fooVal = rest[\"foo\"];"
fullName,"string fullName;"
isMarried,"boolean isMarried;"
rest1,"map<string> rest1;"
rest2,"map<never> rest2;"
rest3,"record {| never name?; boolean married; never...; |} rest3;"
p,"Person p = {name: \"Jane Doe\", married: false};"
rec,"record {| never name?; never married?; |} rec = {};"
topt,"Topt1 topt = {x: 2, y: 3};"
xx1,"var {x: xx1, y: yy1} = topt;"
yy1,"var {x: xx1, y: yy1} = topt;"
xx2,"var {x: xx2, y: yy2} = topt;"
yy2,"var {x: xx2, y: yy2} = topt;"
topt,"Topt1 topt = {};"
topt,"Topt2 topt = {a: 4, c: [{b: 5}]};"
aa,"var {a: aa, c: cc} = topt;"
cc,"var {a: aa, c: cc} = topt;"
cc,"var {a: _, c: cc} = topt;"
ccc,"record {int b?;}[1] ccc = cc;"
topt,"Topt3 topt = {a: 4, c: [{b: 5}]};"
topt,"Topt4 topt = {x: 2, y: 3};"
xx,"var {x: xx, y: yy} = topt;"
yy,"var {x: xx, y: yy} = topt;"
topt,"Topt3 topt = {a: 4};"
y,"[record {int i?;}] y = [{}];"
x,"int? x = 2;"
y,"int? y = ();"
topt,"Topt1 topt = {x, y};"
x,"int? x = ();"
topt,"Topt1 topt = {x: 3, y: ()};"
a,"int? a = 4;"
b,"int? b = ();"
topt,"Topt2 topt = {a: 4, c: [{b}]};"
c,"record { int b?; }[1]? c = ();"
topt,"Topt3 topt = {a: 4, c};"
b,"int? b = 41;"
topt,"Topt3 topt = {a: 4, c: [{b}]};"
listResult,"record {int b?;}[] listResult = <record {int b?;}[1]> topt.c;"
x,"int x = 2;"
y,"NIL? y = ();"
topt1,"Topt1 topt1 = {x, y: ()};"
y1,"int? y1 = CONST_NIL;"
topt2,"Topt1 topt2 = {x, y: y1};"
topt3,"Topt1 topt3 = {x, y: CONST_NIL};"
t4,"Topt4 t4 = {x, y};"
t1,"Topt1 t1 = {x, y};"
empDetails,"EmployeeDetails empDetails = { emp\:name: \"Jo\" };"
details,"[EmployeeDetails, ProductDetails] details = [{emp\:name: \"Amy\"}, {x\:code: \"basic\", quantity: 324}];"
rArr,"int[] & readonly rArr = x;"
str,"string str = y;"
f2,"ReadOnlyRecord f2 = {x: [3], y: \"s2\"};"
x2,"var {x: x2, y: y2} = f2;"
y2,"var {x: x2, y: y2} = f2;"
a1,"readonly & int[] a1 = a;"
b1,"ReadOnlyRecord b1 = b;"
details,"PersonDetails details = {name: \"Jack\", married: true, details: {age: 30}};"
e,"var e = tuples:getTupleWithRestDescOnly();"
f,"string[] f = e;"
i,"(int|string)[] i = h;"
j,"[int, string...] j = h;"
p,"finite_type_project:TypeAliasThree p = {name: \"Anonymous name\"};"
a,"finite_type_project:MyType a = 100;"
b,"finite_type_project:MyType b = \"hundred\";"
p1,"finite_type_project:ParamTest p1 = testVarArgs(\"John\");"
p2,"finite_type_project:ParamTest p2 = testVarArgs(s1);"
val,"finite_type_project:ArrayCustom val = [34, 23];"
val,"finite_type_project:ByteArrayType val = [34, 23];"
si,"finite_type_project:ByteType si = 123;"
comparator,"finite_type_project:ByteType comparator = 123;"
a,"byte a = 34;"
f,"float f = 4.5;"
p1,"finite_type_project:BFType p1 = testVarByteArgs(a);"
p2,"finite_type_project:BFType p2 = testVarByteArgs(f);"
fn,"finite_type_project:BFuncType fn = function (string s) returns int { return s.length(); };"
fn,"finite_type_project:BFuncType2 fn = function (string s) returns int { return s.length(); };"
a,"finite_type_project:State a = \"on\";"
a,"finite_type_project:NumberSet a = 2;"
a,"finite_type_project:FloatValue a = 2.0;"
a,"finite_type_project:BooleanValue a = true;"
a,"finite_type_project:ByteValue a = 12;"
c,"byte|finite_type_project:Person c = a;"
a,"finite_type_project:CombinedState a = \"off\";"
d,"finite_type_project:StringOrInt d = a;"
ab,"finite_type_project:AB ab = finite_type_project:A;"
ab,"finite_type_project:ABInt ab = finite_type_project:A;"
s,"finite_type_project:AB|int s = ab;"
a,"finite_type_project:W a = \"foo\";"
b,"finite_type_project:X b = a;"
assignmentSuccessful,"boolean assignmentSuccessful = a == b && b == finite_type_project:FOO;"
c,"finite_type_project:Y c = a;"
d,"finite_type_project:Z d = a;"
a,"finite_type_project:X a = true;"
b,"finite_type_project:Y b = a;"
c,"finite_type_project:Z c = b;"
p,"foo:Building p = new foo:Building();"
p,"foo:Boy p = new foo:Boy();"
p,"foo:Bin p = new DustBin(100, 10, val1 = \"adding value in invocation\");"
p,"foo:Car p = new foo:Car(a = 50, n = \"passed in name value\");"
p,"Vehicle p = new;"
p,"foo:Tiger p = new();"
em,"foo:Cat em = new;"
emp,"var emp = p.emp;"
p,"foo:Bird p = new;"
p,"Office p = new;"
desk,"foo:Desk desk = new;"
mgr,"foo:Manager1 mgr = new();"
mgr2,"Manager2 mgr2 = new(\"Jane\");"
mgr3,"Manager3 mgr3 = new(\"Jane\");"
cemp1,"foo:CorronifiedEmployee cemp1 = new (true, 100.0, 200.3, 20, \"John\");"
cemp1,"PostPandemicEmployee cemp1 = new (true, 100.0, 200.3, 20, \"John\");"
f1,"foo:ObjectWithModuleLevelVisibilityField f1 = foo:getObjectWithModuleLevelVisibilityField();"
f2,"foo:ObjectWithModuleLevelVisibilityField f2 = new (11, false);"
ob,"ObjectWithModuleLevelVisibilityField ob = new (1, true);"
f1,"foo:ObjectWithModuleLevelVisibilityMethod f1 = foo:getObjectWithModuleLevelVisibilityMethod();"
f2,"foo:ObjectWithModuleLevelVisibilityMethod f2 = new (22, true);"
ob,"ObjectWithModuleLevelVisibilityMethod ob = new (2, false);"
f1,"foo:ObjectWithPublicFieldsAndMethods f1 = foo:getObjectWithPublicFieldsAndMethods();"
f2,"foo:ObjectWithPublicFieldsAndMethods f2 = new (33, false);"
ob1,"ObjectWithModuleLevelVisibilityField ob1 = new (1, false);"
ob2,"ObjectWithModuleLevelVisibilityMethod ob2 = new (2, false);"
ob3,"ObjectWithPublicFieldsAndMethods ob3 = new (3, false);"
r1,"readonly r1 = <readonly> <any|error> a;"
ad,"anydata ad = <anydata> a;"
emp,"se:Employee & readonly emp = { details: { name: \"Emma\", id: 1234 }, department: \"finance\" };"
r2,"readonly r2 = <readonly> <any|error> c;"
val,"var val = r2;"
rec,"se:Employee rec = <se:Employee & readonly> checkpanic val;"
det,"se:Details det = rec.details;"
emp2,"se:Employee & readonly emp2 = { details: { name: \"Mary\", id: 4567 }, department: \"IT\" };"
val2,"any val2 = d;"
r3,"readonly r3 = <readonly> e;"
stVal,"se:Student stVal = <se:Student & readonly> checkpanic val;"
rec,"record {| any...; |} rec = se:getMixedRecord();"
a,"any a = rec[\"a\"];"
r1,"readonly r1 = <readonly> a;"
ad1,"anydata ad1 = <anydata> a;"
b,"any b = rec[\"b\"];"
ad2,"anydata ad2 = <anydata> b;"
c,"any c = rec[\"c\"];"
r3,"readonly r3 = <readonly> c;"
ad3,"anydata ad3 = <anydata> c;"
d,"any d = rec[\"d\"];"
ad4,"anydata ad4 = <anydata> d;"
e,"any e = rec[\"e\"];"
r5,"readonly r5 = <readonly> e;"
ad5,"anydata ad5 = <anydata> e;"
f,"any f = rec[\"f\"];"
ad6,"anydata ad6 = <anydata> f;"
g,"any g = rec[\"g\"];"
r7,"readonly r7 = <readonly> g;"
ad7,"anydata ad7 = <anydata> g;"
h,"any h = rec[\"h\"];"
ad8,"anydata ad8 = <anydata> h;"
i,"any i = rec[\"i\"];"
r9,"readonly r9 = <readonly> i;"
ad9,"anydata ad9 = <anydata> i;"
jsonArr,"json[] jsonArr = <json[]> i;"
j,"any j = rec[\"j\"];"
ad10,"anydata ad10 = <anydata> j;"
k,"any k = rec[\"k\"];"
r11,"readonly r11 = <readonly> k;"
ad11,"anydata ad11 = <anydata> k;"
idTuple,"[se:Identifier, int] idTuple = <[se:Identifier, int]> k;"
l,"any l = rec[\"l\"];"
ad12,"anydata ad12 = <anydata> l;"
m,"any m = rec[\"m\"];"
r13,"readonly r13 = <readonly> m;"
ad13,"anydata ad13 = <anydata> m;"
student,"se:Student student = <se:Student> m;"
n,"any n = rec[\"n\"];"
ad14,"anydata ad14 = <anydata> n;"
o,"any o = rec[\"o\"];"
r15,"readonly r15 = <readonly> o;"
ad15,"anydata ad15 = <anydata> o;"
p,"any p = rec[\"p\"];"
ad16,"anydata ad16 = <anydata> p;"
q,"any q = rec[\"q\"];"
r17,"readonly r17 = <readonly> q;"
ad17,"anydata ad17 = <anydata> q;"
qVal,"table<se:Identifier> key(name) qVal = <table<se:Identifier> key(name)> ad17;"
r,"any r = rec[\"r\"];"
ad18,"anydata ad18 = <anydata> r;"
rVal,"table<map<string>> rVal = <table<map<string>>> ad18;"
s,"any s = rec[\"s\"];"
ownerA,"se:Owner ownerA = <se:Owner> s;"
t,"any t = rec[\"t\"];"
ownerB,"se:Owner ownerB = <se:OwnerB> t;"
seEmp,"se:Employee & readonly seEmp = { details: { name: \"Jo\", id: 1234 }, department: \"IT\" };"
recEmp,"records:Employee & readonly recEmp = { details: { name: \"May\", yob: 1990 }, id: 2314 };"
r1,"readonly r1 = seEmp;"
r2,"readonly r2 = recEmp;"
rec1,"record {} rec1 = seEmp;"
rec2,"record {} rec2 = recEmp;"
e1,"se:Employee e1 = <se:Employee> rec1;"
e2,"records:Employee e2 = <records:Employee> rec2;"
cr,"ConfigRec & readonly cr = {versioning: {}, quota: {initial: 5}, rec: {}, obj: new IdentifierObj()};"
a,"any a = cr;"
cr2,"ConfigRec cr2 = cr;"
obj,"IdentifierObj obj = <IdentifierObj> cr2.obj;"
empMap,"se:EmployeeMap empMap = { emp1: { details: { name: \"Emma\", id: 1234 }, department: \"finance\" }, emp2: { details: { name: \"Tom\", id: 5678 }, department: \"HR\" } };"
empTable,"se:EmployeeTable empTable = table [ { details: { name: \"Emma\", id: 1234 }, department: \"finance\" }, { details: { name: \"Tom\", id: 5678 }, department: \"HR\" } ];"
unionMap,"se:UnionMap unionMap = { id: { name: \"Tom\", id: 5678 }, user: { username : \"user1\" } };"
unionTable,"se:UnionTable unionTable = table [ { name: \"Tom\", id: 5678 }, { username: \"user1\" } ];"
zone,"se:Zone zone = object { public isolated function utcToCivil(se:Utc utc) returns se:Civil => { year: 1970, month: 1, day: 1, hour: 5, minute: 30, second: 1 }; };"
civil,"se:Civil civil = zone.utcToCivil([1, 0]);"
fn,"isolated function () fn = self.baz;"
x,"int[][] x = self.arrs;"
outerArr,"int[][] outerArr;"
x,"int[][] x = [];"
listResult,"int[][] listResult = from var e in arr order by e[0] ascending select e;"
res,"error? res = from var e in self.arrs do { arr.push(e); };"
innerArr,"int[][] innerArr = [];"
fn,"future<()> fn = @v15 { val: false } start funcWithWorker();"
origGlobalInt,"int origGlobalInt = 10;"
origGlobalString,"string origGlobalString = \"hello\";"
v1,"boolean v1 = a1 is map<int> && a1[\"one\"] == origGlobalInt && a1[\"two\"] == 22;"
v2,"boolean v2 = b1 is map<string> && b1[\"strOne\"] == \"one\" && b1[\"two\"] == origGlobalString;"
u1,"int u1 = 321;"
u2,"string u2 = \"world\";"
v3,"boolean v3 = a2 is map<int> && a2[\"one\"] == u1 && a2[\"two\"] == 22;"
v4,"boolean v4 = b2 is map<string> && b2[\"strOne\"] == \"one\" && b2[\"two\"] == u2;"
t,"typedesc<any> t = typeof c1;"
m1,"map<int>? m1 = t.@t1;"
m2,"map<string>? m2 = <map<string>?> getResourceAnnot(c1, \"get\", [\"res\"], \"t2\");"
v5,"boolean v5 = m1 is map<int> && m1[\"one\"] == origGlobalInt && m1[\"two\"] == 22;"
v6,"boolean v6 = m2 is map<string> && m2[\"strOne\"] == \"one\" && m2[\"two\"] == origGlobalString;"
ser,"service object {} ser = @t1 { one: globalInt, two: 22 } service object { @t2 { strOne: \"one\", two: globalString } resource function get res() { } };"
t,"typedesc<any> t = typeof ser;"
m2,"map<string>? m2 = <map<string>?> getResourceAnnot(ser, \"get\", [\"res\"], \"t2\");"
n,"int n;"
rec,"BarRec rec = {func : function() returns string => \"Bar\", id : 1};"
testError,"TestError testError = error(\"Error\", func = function() returns string => \"Bar\", id = 1);"
rec,"Record rec = {a: 1, b: \"A\"};"
val1,"var {a: val1, b: val2} = rec;"
val2,"var {a: val1, b: val2} = rec;"
x,"error? x = from var item in 1 ... 5 where false do { error? y = from var item2 in 1 ...2 where true do { int _ = 1; int _ = 1; }; };"
x,"error? x = from var item in 1 ... 5 where true do { error? y = from var item2 in 1 ...2 where false do { int _ = 1; int _ = 1; }; };"
b,"string b = \"A\";"
m,"string m;"
y,"int y = 0;"
message,"string message = \"err!\";"
y,"int y;"
v,"int|boolean v = true;"
a,"string? a = \"A\";"
b,"string|int b = \"B\";"
b,"string|int? b = \"B\";"
c,"string|int? c = \"C\";"
a,"string a = \"Hello\";"
b,"float b = 11.1;"
c,"string c = \"World !!!\";"
foo,"var foo = testClosureWithTupleTypes([a, b, c]);"
i,"string i = \"Ballerina\";"
j,"float j = 15.0;"
k,"string k = \"Program !!!\";"
i,"string i = \"HelloInner\";"
j,"float j = 44.8;"
k,"string k = \"World Inner!!!\";"
r,"[string, float, string] r = [i, j, k];"
d,"string d = \"Ballerina\";"
e,"float e = 15.0;"
f,"string f = \"Program!!!\";"
foo,"var foo = testClosureWithTupleTypesOrder([a, b, c]);"
addFunc,"var addFunc = function (int b) returns (int) { return b + globalA + a; };"
b,"int b = 4;"
foo,"var foo = function (float w) returns (string) { return self.name + w.toString() + \"K\" + b.toString() + self.age.toString(); };"
foo,"var foo = function (float w) returns (string) { return w.toString() + self.year.toString() + b.toString() + \"Ballerina !!!\"; };"
p,"Person p = new;"
foo,"var foo = p.getAttachedFP();"
outerInt,"int outerInt = 4;"
booOuter,"boolean booOuter = false;"
outerFoo,"var outerFoo = function (float fOut) returns (function (float) returns (string)) { int innerInt = 7; boolean booInner = true; var innerFoo = function (float fIn) returns (string) { string str = \"Plain\"; if (!booOuter && booInner) { str = innerInt.toString() + \"InnerInt\" + outerInt.toString() + fOut.toString() + \"InnerFloat\" + fIn.toString() + \"Ballerina !!!\"; } return str; }; return innerFoo; };"
fooOut,"var fooOut = testDifferentArgs();"
fooIn,"var fooIn = fooOut(1.2);"
f,"float f = 5.6;"
foo,"var foo = function (float f1) returns (string) { if (a > 8) { b = a + <int>f1 + b; } return \"Ballerina\" + b.toString(); };"
foo,"var foo = testVariableShadowingInClosure1(9);"
a,"string a = foo(3.4);"
boo,"boolean boo = true;"
fooOut,"var fooOut = function (float f1) returns (function (float, boolean) returns (string)) { if (a > 8) { b = a + <int>f1 + b; } string s = \"Out\" + b.toString(); var fooIn = function (float f2, boolean boo1) returns (string) { if (a > 8 && !boo1) { b = a + <int>f2 + b; } return s + \"In\" + b.toString() + \"Ballerina!!!\"; }; return fooIn; };"
foo,"var foo = testVariableShadowingInClosure2(9);"
bar,"var bar = foo(3.4);"
s,"string s = bar(24.6, false);"
fooOutMost,"var fooOutMost = function (float f1) returns (function (float) returns (function (float, boolean) returns (string))) { if (a > 8) { b = a + <int>f1 + b; } string sOut = \"OutMost\" + b.toString(); var fooOut = function (float f2) returns (function (float, boolean) returns (string)) { if (a == 9) { b = a + <int>f2 + b; } string s = sOut + \"Out\" + b.toString(); var fooIn = function (float f3, boolean boo1) returns (string) { if (a > 8 && !boo1) { b = a + <int>f3 + b; } return s + \"In\" + b.toString() + \"Ballerina!!!\"; }; return fooIn; }; return fooOut; };"
foo,"var foo = testVariableShadowingInClosure3(9);"
baz,"var baz = bar(5.7);"
s,"string s = baz(24.6, false);"
a,"int a = 7;"
fooOutMost,"var fooOutMost = function (float f1) returns (function (float) returns (function (float, boolean) returns (string))) { string sOut = \"OutMost\" + b.toString() + a.toString(); var fooOut = function (float f2) returns (function (float, boolean) returns (string)) { string s = sOut + \"Out\" + b.toString() + a.toString(); var fooIn = function (float f3, boolean boo1) returns (string) { b = a + <int>f3 + b; return s + \"In\" + b.toString() + \"Ballerina!!!\"; }; return fooIn; }; return fooOut; };"
foo,"var foo = testVariableShadowingInClosure4();"
fadd,"float fadd = 0.0;"
fa,"float[] fa = [1.1, 2.2, -3.3, 4.4, 5.5];"
fsum,"float fsum = fadd;"
boo1,"boolean boo1 = true;"
boo2,"boolean boo2 = false;"
value,"var value = trap <byte> f;"
i,"byte i = value;"
bArr,"byte[][] bArr = [];"
foo,"var foo = testByteAndBoolean();"
bar,"var bar = foo(34, 7);"
sum1,"int sum1 = 23;"
bar,"var bar = function () returns (function (int) returns int) { float f = 23.7; var foo = function (int i) returns (int) { int sum2 = 7; if (i < 7) { if (i < 6) { if (i < 5) { if (i == 4) { sum1 = sum1 + sum2 + i + <int>f; } } } } return sum1; }; return foo; };"
sum,"int sum = 23;"
foo,"var foo = function (int[] i, int[] j, int[] k) returns int { foreach var x in i { foreach var y in j { foreach var z in k { sum = sum + x + y + z; } } } return sum; };"
foo,"var foo = testMultiLevelBlockStatements1();"
baz,"var baz = foo();"
bar,"var bar = testMultiLevelBlockStatements2();"
i,"int[] i = [1,2];"
j,"int[] j = [1,2,3];"
k,"int[] k = [1,2,3,4];"
otherInternal,"var otherInternal = firstParameter;"
a1,"var a1 = function1(\"ABC\");"
b10,"boolean b10 = a1(\"ABC\");"
b11,"boolean b11 = a1(\"GHJ\");"
a2,"var a2 = function2(\"ABC\");"
b20,"boolean b20 = a2(\"ABC\");"
b21,"boolean b21 = a2(\"WER\");"
a3,"var a3 = function3(\"ABC\");"
b30,"boolean b30 = a3(\"ABC\");"
b31,"boolean b31 = a3(\"MKJ\");"
a4,"var a4 = function4(\"ABC\");"
b40,"boolean b40 = a4(\"ABC\");"
b41,"boolean b41 = a4(\"ERWWS\");"
test,"boolean test = true;"
bar,"var bar = function () returns string { a = a + \"a\"; return a; };"
fn,"var fn = function () returns string { string result = strings:'join(\", \", ...args); return result; };"
fn,"var fn = function () returns int { int len = scores.length(); int i = 0; int sum = 0; while (i < len) { sum += scores[i]; i += 1; } return sum; };"
temp,"string temp = \"text \" + param1;"
process,"var process = function(string param2) returns error? { moduleLevel = moduleLevel + param2; return error(\"An Error\", tempString = temp, moduleString = moduleLevel, param1 = param1, param2 = param2); };"
temp,"string temp = \"text\";"
process,"var process = function() returns error? { return error(\"An Error\", tempString = temp, arrayParam = arr); };"
temp,"var temp = errorConstructorReference1(\"tempParam1\");"
err,"error err = <error>temp;"
errorDetail,"map<value:Cloneable> errorDetail = err.detail();"
arr,"string[] arr = [\"array\"];"
tempfunc,"var tempfunc = errorConstructorReference2(arr);"
tempErr,"var tempErr = tempfunc();"
refObj,"Obj1 refObj = object { function info(Foo foo, stream<int, error?> s) returns error? { check s.forEach(function(int j) { int[] arr = []; arr.forEach(function(int i) { foo.fooFunc(); }); }); } };"
refObj,"Obj2 refObj = object { function addAll(int[] arr1, int[] arr2) returns int { int x = 0; arr1.forEach(function(int j) { arr2.forEach(function(int i) { x += i + j; }); }); return x; } };"
refObj,"Obj3 refObj = object { function addAll(int[] arr1, int[] arr2, int[] arr3, int[] arr4) returns int { int x = 0; arr1.forEach(function(int j) { arr2.forEach(function(int i) { arr3.forEach(function(int k) { arr4.forEach(function(int l) { x += i + j + k + l; }); }); }); }); return x; } };"
obj,"Obj2 obj = testLevelsWithForEach2();"
x,"int x = obj.addAll([1,2,3], [4]);"
obj3,"Obj3 obj3 = testLevelsWithForEach3();"
y,"int y = obj3.addAll([1,2,3], [4,5], [6], [7]);"
expT,"typedesc<anydata> expT = typeof expected;"
actT,"typedesc<anydata> actT = typeof actual;"
reason,"string reason = \"expected [\" + expected.toString() + \"] of type [\" + expT.toString() + \"], but found [\" + actual.toString() + \"] of type [\" + actT.toString() + \"]\";"
p,"Person p = { name: name, age, [foo()]: \"FOO\" };"
annot,"Annot? annot = FooRec.@v5;"
f,"future<int?> f = @WorkerAnnot start add(1, 2);"
x2,"int[] x2 = [1, 2 , 3];"
y2,"int[] y2 = [...x2, 4];"
y3,"int[] y3 = [...y1, 5];"
mbp1,"string mbp1;"
mbp2,"int mbp2;"
rbp3,"map<string> rbp3;"
mbp3,"record {string name; int age;} {name: mbp3, age, ...rbp4} = <Person2>{name: \"John Doe\", age: 20, \"foo\": \"bar\"};"
msg,"string msg;"
cause,"error cause;"
code,"int code;"
rbp5,"map<string> rbp5;"
msg1,"Error error Error(msg1, cause1, code=code1, ...rbp6) = error Error(\"FileNotFound\", code = 500);"
cause1,"Error error Error(msg1, cause1, code=code1, ...rbp6) = error Error(\"FileNotFound\", code = 500);"
code1,"Error error Error(msg1, cause1, code=code1, ...rbp6) = error Error(\"FileNotFound\", code = 500);"
a3,"[[string, int], float] [[a1, a2], a3] = [[\"text\", 4], 89.9];"
valName,"record {string name; int age;} {name: valName, valAge} = person;"
dept,"Dept dept = {val: 11};"
jam,"map<int> {val: jam} = dept;"
val,"int val = a;"
iVal,"int iVal = 0;"
valName,"Employee {name: valName, age: valAge} = employee;"
valAge,"Employee {name: valName, age: valAge} = employee;"
str,"@varDecl string str = \"foo\";"
str2,"@varDecl final var str2 = \"value\";"
res1,"int res1 = lbp3;"
res2,"string res2 = rbp2[0];"
r1,"string:RegExp r1 = re `[a-z]`;"
r2,"string:RegExp r2 = re `((c)(d))`;"
r3,"string:RegExp r3 = re `[bB].tt[a-z]*`;"
r4,"string:RegExp r4 = re `[bB].${r3}`;"
o,"O o = {};"
value,"string|int value = \"Jam\";"
bindingPattern,"BindingPattern bindingPattern = { field1: INT_FIELD, field2: STRING_FIELD, field3: FLOAT_FIELD, var4: DECIMAL_FIELD, var5: BOOLEAN_FIELD, field6: NIL_FIELD, field7: [8, 9, 10, 11] };"
bRecord,"ComplexRecordTwo bRecord = { bField1: FLOAT_FIELD, bField2: (STRING_FIELD, BOOLEAN_FIELD) };"
aRecord,"ComplexRecord aRecord = { aField1: bRecord, aField2: (jsonField, bRecord), aField3: (STRING_FIELD_2, INT_FIELD_2, { x: STRING_FIELD_3, y: INT_FIELD_3 }) };"
a,"ComplexRecord { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
b, { bField1: c, bField2: d },"ComplexRecord { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
e,"ComplexRecord { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
f, g,"ComplexRecord { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
a,"var { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
b, { bField1: c, bField2: d },"var { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
e,"var { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
f, g,"var { aField1: a, aField2: (b, { bField1: c, bField2: d }), aField3: (e, f, g) } = aRecord;"
f,"float f = F;"
s3,"map<float> s3 = { one: f, two: 2.00 };"
s,"string s = S;"
s4,"FooRecord s4 = { fooFieldOne: s };"
i,"int i = I;"
s5,"BarObject s5 = new(i);"
p,"Person p = {id: <int>(checkpanic f[\"id\"]), fname: <string>(checkpanic f[\"fname\"]), lname: <string>(checkpanic f[\"lname\"])};"
startTime,"int startTime = nanoTime();"
_frame,"_Frame _frame = {};"
pl,"Person[] pl = getPersonArray(warmupCount);"
outputList,"Person[] outputList = [];"
frames2,"_Frame[] frames2 = [];"
c,"int c = round(ceil(sqrt(<float>warmupCount * 1.0f)));"
pl,"Person[] pl = getPersonArray(c);"
dl,"Department[] dl = getDepartmentArray(c);"
outputList,"DeptPerson[] outputList = from var person in pl from var dept in dl limit warmupCount select { fname: person.fname, lname: person.lname, dept: dept.name };"
outputList,"DeptPerson[] outputList = [];"
p,"Person p = pl[i];"
d,"Department d = dl[j];"
dl,"Department[] dl = getDepartmentArray(warmupCount);"
outputList,"DeptPerson[] outputList = from var person in pl join var dept in dl on person.id equals dept.id limit warmupCount select { fname: person.fname, lname: person.lname, dept: dept.name };"
deptMap,"map<Department> deptMap = {};"
d,"Department d = dl[i];"
d,"Department d = <Department>deptMap[p.id.toString()];"
message,"Patient message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HealthServer/registerPatient\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HealthServer/getPatientInfo\", message, headers);"
authInfo,"AuthInfo authInfo = users.get(username);"
authenticated,"boolean authenticated = checkPasswordEquality(authInfo.password, password);"
userDetails,"UserDetails userDetails = { username: username };"
scopes,"string[]? scopes = authInfo?.scopes;"
authenticated,"Error? authenticated = authenticateWithLdap(self.ldapConnection, username, password);"
groups,"string[]|Error? groups = getLdapGroups(self.ldapConnection, username);"
usernameAndPassword,"string usernameAndPassword = \"!nval!d-b@$e64-encoded-va!ue\";"
result,"[string, string]|Error result = extractUsernameAndPassword(usernameAndPassword);"
usernameAndPassword,"string usernameAndPassword = \"YWxpY2UxMjM=\";"
usernameAndPassword,"string usernameAndPassword = \"YWxpY2U6\";"
usernameAndPassword,"string usernameAndPassword = \"OjEyMw==\";"
body,"string? body = req.body;"
receivedData,"readonly & byte[] receivedData = check socketClient->readBytes();"
responseString,"string responseString = check string:fromBytes(receivedData);"
payload,"string? payload = ();"
respArr,"string[] respArr = regexp:split(re`\r\n\r\n`, responseString);"
respHeaders,"string[] respHeaders = regexp:split(re`\r\n`, respArr[0]);"
contLenHeader,"string contLenHeader = respHeaders.filter(i => (i.startsWith(\"Content-Length\")))[0];"
contLen,"int contLen = check ints:fromString(regexp:split(re`:`, contLenHeader)[1].trim());"
remainingBytes,"int remainingBytes = contLen - (<string>payload).length();"
data,"byte[] data = check socketClient->readBytes();"
respArr,"string[] respArr = regexp:split(re`\r\n`, resp);"
headersMap,"map<string> headersMap = {};"
filtered,"string[] filtered = respArr.filter(i => !(i.startsWith(\"HTTP\")) && i.includes(\":\", 0));"
keyValue,"string[] keyValue = regexp:split(re`:`, header);"
status,"string status = respArr[0].substring(9, respArr[0].length());"
httpVersion,"string httpVersion = respArr[0].startsWith(\"HTTP/1.1\") ? \"HTTP/1.1\" : \"HTTP/2.0\";"
response,"Response response = { headers: headersMap, body: body, status: status, HttpVersion: httpVersion };"
request,"Request request = { headers: headersMap, body: payload, path: httpStatus, HttpVersion: httpVersion };"
intArray,"int[] intArray = getNumbers();"
persons,"Person[] persons = getPersons();"
personList,"Person[] personList = getPersons();"
personArray,"int[] personArray = getPersons();"
intArray,"int[] intList = getNumbers();"
numbers,"int[] numbers = getNumbers();"
numbersArray,"int[] numbersArray = getNumbers();"
numbersList,"int[] numbersList = getNumbers();"
count,"int count = getCount();"
name,"string name = getName();"
age,"int age = getAge();"
isAuthorized,"boolean isAuthorized = checkAuthorization();"
isRaining,"boolean isRaining = false;"
isFlag,"boolean isFlag = true;"
salary,"float salary = getSalary();"
names,"string[] names = getNames();"
payload,"json payload = getPayload();"
dateList,"Date[] dateList = [];"
dateArray,"Date[] dateArray = [];"
totalPrice,"float totalPrice = calculateTotalPrice();"
message,"string message = getMessage();"
isFound,"boolean isFound = findItem();"
employees,"Employee[] employees = getEmployees();"
students,"Students[] students = getStudents();"
order,"Order order = getOrder();"
student,"Student student;"
person,"Person person = {name: 'John'};"
persons,"Person[] persons = getPersons();"
persons,"Person[] persons = getPersons(10, 'Sales');"
num,"int num;"
daysOfWeek,"DayOfWeek[] daysOfWeek = [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY];"
scores,"int[] scores = getScores();"
temperature,"float temperature = getTemperature();"
isEven,"boolean isEven = checkIfEven();"
customer,"Customer customer = new Customer("John Doe", 35);"
product,"Product product = new Product("Widget", 29.99);"
orderList,"Order[] orderList = getOrders();"
isAuthenticated,"boolean isAuthenticated = checkAuthentication();"
availableColors,"string[] availableColors = {"Red", "Blue", "Green"};"
userCount,"int userCount = getUserCount();"
isOpen,"boolean isOpen = checkIfStoreOpen();"
isWeekend,"boolean isWeekend = checkIfWeekend();"
book,"Book book = new Book("Title", "Author", 19.99);"
sensorData,"SensorData[] sensorData = getSensorData();"
userInput,"string userInput = getUserInput();"
productAvailability,"boolean productAvailability = checkProductAvailability();"

