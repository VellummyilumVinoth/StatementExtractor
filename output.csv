skipped,"TestDiffResult[] skipped = [];"
unchanged,"TestDiffResult[] unchanged = [];"
changed,"TestDiffResult[] changed = [];"
newSkipped,"var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));"
newUnchanged,"var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));"
newChanged,"var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath));"
baseTestDir,"string baseTestDir = check file:joinPath(baseDir, testDir);"
transformedTestDir,"string transformedTestDir = check file:joinPath(transformedDir, testDir);"
newSkipped,"var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));"
newUnchanged,"var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));"
newChanged,"var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath));"
baseTestFile,"string baseTestFile = check file:joinPath(baseTestDir, test);"
transformedTestFile,"string transformedTestFile = check file:joinPath(transformedTestDir, test);"
baseTests,"TestCase[] baseTests = check parseTests(baseTestFile);"
transformedTests,"TestCase[] transformedTests = check parseTests(transformedTestFile);"
lines,"string[] lines = check io:fileReadLines(path);"
content,"string[] content = [];"
description,"string description = "";"
tests,"TestCase[] tests = [];"
s,"State s = CONTENT;"
baseIndex,"int baseIndex = 0;"
transformedIndex,"int transformedIndex = 0;"
baseDescription,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
baseContent,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
transformedDescription,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
transformedContent,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
body,"string[] body = [];"
currentPath,"string currentPath = "";"
path,"string path = diff.base.path;"
parts,"string[] parts = check file:splitPath(absPath);"
skipList,"string? skipList = opts.skipList;"
skipLabels,"string[][] skipLabels = skipList != () ? check parseSkipList(skipList) : [];"
skipped,"int skipped = 0;"
total,"int total = 0;"
tests,"BaltTestCase[] tests = check parseTest(path);"
parts,"string[] parts = check file:splitPath(path);"
filename,"string filename = parts[parts.length() - 1];"
dir,"string dir = parts[parts.length() - 2];"
testCases,"BaltTestCase[] testCases = [];"
header,"string[] header = [];"
labels,"string[] labels = [];"
useIoLib,"boolean useIoLib = false;"
s,"State s = BOF;"
fBody,"var [_, fBody] = parseField(line);"
contentLine,"var [contentLine, newLabels] = transformContent(line);"
newLabels,"var [contentLine, newLabels] = transformContent(line);"
newContent,"string[] newContent = ["import ballerina/io;"];"
newLabels,"string[] newLabels = [];"
initFunc,"string initFunc = "function init()";"
newLine,"string newLine;"
starIndex,"int? starIndex = line.indexOf("{");"
endIndex,"int? endIndex = line.indexOf("}");"
targetIndex,"int targetIndex = <int>line.indexOf("?;");"
i,"int? i = s.indexOf(":");"
fieldName,"string fieldName = s.substring(0, i);"
fieldValue,"string fieldValue = s.substring(i + 1);"
index,"int index = 0;"
skipIndices,"int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];"
skipTest,"boolean skipTest = false;"
outputFileName,"string outputFileName = string `./tests/${dir}/${filename}`;"
invalid,"boolean invalid = true;"
tc,"t:Context tc = mod.getTypeContext();"
numBlocks,"int numBlocks = self.blocks.length();"
vc,"VerifyContext vc = new(mod, defn);"
entry,"Label entry = 0;"
cx,"VerifyCodeContext cx = check vc.verifyCodeContext(code);"
params,"RegSet params = check verifyParamRegs(vc, code.registers);"
block,"BasicBlock block = cx.blocks[current];"
term,"Insn term = check blockTerminator(cx, block, predPos);"
termPos,"Position termPos = term.pos;"
onPanic,"Label? onPanic = block.onPanic;"
cycle,"boolean cycle = cx.preds[child];"
fid,"int fid = cx.fwdInDegrees[child];"
i,"int i = 0;"
insns,"Insn[] insns = cx.blocks[i].insns;"
paramRegs,"RegSet paramRegs = [];"
afterParams,"boolean afterParams = false;"
flows,"RegFlow[] flows = cx.blocksFlows[current];"
regs,"RegSet regs = mergeFlows(flows);"
afterMerge,"boolean afterMerge = false;"
operands,"| var { args: operands }"
term,"Insn term = check blockTerminator(cx, block, viaPos);"
trueRegs,"RegSet trueRegs = regs.clone();"
falseRegs,"RegSet falseRegs = regs;"
numFlows,"int numFlows = flows.length();"
flow,"RegFlow? flow = flowOriginating(flows, pred);"
insns,"Insn[] insns = block.insns;"
insnsLen,"int insnsLen = insns.length();"
result,"RegSet result = [];"
numReg,"int numReg = flow[0].regs.length();"
conj,"boolean conj = true;"
name,"string name = insn.name;"
unnarrowedOp,"Register unnarrowedOp = unnarrow(insn.result);"
union,"t:SemType union = t:NEVER;"
unnarrowedOp,"Register unnarrowedOp = unnarrow(insn.operand);"
func,"FunctionRef func = <FunctionRef>insn.func;"
sig,"FunctionSignature sig = func.signature;"
nSuppliedArgs,"int nSuppliedArgs = insn.args.length();"
nExpectedArgs,"int nExpectedArgs = sig.paramTypes.length();"
name,"string name = vc.symbolToString(func.symbol);"
ty,"t:SemType ty = insn.result.semType;"
lat,"t:ListAtomicType? lat = t:listAtomicType(vc.typeContext(), ty);"
operands,"Operand[] operands = insn.operands;"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(vc.typeContext(), ty);"
indexOperand,"IntOperand indexOperand = insn.operands[1];"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, indexOperand.semType);"
i,"IntOperand i = insn.operands[1];"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, insn.operands[1].semType);"
keyOperand,"StringOperand keyOperand = insn.operands[1];"
memberType,"t:SemType memberType = t:mappingMemberTypeInner(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);"
memberType,"t:SemType memberType = t:mappingMemberTypeInnerVal(vc.typeContext(), insn.operands[0].semType, keyOperand.semType);"
lhs,"Operand lhs = insn.operands[0];"
rhs,"Operand rhs = insn.operands[1];"
label,"int label = code.blocks.length();"
bb,"BasicBlock bb = { label, name };"
r,"VarRegister r = { number: code.registers.length(), semType, pos, name, scope };"
r,"FinalRegister r = { number: code.registers.length(), semType, pos, name, scope };"
r,"NarrowRegister r = { number: code.registers.length(), underlying, semType, pos };"
r,"ParamRegister r = { number: code.registers.length(), semType, pos, name, scope };"
r,"TmpRegister r = { number: code.registers.length(), semType, pos, name };"
r,"AssignTmpRegister r = { number: code.registers.length(), semType, pos, name };"
isNamed,"boolean isNamed = ty.name != ();"
elementTypes,"Type[] elementTypes = ty.elementTypes;"
ty1,"Type ty1 = v1.ty;"
ty2,"Type ty2 = v2.ty;"
words,"string[] words = [];"
operand,"string operand = concat(...words);"
structBody,"string[] structBody = [];"
elemTypes,"Type[] elemTypes = [];"
element,"final Value element = elements[i];"
structTy,"Type structTy = structType(elemTypes);"
ty,"ArrayType ty = arrayType(elementType, values.length());"
body,"string[] body = ["["];"
element,"final ConstValue element = values[i];"
ty,"ArrayType ty = arrayType("i8", bytes.length());"
val,"ConstValue val = new(ty, charArray(bytes));"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self);"
structName,"string structName = "%" + escapeIdent(name);"
ty,"StructType ty = { elementTypes: [], name: structName };"
tyName,"string? tyName = namedStructTy.name;"
valRep,"string valRep;"
data,"var data = entry[1];"
words,"string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)];"
tyName,"string? tyName = ty.name;"
data,"var data = self.namedStructTypes[tyName];"
dIBuilder,"DIBuilder dIBuilder = new(self, self.context);"
metadata,"Metadata metadata = self.addMetadata();"
preambleWords,"string[] preambleWords = [];"
fnName,"string fnName = self.escapeGlobalIdent(name);"
fn,"FunctionDefn fn = new (self.context, fnName, fnType);"
fn,"FunctionDecl fn = new(self.context, fnName, fnType);"
fnExisting,"FunctionDecl? fnExisting = <FunctionDecl?>self.globals[name];"
fnExisting,"boolean fnExisting = self.globals[name] != ();"
fn,"FunctionDecl fn = new(self.context, "llvm." + name, fnType);"
varName,"string varName = self.escapeGlobalIdent(name);"
ptrType,"PointerType ptrType = pointerType(ty, props.addressSpace);"
val,"ConstPointerValue val = new ConstPointerValue(ptrType, "@" + varName);"
aliasName,"string aliasName = self.escapeGlobalIdent(name);"
alias,"ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);"
varName,"string varName = escapeIdent(name);"
out,"Output out = new;"
words,"string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];"
line,"string[] line = [alias.operand, "="];"
initializer,"var initializer = prop.initializer;"
metadata,"Metadata metadata = new(self.genMetadataLabel());"
attrib,"ReturnEnumAttribute attrib = attribute[1];"
attrib,"ParamEnumAttribute attrib = attribute[1];"
paramIndex,"int paramIndex = attribute[0];"
paramType,"final Type paramType = functionType.paramTypes[i];"
register,"string register = "%" + i.toString();"
arg,"Value arg = new (paramType, register);"
isFirst,"boolean isFirst = true;"
bbName,"string|Unnamed bbName = self.genName(name);"
bb,"BasicBlock bb = new (self.context, bbName, self);"
varName,"string varName = name;"
count,"int count = self.variableNames.get(varName);"
newName,"string newName = varName + "." + count.toString();"
varName,"int varName = self.unnamedLabelCount;"
reg,"string|Unnamed reg = self.genName(name);"
newLabel,"string newLabel = self.nameCounter.toString();"
newName,"string newName = "%" + self.nameCounter.toString();"
newName,"string newName = self.nameTranslation[name];"
metadata,"Metadata metadata = self.m.addMetadata();"
body,"string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];"
name,"string? name = props.name;"
alignInBits,"Alignment? alignInBits = props.alignInBits;"
body,"string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];"
encodingToString,"string encodingToString = "DW_ATE_" + props.encoding;"
align,"int? align = props.alignInBits;"
words,"(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];"
words,"(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];"
scope,"Metadata? scope = props.scope;"
file,"Metadata? file = props.file;"
ty,"Metadata? ty = props.ty;"
flags,"string[] flags = [];"
retainedNodes,"Metadata retainedNodes = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];"
typeNode,"Metadata typeNode = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), "=", "!", "DILocation", "("];"
bb,"BasicBlock bb = self.bb();"
reg,"string|Unnamed reg = bb.func.genReg(name);"
ptrTy,"PointerType ptrTy = pointerType(ty);"
ty,"Type ty = ptr.ty.pointsTo;"
ty,"IntType|FloatType ty = sameNumberType(lhs, rhs);"
ty,"IntegralType ty = sameIntegralType(lhs, rhs);"
words,"(string|Unnamed)[] words = [reg, "="];"
valueType,"Type valueType = val.ty;"
valTy,"Type valTy = val.ty;"
insnWords,"(string|Unnamed)[] insnWords;"
retType,"RetType retType;"
fnTy,"Type fnTy = fn.ty.pointsTo;"
fnName,"var fnName = fn.operand;"
functionName,"string functionName = "@" + fn.functionName;"
words,"(string|Unnamed)[] words = [reg];"
insnWords,"(string|Unnamed)[] insnWords = [];"
arg,"final Value arg = args[i];"
elementType,"Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);"
condTy,"Type condTy = condition.ty;"
words,"(string|Unnamed)[] words = [];"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);"
tem,"BasicBlock? tem = self.currentBlock;"
chunks,"(string|Unnamed)[] chunks = [];"
currentChunk,"string[] currentChunk = [];"
newLines,"(string|Unnamed)[][] newLines = [];"
newLine,"(string|Unnamed)[] newLine = [];"
newLine,"string[] newLine = [];"
outputLine,"string outputLine = createLine([concat(...newLine)], INDENT);"
typeStringBody,"string[] typeStringBody = [];"
elementType,"final Type elementType = elementTypes[i];"
paramType,"final Type paramType = ty.paramTypes[i];"
elementTypes,"Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);"
metadata,"Metadata? metadata = fn.metadata;"
ty,"final Type ty = fn.functionType.paramTypes[i];"
parts,"string[] parts = [];"
lastTail,"string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";"
head,"string head = word.length() > 0 ? word.substring(0, 1) : "";"
escaped,"string escaped = "\"";"
cp,"int cp = ch.toCodePointInt();"
bytes,"byte[] bytes = ch.toBytes();"
result,"string result = "";"
hex,"string hex = cp.toHexString().toUpperAscii();"
ptrTy,"Type ptrTy = ptr.ty;"
resultType,"Type resultType = ptr.ty;"
resultAddressSpace,"int resultAddressSpace = 0;"
i,"int i;"
indexTy,"Type indexTy = index.ty;"
result,"string result = "c\"";"
hex,"string hex = b.toHexString().toUpperAscii();"
context,"Context context = new;"
builder,"Builder builder = context.createBuilder();"
m,"Module m = context.createModule();"
g,"ConstPointerValue g = m.addGlobal("i64", "g", initializer=context.constInt("i64", 5), addressSpace=1, linkage="internal");"
a,"ConstPointerValue a = m.addAlias("i64", g, "a", addressSpace=1);"
mainFunction,"FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});"
initBlock,"BasicBlock initBlock = mainFunction.appendBasicBlock();"
retVal,"Value retVal = builder.load(a);"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: ["i8"]});"
initBlock,"BasicBlock initBlock = foo.appendBasicBlock();"
a,"Value a = foo.getParam(0);"
const1,"Value const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);"
const1Ty,"Type const1Ty = structType(["i64", "i64"]);"
const2,"Value const2 = context.constStruct([context.constInt("i64", 3), context.constInt("i64", 4)]);"
const2Ty,"Type const2Ty = structType(["i64", "i64"]);"
const3,"Value const3 = context.constStruct([const1, const2]);"
const3Ty,"Type const3Ty = structType([const1Ty, const2Ty]);"
testTy,"FunctionType testTy = {returnType: const1Ty, paramTypes: []};"
test,"FunctionDefn test = m.addFunctionDefn("test", testTy);"
initBlock,"BasicBlock initBlock = test.appendBasicBlock();"
test2,"FunctionDefn test2 = m.addFunctionDefn("test2", {returnType: const3Ty, paramTypes: []});"
initBlock2,"BasicBlock initBlock2 = test2.appendBasicBlock();"
constFnStruct,"Value constFnStruct = context.constStruct([test]);"
constFnStructTy,"Type constFnStructTy = structType([pointerType(testTy)]);"
test3,"FunctionDefn test3 = m.addFunctionDefn("test3", {returnType:constFnStructTy, paramTypes: []});"
bb,"BasicBlock bb = test3.appendBasicBlock();"
sub,"FunctionDecl sub = m.getIntrinsicDeclaration("ssub.with.overflow.i64.i64");"
abort,"Function abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64", "i64"]});"
R3,"PointerValue R3 = builder.alloca("i64");"
R4,"PointerValue R4 = builder.alloca("i64");"
R0,"Value R0 = foo.getParam(0);"
R1,"Value R1 = foo.getParam(1);"
R5,"Value R5 = builder.load(R3);"
R6,"Value R6 = builder.load(R4);"
R_7,"Value? R_7 = builder.call(sub, [R5, R6]);"
R7,"Value R7;"
R8,"Value R8 = builder.extractValue(R7, 0);"
R9,"Value R9 = builder.extractValue(R7, 1);"
R10,"Value R10 = builder.iBitwise("xor", R9, context.constInt("i1", 1));"
ifTrue,"BasicBlock ifTrue = foo.appendBasicBlock();"
ifFalse,"BasicBlock ifFalse = foo.appendBasicBlock();"
structTy,"StructType structTy = context.structCreateNamed("structTy");"
fnTy,"FunctionType fnTy = functionType(structTy, [structTy, "i64"]);"
notUsed,"StructType notUsed = context.structCreateNamed("notUsed");"
g,"ConstPointerValue g = m.addGlobal(structTy, "g");"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", { returnType: structTy, paramTypes: [] });"
fooBB,"BasicBlock fooBB = foo.appendBasicBlock();"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", { returnType: "void", paramTypes: [structTy] });"
barBB,"BasicBlock barBB = bar.appendBasicBlock();"
test,"FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});"
p0,"Value p0 = test.getParam(0);"
p1,"Value p1 = test.getParam(1);"
p2,"Value p2 = test.getParam(2);"
temp1,"Value temp1 = builder.iArithmeticWrap("add",p0, p1);"
temp2,"Value temp2 = builder.iArithmeticWrap("add",temp1, p2);"
test2,"FunctionDecl test2 = m.addFunctionDecl("test2", {returnType:"i64", paramTypes:["i64", "i64", "i64"]});"
fnTy,"FunctionType fnTy = functionType("i64", ["i8", "i64"]);"
otherFnTy,"FunctionType otherFnTy = functionType("i8", ["i64"]);"
otherFnPtrTy,"PointerType otherFnPtrTy = pointerType(otherFnTy, 0);"
fn,"FunctionDecl fn = m.addFunctionDecl("otherFn", otherFnTy);"
fnPointerTy,"PointerType fnPointerTy = pointerType(fnTy, 0);"
structTy,"StructType structTy = structType(["i32", fnPointerTy]);"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: []});"
bar,"FunctionDecl bar = m.addFunctionDecl("bar",{returnType:"i64", paramTypes:["i64"]});"
barVoid,"FunctionDecl barVoid = m.addFunctionDecl("barVoid", {returnType:"void", paramTypes: []});"
R_1,"Value? R_1 = builder.call(bar, [context.constInt("i64", 0)]);"
R1,"Value R1;"
g1Ty,"StructType g1Ty = structType(["i64", "i32", "i8"]);"
g1,"ConstPointerValue g1 = m.addGlobal(g1Ty, "g1", isConstant=true);"
init,"ConstValue init = context.constGetElementPtr(g1, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");"
g2,"ConstPointerValue g2 = m.addGlobal(pointerType("i64", 0), "g2", initializer=init);"
init2,"ConstValue init2 = context.constBitCast(g2, pointerType("i32", 0));"
g4,"ConstPointerValue g4 = m.addGlobal(pointerType("i32", 0), "g4", isConstant=true);"
init3,"ConstValue init3 = context.constAddrSpaceCast(g4, pointerType("i32", 1));"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "void", paramTypes: []});"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i64", paramTypes: []});"
foo,"FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64",paramTypes:["i64"]});"
R2,"PointerValue R2 = builder.alloca("i64");"
R4,"Value R4 = builder.load(R2);"
foo,"FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes:["i64"]});"
m,"Module m = basicMain();"
output,"Output output = new ();"
outputPath,"string outputPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", "tmp.ll");"
foo1,"FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: ["i64"]});"
foo1BB,"BasicBlock foo1BB = foo1.appendBasicBlock();"
R0,"Value R0 = foo1.getParam(0);"
R3,"Value R3 = builder.load(R2);"
foo2,"FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: ["i64", "i64"]});"
bb2,"BasicBlock bb2 = foo2.appendBasicBlock();"
R0,"Value R0 = foo2.getParam(0);"
R1,"Value R1 = foo2.getParam(1);"
R5,"Value R5 = builder.load(R4);"
foo3,"FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType: "i64", paramTypes: ["i64", "i64", "i64"]});"
bb3,"BasicBlock bb3 = foo3.appendBasicBlock();"
R5,"PointerValue R5 = builder.alloca("i64");"
R6,"PointerValue R6 = builder.alloca("i64");"
R0,"Value R0 = foo3.getParam(0);"
R1,"Value R1 = foo3.getParam(1);"
R2,"Value R2 = foo3.getParam(2);"
R7,"Value R7 = builder.load(R6);"
foo,"FunctionDefn foo = m.addFunctionDefn("main", {returnType: "i64", paramTypes: []});"
R1,"PointerValue R1 = builder.alloca("i64");"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i8")]});"
arg,"Value arg = foo.getParam(0);"
third,"Value third = builder.bitCast(arg, pointerType("i64"));"
foo1,"FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType: "i64", paramTypes: []});"
bb1,"BasicBlock bb1 = foo1.appendBasicBlock();"
foo2,"FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: "i64", paramTypes: []});"
c,"Value c = context.constInt("i64",42);"
R2,"Value R2 = builder.load(R1);"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: [pointerType("i8")]});"
v1,"Value v1 = builder.ptrToInt(arg, "i64");"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: [pointerType("i8")]});"
V1,"Value V1 = builder.ptrToInt(arg, "i1");"
strContent,"byte[] strContent ="abc123#@% \n\\\"".toBytes();"
str,"Value str = context.constString(strContent);"
strFn,"FunctionDefn strFn = m.addFunctionDefn("test", {returnType: arrayType("i8", strContent.length()), paramTypes: []});"
initBlock,"BasicBlock initBlock = strFn.appendBasicBlock();"
expectedPath,"string expectedPath = check file:joinPath(file:getCurrentDir(), "modules", "print.llvm", "tests", "testOutputs", expectedFilename);"
expectedLines,"string[] expectedLines = check io:fileReadLines(expectedPath);"
expectedOutput,"string expectedOutput = "\n".'join(...expectedLines);"
mod,"Module mod = func();"
actualOutput,"string actualOutput = mod.printModuleToString();"
arrTy1,"Type arrTy1 = arrayType("i64", 20);"
arrTy2,"Type arrTy2 = arrayType(arrTy1, 10);"
rtTy,"Type rtTy = structType(["i64", arrTy2,"i64"]);"
stTy,"Type stTy = structType(["i64", "i64", rtTy]);"
g1,"PointerValue g1 = m.addGlobal(stTy, "g1");"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType:"void", paramTypes:[]});"
bb,"BasicBlock bb = foo.appendBasicBlock();"
v0,"PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i32", 1)]);"
v1,"PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i32", 0), context.constInt("i32", 2)]);"
v2,"PointerValue v2 = builder.getElementPtr(v1, [context.constInt("i32", 0), context.constInt("i32", 1)]);"
v3,"PointerValue v3 = builder.getElementPtr(v2, [context.constInt("i64", 0), context.constInt("i64", 5)]);"
arrTy3,"Type arrTy3 = arrayType(pointerType("i64", 1), 10);"
rtTy2,"Type rtTy2 = structType([ "i32", arrTy3, "i32" ]);"
stTy2,"Type stTy2 = structType(["i8", "i8", rtTy2]);"
g2,"PointerValue g2 = m.addGlobal(stTy2, "g2");"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType(pointerType("i64",1)), paramTypes: []});"
t0,"PointerValue t0 = builder.getElementPtr(g2, [context.constInt("i32", 1),context.constInt("i32", 2), context.constInt("i32", 1), context.constInt("i32", 4)]);"
v0,"error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0),context.constInt("i64", 1)]);"
g2,"PointerValue g2 = m.addGlobal("i32", "g2");"
v1,"Value v1 = builder.ptrToInt(g2, "i32");"
v0,"error|PointerValue v0 = trap builder.getElementPtr(g1, [context.constInt("i32", 0), v1]);"
structTy,"Type structTy = structType(["i64", "i64"]);"
arrTy,"Type arrTy = arrayType(structTy, 10);"
g1,"PointerValue g1 = m.addGlobal(arrTy, "g1");"
v0,"PointerValue v0 = builder.getElementPtr(g1, [context.constInt("i64", 10)]);"
v1,"error|PointerValue v1 = builder.getElementPtr(v0, [context.constInt("i64", 10)]);"
dIBuilder,"DIBuilder dIBuilder = m.createDIBuilder();"
fileData,"Metadata fileData = dIBuilder.createFile("filename.bal", "PATH_TO_BAL_SOURCE");"
functionTy,"Metadata functionTy = dIBuilder.createSubroutineType(fileData);"
functionData,"Metadata functionData = dIBuilder.createFunction(scope=fileData, name="test", linkageName="test", file=fileData, lineNo=0, ty=functionTy, scopeLine=0);"
loc,"Metadata loc = dIBuilder.createDebugLocation(1, 2, functionData);"
testFn,"FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "void", paramTypes: []});"
testBB,"BasicBlock testBB = testFn.appendBasicBlock();"
v0,"Value v0 = foo.getParam(0);"
v1,"Value v1 = foo.getParam(1);"
a,"Value a = builder.iArithmeticNoWrap("add", v0, v1);"
b,"Value b = builder.iArithmeticNoWrap("sub", v0, v1);"
c,"Value c = builder.iArithmeticNoWrap("mul", a, b);"
abort,"FunctionDefn abort = m.addFunctionDefn("abort", {returnType:"void", paramTypes:[]});"
R6,"Value R6 = builder.load(R5);"
R7,"Value R7 = builder.iCmp("eq", R6, context.constInt("i64", 0));"
bb8,"BasicBlock bb8 = foo.appendBasicBlock();"
bb9,"BasicBlock bb9 = foo.appendBasicBlock();"
R10,"Value R10 = builder.load(R4);"
R11,"Value R11 = builder.iCmp("eq", R10, context.constInt("i64", int:MIN_VALUE));"
bb16,"BasicBlock bb16 = foo.appendBasicBlock();"
bb12,"BasicBlock bb12 = foo.appendBasicBlock();"
R13,"Value R13 = builder.load(R5);"
R14,"Value R14 = builder.iCmp("eq", R13, context.constInt("i64", -1));"
bb15,"BasicBlock bb15 = foo.appendBasicBlock();"
bb20,"BasicBlock bb20 = foo.appendBasicBlock();"
R17,"Value R17 = builder.load(R4);"
R18,"Value R18 = builder.load(R5);"
R19,"Value R19 = builder.iArithmeticSigned("srem", R17, R18);"
R21,"Value R21 = builder.load(R3);"
fn,"FunctionDefn fn = m.addFunctionDefn(name, {returnType: "i1", paramTypes: ["double", "double"]});"
bb,"BasicBlock bb = fn.appendBasicBlock();"
p0,"Value p0 = fn.getParam(0);"
p1,"Value p1 = fn.getParam(1);"
res,"Value res = builder.fCmp(predicate, p0, p1);"
test,"FunctionDefn test = m.addFunctionDefn("test", {returnType: "i64", paramTypes:[]});"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "double", paramTypes: ["double", "double"]});"
initBlock,"BasicBlock initBlock = bar.appendBasicBlock();"
v0,"Value v0 = bar.getParam(0);"
v1,"Value v1 = bar.getParam(1);"
a,"Value a = builder.fArithmetic("fadd", v0, v1);"
b,"Value b = builder.fArithmetic("fsub", v0, v1);"
c,"Value c = builder.fArithmetic("fmul", a, b);"
d,"Value d = builder.fArithmetic("fdiv", c, a);"
add,"FunctionDecl add = m.getIntrinsicDeclaration("sadd.with.overflow.i64.i64");"
abort,"FunctionDefn abort = m.addFunctionDefn("abort", {returnType: "void", paramTypes: []});"
R_7,"Value? R_7 = builder.call(add, [R5, R6]);"
test,"FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["double"]});"
neg,"Value neg = builder.fNeg(p0);"
mul,"FunctionDecl mul = m.getIntrinsicDeclaration("smul.with.overflow.i64.i64");"
R_7,"Value? R_7 = builder.call(mul, [R5, R6]);"
bar,"FunctionDecl bar = m.addFunctionDecl("bar", {returnType: "void", paramTypes: []});"
bar2,"FunctionDecl bar2 = m.addFunctionDecl("bar2", {returnType: "void", paramTypes: []});"
bbfoo,"BasicBlock bbfoo = foo.appendBasicBlock();"
bbfoo2,"BasicBlock bbfoo2 = foo2.appendBasicBlock();"
const1,"ConstValue const1 = context.constStruct([context.constInt("i64", 1), context.constInt("i64", 2)]);"
g,"PointerValue g = m.addGlobal("i64", "g1");"
g2,"PointerValue g2 = m.addGlobal("i64", "g2", addressSpace=2);"
g7,"ConstPointerValue g7 = m.addGlobal(const1Ty, "g7");"
testFn,"FunctionDefn testFn = m.addFunctionDefn("testFn", {returnType: "i64", paramTypes: []});"
initBlock,"BasicBlock initBlock = testFn.appendBasicBlock();"
val1,"Value val1 = builder.ptrToInt(g, "i64");"
val2,"Value val2 = builder.ptrToInt(g2, "i64");"
ret,"Value ret = builder.iArithmeticWrap("add", val1, val2);"
e,"error|PointerValue e = trap m.addGlobal("i64", "g1");"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes:[]});"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i8", 1), paramTypes: [pointerType("i8", 1)]});"
mask,"FunctionDecl mask = m.getIntrinsicDeclaration("ptrmask.p1.i64");"
result,"Value? result = builder.call(mask, [arg, context.constInt("i64",72057594037927928)]);"
overflowArithmeticReturnType,"StructType overflowArithmeticReturnType = structType(["i64", "i1"]);"
overflowArithmeticFunctionType,"FunctionType overflowArithmeticFunctionType = {returnType: overflowArithmeticReturnType, paramTypes: ["i64", "i64"]};"
names,"IntrinsicFunctionName[] names = ["sadd.with.overflow.i64.i64", "ssub.with.overflow.i64.i64", "smul.with.overflow.i64.i64"];"
f,"FunctionDecl f = m.getIntrinsicDeclaration(name);"
functionName,"string functionName = "llvm." + name;"
name,"IntrinsicFunctionName name = "sadd.with.overflow.i64.i64";"
f1,"FunctionDecl f1 = m.getIntrinsicDeclaration(name);"
f2,"FunctionDecl f2 = m.getIntrinsicDeclaration(name);"
attributes,"FunctionEnumAttribute[] attributes = ["noreturn", "cold", "nounwind", "readnone", "speculatable", "willreturn"];"
fDecl,"FunctionDecl fDecl = m.addFunctionDecl("decl", {returnType: "void", paramTypes: []});"
fDefn,"FunctionDefn fDefn = m.addFunctionDefn("defn", {returnType: "void", paramTypes: []});"
attribute,"EnumAttribute attribute = "cold";"
test,"FunctionDefn test = m.addFunctionDefn("test", {returnType: "double", paramTypes: ["i64", "i32"]});"
v1,"Value v1 = builder.sIToFP(p0, "double");"
v2,"Value v2 = builder.sIToFP(p1, "double");"
ret,"Value ret = builder.fArithmetic("fadd", v1, v2);"
g1,"ConstPointerValue g1 = m.addGlobal("i64", "g1");"
structTy,"StructType structTy = context.structCreateNamed("st");"
g2,"ConstPointerValue g2 = m.addGlobal(structTy, "g2");"
mainFunction,"FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i32", paramTypes: []});"
testFn,"FunctionDefn testFn = m.addFunctionDefn("test", {returnType: "i32", paramTypes: []});"
f,"FunctionDefn f = m.addFunctionDefn("f", {returnType: "void", paramTypes: []});"
bb,"BasicBlock bb = f.appendBasicBlock();"
s,"DataValue s = new ("i64", "s");"
d,"PointerValue d = new (pointerType("i1"), "d");"
e,"error? e = trap builder.store(s, d);"
e,"Value?|error e = trap builder.call(f, [s]);"
e,"Value?|error e = trap builder.extractValue(s, 0);"
e,"error? e = trap builder.condBr(s,bb,bb);"
context,"Context context = new();"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i8", paramTypes: ["i64"]});"
v1,"Value v1 = builder.trunc(arg, "i8");"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: "i1", paramTypes: ["i64"]});"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: "i64", paramTypes: ["i64"]});"
v1,"Value|error v1 = trap builder.trunc(arg, "i64");"
structPtrTy,"PointerType structPtrTy = pointerType(structTy);"
extFnTy,"FunctionType extFnTy = {returnType: "void", paramTypes: [structPtrTy]};"
extFnPtrTy,"PointerType extFnPtrTy = pointerType(extFnTy);"
mainFnTy,"FunctionType mainFnTy = {returnType: "void", paramTypes: [structPtrTy]};"
mainFn,"FunctionDefn mainFn = m.addFunctionDefn("main", mainFnTy);"
bb,"BasicBlock bb = mainFn.appendBasicBlock();"
arg,"Value arg = mainFn.getParam(0);"
v2,"PointerValue v2 = builder.alloca(structPtrTy);"
v3,"Value v3 = builder.load(v2);"
v4,"PointerValue v4 = builder.getElementPtr(<PointerValue>v3, [context.constInt("i32", 0), context.constInt("i32", 0)], "inbounds");"
v5,"Value v5 = builder.load(v4);"
v6,"PointerValue v6 = builder.getElementPtr(<PointerValue>v5, [context.constInt("i64", 1)], "inbounds");"
v7,"Value v7 = builder.load(v6);"
v8,"Value v8 = builder.load(v2);"
v9,"PointerValue v9 = builder.bitCast(<PointerValue>v7, extFnPtrTy);"
foo,"FunctionDefn foo = m.addFunctionDefn("foo", {returnType: pointerType("i64"), paramTypes: [pointerType("i64")]});"
third,"Value third = builder.getElementPtr(<PointerValue>arg, [context.constInt("i64", 3)]);"
bar,"FunctionDefn bar = m.addFunctionDefn("bar", {returnType: pointerType("i8"), paramTypes: [pointerType("i8")]});"
arg_1,"Value arg_1 = bar.getParam(0);"
foo2,"FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType: pointerType("i64", 1), paramTypes: [pointerType("i64", 1)]});"
fooBB2,"BasicBlock fooBB2 = foo2.appendBasicBlock();"
arg_2,"Value arg_2 = foo2.getParam(0);"
f1,"FunctionDefn f1 = foo1(builder, m);"
f2,"FunctionDefn f2 = foo2(builder, m);"
f3,"FunctionDefn f3 = foo3(context, builder, m);"
f4,"FunctionDefn f4 = foo4(builder, m);"
test,"FunctionDefn test = m.addFunctionDefn("test", {returnType:"void", paramTypes:[]});"
bb5,"BasicBlock bb5 = test.appendBasicBlock();"
R3,"Value R3;"
R_3,"Value|() R_3 = builder.call(f3, []);"
R4,"Value R4;"
R_4,"Value|() R_4 = builder.call(f4, [context.constInt("i64", 12), context.constInt("i64", 13)]);"
foo1,"FunctionDefn foo1 = m.addFunctionDefn("foo1", {returnType:"void", paramTypes:[]});"
foo2,"FunctionDefn foo2 = m.addFunctionDefn("foo2", {returnType:"void", paramTypes:["i64","i64"]});"
foo3,"FunctionDefn foo3 = m.addFunctionDefn("foo3", {returnType:"i64", paramTypes:[]});"
C1,"Value C1 = cx.constInt("i64", 21);"
foo4,"FunctionDefn foo4 = m.addFunctionDefn("foo4", {returnType:"i64", paramTypes:["i64", "i64"]});"
bb4,"BasicBlock bb4 = foo4.appendBasicBlock();"
R0,"Value R0 = foo4.getParam(0);"
R1,"Value R1 = foo4.getParam(1);"
genFn,"FunctionDecl genFn = m.addFunctionDecl("genFn", {returnType: pointerType("i64", 3), paramTypes:[]});"
pty0,"PointerType pty0 = pointerType("i64", 0);"
mainFunction,"FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: pty0, paramTypes: []});"
val,"Value? val = builder.call(genFn, []);"
retVal,"Value retVal = builder.addrSpaceCast(<PointerValue>val, pty0);"
e,"error|PointerValue e = trap m.addGlobal("i64", "sadd.with.overflow.i64.i64");"
fn,"error|FunctionDecl fn = trap m.addFunctionDecl("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});"
fn,"error|FunctionDefn fn = trap m.addFunctionDefn("sadd.with.overflow.i64.i64",{returnType:"i64", paramTypes:["i64"]});"
fn,"error|FunctionDefn fn = trap m.addFunctionDefn("g1",{returnType:"i64", paramTypes:["i64"]});"
fn,"error|FunctionDecl fn = trap m.addFunctionDecl("g1",{returnType:"i64", paramTypes:["i64"]});"
functionData,"Metadata functionData = dIBuilder.createFunction(scope=fileData, name="main", linkageName="test", file=fileData, lineNo=1, ty=functionTy, scopeLine=0);"
tyMeta,"Metadata tyMeta = dIBuilder.createBasicType(name="myInt", encoding="signed", sizeInBits=64);"
varMeta,"Metadata varMeta = dIBuilder.createAutoVariable(ty=tyMeta, scope=functionData, name="myVar", lineNo=2, file=fileData);"
bMeta,"Metadata bMeta = dIBuilder.createAutoVariable(ty=dIBuilder.createBasicType(name="constInt", encoding="signed", sizeInBits=64), scope=functionData, name="B", lineNo=2, file=fileData);"
charMeta,"Metadata charMeta = dIBuilder.createBasicType(name="char", encoding="signed_char", sizeInBits=8);"
taggedPtrMeta,"Metadata taggedPtrMeta = dIBuilder.createTypedef(dIBuilder.createPointerType(pointeeTy=charMeta, sizeInBits=64, addressSpace=1), "TaggedPtr", fileData, 0, scope=fileData);"
cMeta,"Metadata cMeta = dIBuilder.createAutoVariable(ty=taggedPtrMeta, scope=functionData, name="C", lineNo=2, file=fileData);"
emptyExpr,"Metadata emptyExpr = dIBuilder.createExpression([]);"
bScope,"Metadata bScope = dIBuilder.createLexicalBlock(functionData, fileData, 3, 2);"
loc1,"Metadata loc1 = dIBuilder.createDebugLocation(2, 2, bScope);"
loc2,"Metadata loc2 = dIBuilder.createDebugLocation(3, 2, functionData);"
loc3,"Metadata loc3 = dIBuilder.createDebugLocation(4, 2, functionData);"
a,"PointerValue a = builder.alloca("i64");"
b,"PointerValue b = builder.alloca("i64");"
c,"PointerValue c = builder.alloca(pointerType("i8", 1));"
initA,"Value initA = context.constInt("i64", 10);"
retVal,"Value retVal = builder.iArithmeticWrap("add", builder.load(a), context.constInt("i64", 1));"
mainFunction,"FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "void", paramTypes: []});"
fn,"FunctionDefn fn = m.addFunctionDefn(fnName, {returnType: "double", paramTypes: []});"
initBlock,"BasicBlock initBlock = fn.appendBasicBlock();"
mainFunction,"FunctionDefn mainFunction = m.addFunctionDefn("main", {returnType: "i64", paramTypes: ["i64", "i64"]});"
p1,"Value p1 = mainFunction.getParam(0);"
p2,"Value p2 = mainFunction.getParam(1);"
v,"PointerValue v = builder.alloca("i64");"
a,"Value a = builder.iArithmeticWrap("add", p1, p2);"
greater,"BasicBlock greater = mainFunction.appendBasicBlock("greater");"
less,"BasicBlock less = mainFunction.appendBasicBlock("less");"
isGreater,"Value isGreater = builder.iCmp("sge", a, context.constInt("i64", 10));"
b_1,"Value b_1 = builder.iArithmeticWrap("sub", a, context.constInt("i64", 5));"
common,"BasicBlock common = mainFunction.appendBasicBlock();"
b_2,"Value b_2 = builder.iArithmeticWrap("add", a, context.constInt("i64", 5));"
b_3,"Value b_3 = builder.load(v);"
R6,"Value R6 = builder.iCmp("eq", R5, context.constInt("i64", 0));"
bb7,"BasicBlock bb7 = foo.appendBasicBlock();"
bb10,"BasicBlock bb10 = foo.appendBasicBlock();"
bb13,"BasicBlock bb13 = foo.appendBasicBlock();"
bb14,"BasicBlock bb14 = foo.appendBasicBlock();"
R8,"Value R8 = builder.load(R3);"
R9,"Value R9 = builder.iCmp("eq", R8, context.constInt("i64", int:MIN_VALUE));"
R11,"Value R11 = builder.load(R4);"
R12,"Value R12 = builder.iCmp("eq", R11, context.constInt("i64", -1));"
R15,"Value R15 = builder.load(R3);"
R16,"Value R16 = builder.load(R4);"
R17,"Value R17 = builder.iArithmeticSigned("sdiv", R15, R16);"
intTypes,"IntType[] intTypes = ["i64", "i1"];"
out,"string out = typeToString(ty, context);"
pTy,"PointerType pTy = pointerType(ty);"
out,"string out = typeToString(pTy, context);"
ty,"StructType ty = structType(intTypes);"
elements,"ConstValue[] elements = [context.constInt("i64", 1), context.constInt("i64", 10), context.constInt("i64", 100)];"
array,"ConstValue array = context.constArray("i64", elements);"
retTy,"ArrayType retTy = arrayType("i64", 3);"
fn,"FunctionDefn fn = m.addFunctionDefn("test", {returnType: retTy, paramTypes:[]});"
msg,"string msg = "something impossible happened";"
startPos,"Position startPos = tok.currentStartPos();"
td,"TypeDesc td = check parseIntersection(tok);"
td,"TypeDesc td = check parseUnaryTypeDesc(tok);"
tds,"TypeDesc[] tds = [lhs];"
opPos,"Position[] opPos = [];"
right,"TypeDesc right = op == "|" ? check parseIntersection(tok) : check parseUnaryTypeDesc(tok);"
endPos,"Position endPos = tok.previousEndPos();"
unary,"UnaryTypeDesc unary = { startPos, endPos, op: "!", opPos: startPos, td };"
td,"TypeDesc td = check parsePrimaryTypeDesc(tok);"
opPos,"Position opPos = tok.currentStartPos();"
endPos,"Position endPos = tok.currentEndPos();"
optionalTd,"UnaryTypeDesc optionalTd = { startPos, endPos, op: "?", opPos, td };"
dimensions,"SimpleConstExpr?[] dimensions = [];"
endPos,"Position? endPos = ();"
array,"ArrayTypeDesc array = { startPos, endPos: <Position>endPos, member: td , dimensions };"
cur,"Token? cur = tok.current();"
endPos,"Position endPos;"
td,"TypeDesc td = check parseTypeDesc(tok);"
qNamePos,"Position qNamePos = tok.currentStartPos();"
typeName,"string typeName = check tok.expectIdentifier();"
pos,"Position pos = tok.currentStartPos();"
constituent,"TypeDesc constituent = check parseTypeParam(tok);"
rest,"var rest = check parseTypeParam(tok);"
detail,"var detail = check parseTypeParam(tok);"
row,"TypeDesc row = check parseTypeParam(tok);"
prefix,"var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);"
typeName,"var [prefix, typeName] = check parseOptQualIdentifier(tok, identifier);"
valueExpr,"SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);"
params,"FunctionTypeParam[] params = namedParams ?: [];"
paramStartPos,"Position paramStartPos = tok.currentStartPos();"
ret,"TypeDesc? ret = ();"
t,"Token? t = tok.current();"
namePos,"Position namePos = tok.currentStartPos();"
name,"string name = check tok.expectIdentifier();"
members,"TypeDesc[] members = [];"
rest,"TypeDesc? rest = ();"
fields,"FieldDesc[] fields = [];"
fieldStartPos,"Position fieldStartPos = tok.currentStartPos();"
ro,"boolean ro = false;"
endPos,"Position endPos = check tok.expectEnd(";");"
importDecls,"SubSyntaxNode[] importDecls = from ImportDecl decl in part.importDecls select syntaxNodeFromImportDecl(decl);"
moduleLevelDefns,"SubSyntaxNode[] moduleLevelDefns = from ModuleLevelDefn defn in part.defns select syntaxNodeFromModuleLevelDefn(defn);"
childNodes,"SubSyntaxNode[] childNodes = flattenSyntaxNodeList([importDecls, moduleLevelDefns]);"
org,"string? org = decl.org;"
prefix,"string? prefix = decl.prefix;"
nameNodes,"SubSyntaxNode[] nameNodes = joinSyntaxNodesWithSeperator((from int i in 0 ..< decl.names.length() select { name:decl.names[i], pos: i == 0 ? decl.namePos : () }), { token: "." });"
td,"SubsetBuiltinTypeDesc? td = defn.td;"
name,"string? name = param.name;"
body,"SubSyntaxNode[] body = from Stmt stmt in block.stmts select syntaxNodeFromStmt(stmt);"
name,"string? name = stmt.name;"
returnExpr,"Expr? returnExpr = stmt.returnExpr;"
lValue,"LExpr|WILDCARD lValue = stmt.lValue;"
ifFalse,"StmtBlock|IfElseStmt? ifFalse = stmt.ifFalse;"
clauses,"SubSyntaxNode[] clauses = from MatchClause clause in stmt.clauses select syntaxNodeFromMatchClause(clause);"
childNodes,"SubSyntaxNode[][] childNodes = from int i in 0 ..< patterns.length() select i > 0 ? [{ token: "|" }, syntaxNodeFromMatchPattern(patterns[i])] : [syntaxNodeFromMatchPattern(patterns[i])];"
prefix,"string? prefix = expr.prefix;"
identifierPos,"Position? identifierPos = prefix == () ? expr.qNamePos : ();"
token,"string token;"
typeSuffix,"FpTypeSuffix? typeSuffix = expr.typeSuffix;"
op,"BinaryExprOp|BinaryBitwiseOp|BinaryLogicalOp op;"
memberNodes,"SubSyntaxNode[] memberNodes = joinSyntaxNodesWithSeperator((from TypeDesc member in td.members select syntaxNodeFromTypeDesc(member)), { token: "," });"
rest,"TypeDesc? rest = td.rest;"
dimensions,"SubSyntaxNode[][] dimensions = from SimpleConstExpr? dimension in td.dimensions select dimension == () ? [{ token: "[" }, { token: "]" }]: [{ token: "[" }, syntaxNodeFromExpr(dimension), { token: "]" }];"
rest,"TypeDesc|INCLUSIVE_RECORD_TYPE_DESC? rest = td.rest;"
fields,"SubSyntaxNode[] fields = from FieldDesc f in td.fields select syntaxNodeFromFieldDesc(f);"
params,"SubSyntaxNode[] params = joinSyntaxNodesWithSeperator((from FunctionTypeParam param in td.params select syntaxNodeFromFunctionTypeParam(param)), { token: "," });"
retTd,"TypeDesc? retTd = td.ret;"
prefix,"string? prefix = td.prefix;"
childNodes,"SubSyntaxNode[] childNodes = [{ token: td.op, pos: td.startPos }, syntaxNodeFromTypeDesc(td.td)];"
valueExpr,"ExtendedLiteralExpr valueExpr = td.valueExpr;"
childNodes,"SubSyntaxNode[] childNodes = flattenSyntaxNodeList(nodes);"
newNodes,"SubSyntaxNode[] newNodes = [];"
nodes,"SubSyntaxNode[] nodes = [];"
words,"Word[] words = [];"
childNodes,"SubSyntaxNode[] childNodes = node.childNodes;"
flags,"OutputFlags flags = terminalSyntaxNodeFlags(child, node);"
parent,"AstNode? parent = parentNode != () ? syntaxNodeToAstNode(parentNode) : ();"
name,"string name = parent is FunctionCallExpr ? parent.funcName : parent.methodName;"
astNode,"AstNode astNode = node.astNode;"
chunks,"string[] chunks = ["\""];"
Char,"string:Char? singleEscaped = REVERSE_ESCAPES[ch];"
lines,"string[] lines = [];"
skipSpace,"boolean skipSpace = true;"
ignoreNewLine,"boolean ignoreNewLine = false;"
indentSize,"int indentSize = 0;"
token,"Word token = words[i];"
nextToken,"Word? nextToken = i < words.length() - 1 ? words[i + 1] : ();"
lastLine,"string lastLine = string"
filteredLines,"string[] filteredLines = from string line in lines where line.trim().length() > 0 select line;"
Char,":Char?[] { string:Char?[] fragFixed = [];"
ft,"FixedToken?[] ft = [];"
s,"string s = checkpanic string"
fragCodes,"readonly & FragCode[] fragCodes = line.fragCodes;"
fragments,"readonly & string[] fragments = line.fragments;"
fragCodeIndex,"int fragCodeIndex = 0;"
fragmentIndex,"int fragmentIndex = 0;"
code,"FragCode code = fragCodes[fragCodeIndex];"
ft,"FixedToken? ft = fragTokens[<int>code];"
lineContent,"string[] lineContent = [];"
hexDigits,"string hexDigits = fragment.substring(3, fragment.length() - 1);"
codePoint,"int codePoint = check int"
:Char,"string:Char"
result,"ScannedLine[] result = from var l in lines select scanLine(l);"
codePoints,"int[] codePoints = line.toCodePointInts();"
fragCodes,"FragCode[] fragCodes = [];"
endIndex,"int[] endIndex = [];"
fragments,"string[] fragments;"
nVarFragments,"int nVarFragments = 0;"
fragments,"string[] fragments = [];"
startIndex,"int startIndex = 0;"
lineStartIndex,"int lineStartIndex = 0;"
cr,"int? cr = ();"
len,"final int len = codePoints.length();"
i,"int i = startIndex;"
cp,"int cp = codePoints[i];"
cp2,"int cp2 = codePoints[i];"
endIndex,"int? endIndex = scanFractionExponent(codePoints, i);"
endIndex,"int? endIndex = scanHexDigits(codePoints, i + 1);"
startResultLength,"final int startResultLength = result.fragCodes.length();"
len,"int len = codePoints.length();"
endIndex,"int? endIndex = scanNumericEscape(codePoints, i + 1);"
i,"int i = scanOptDigits(codePoints, startIndex);"
endIndex,"int? endIndex = scanFractionExponent(codePoints, i + 1);"
endIndex,"int? endIndex = scanExponent(codePoints, i + 1);"
ei,"int[] ei = result.endIndex;"
len,"int len = ei.length();"
startIndex,"int startIndex = len > 0 ? ei[len - 1] : 0;"
ki,"int? ki = keywordIndex(codePoints, startIndex, i);"
kw,"string kw = checkpanic string"
fc,"FragCode[] fc = result.fragCodes;"
len,"int len = fc.length();"
stmts,"Stmt[] stmts = [];"
closeBracePos,"Position closeBracePos = tok.currentStartPos();"
peeked,"var peeked = tok.peek(skipQualIdent=true);"
isTypeDesc,"boolean isTypeDesc = check savePreparseRestore(tok, preparseArrayTypeDesc);"
stmt,"BreakContinueStmt stmt = { startPos, endPos, breakContinue:<BreakContinue>cur };"
peeked,"var peeked = tok.peek();"
state,"TokenizerState state = tok.save();"
isTypeDesc,"boolean isTypeDesc = check func(tok);"
name,"string name;"
prefix,"string? prefix;"
expr,"FunctionCallExpr expr = check finishFunctionCallExpr(tok, prefix, name, startPos);"
lExpr,"LExpr lExpr = { startPos, endPos, name, qNamePos: startPos, prefix };"
index,"Expr index = check parseInnerExpr(tok);"
expr,"Expr expr = check startPrimaryExpr(tok);"
primary,"Expr primary = check finishPrimaryExpr(tok, expr, startPos);"
stmt,"CallStmt stmt;"
innerKwPos,"Position innerKwPos = tok.currentStartPos();"
operandStmt,"CallStmt operandStmt = check finishCheckingCallStmt(tok, t, innerKwPos);"
operandStmt,"CallStmt operandStmt = check parseMethodCallStmt(tok);"
operand,"Expr operand = check parsePrimaryExpr(tok);"
expr,"CheckingCallExpr expr = { startPos: kwPos, endPos: operand.endPos, checkingKeyword, kwPos, operand};"
expr,"Expr expr = check parseExpr(tok);"
stmt,"AssignStmt stmt = { startPos, endPos, opPos, lValue, expr };"
opStr,"string opStr = op;"
binOp,"BinaryArithmeticOp|BinaryBitwiseOp binOp = <BinaryArithmeticOp|BinaryBitwiseOp> opStr.substring(0, opStr.length() - 1);"
stmt,"CompoundAssignStmt stmt = { startPos, endPos, opPos, lValue, expr, op: binOp };"
name,"string|WILDCARD name;"
opPos,"Position opPos = check tok.expectStart("=");"
initExpr,"Expr initExpr = check parseExpr(tok);"
returnExpr,"Expr? returnExpr;"
panicExpr,"Expr panicExpr = check parseExpr(tok);"
ifFalse,"IfElseStmt|StmtBlock? ifFalse;"
condition,"Expr condition = check parseExpr(tok);"
ifTrue,"StmtBlock ifTrue = check parseStmtBlock(tok);"
ifFalseStartPos,"Position ifFalseStartPos = tok.currentStartPos();"
body,"StmtBlock body = check parseStmtBlock(tok);"
kwPos,"Position kwPos = check tok.expectStart("in");"
range,"RangeExpr range = check parseRangeExpr(tok);"
expr,"Expr expr = check parseInnerExpr(tok);"
clauses,"MatchClause[] clauses = [];"
patterns,"MatchPattern[] patterns = check parseMatchPatternList(tok);"
opPos,"Position opPos = check tok.expectStart("=>");"
block,"StmtBlock block = check parseStmtBlock(tok);"
patterns,"MatchPattern[] patterns = [];"
parenResult,"boolean? parenResult = check preparseBracketed(tok, close);"
squareResult,"boolean? squareResult = check preparseBracketed(tok, "]");"
result,"boolean? result = check preparseBracketed(tok, closeBracketMap.get(<string>t));"
members,"var [members, _] = check parseExprList(tok, "]");"
expr,"ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };"
fields,"Field[] fields = check parseFields(tok);"
expr,"MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };"
expr,"Expr expr = check parseLogicalAndExpr(tok);"
right,"Expr right = check parseLogicalAndExpr(tok);"
bin,"BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };"
expr,"Expr expr = check parseBitwiseOrExpr(tok);"
right,"Expr right = check parseBitwiseOrExpr(tok);"
bin,"BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };"
expr,"Expr expr = check parseBitwiseXorExpr(tok);"
right,"Expr right = check parseBitwiseXorExpr(tok);"
bin,"BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };"
expr,"Expr expr = check parseBitwiseAndExpr(tok);"
right,"Expr right = check parseBitwiseAndExpr(tok);"
expr,"Expr expr = check parseEqualityExpr(tok);"
right,"Expr right = check parseEqualityExpr(tok);"
expr,"Expr expr = check parseRelationalExpr(tok);"
right,"Expr right = check parseRelationalExpr(tok);"
bin,"BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };"
expr,"Expr expr = check parseShiftExpr(tok);"
right,"Expr right = check parseShiftExpr(tok);"
bin,"BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };"
t2,"Token? t2 = tok.current();"
kwPos,"Position kwPos = tok.currentStartPos();"
lower,"Expr lower = check parseAdditiveExpr(tok);"
opPos,"Position opPos = check tok.expectStart("..<");"
upper,"Expr upper = check parseAdditiveExpr(tok);"
expr,"Expr expr = check parseAdditiveExpr(tok);"
right,"Expr right = check parseAdditiveExpr(tok);"
shift,"BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };"
expr,"Expr expr = check parseMultiplicativeExpr(tok);"
right,"Expr right = check parseMultiplicativeExpr(tok);"
bin,"BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };"
expr,"Expr expr = check parseUnaryExpr(tok);"
right,"Expr right = check parseUnaryExpr(tok);"
operand,"Expr operand = check parseUnaryExpr(tok);"
expr,"UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };"
expr,"CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };"
expr,"TypeCastExpr expr = { startPos, endPos, opPos, td, operand };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };"
expr,"FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: () };"
innerExpr,"Expr innerExpr = check parseInnerExpr(tok);"
expr,"LiteralExpr expr = { startPos, endPos, value: t == "true" };"
message,"Expr message = check parseExpr(tok);"
accessEndPos,"Position accessEndPos = check tok.expectEnd("]");"
accessExpr,"MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };"
qnamePos,"Position qnamePos = tok.currentStartPos();"
name,"string name = check parseIdentifierOrMethodName(tok);"
fieldAccessExpr,"FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };"
openParenPos,"Position openParenPos = tok.currentStartPos();"
args,"var [args, closeParenPos] = check parseExprList(tok, ")");"
closeParenPos,"var [args, closeParenPos] = check parseExprList(tok, ")");"
exprs,"Expr[] exprs = [];"
closeTerminatorPos,"Position closeTerminatorPos = tok.currentStartPos();"
fields,"Field[] fields = [];"
f,"Field f = check parseField(tok);"
isIdentifier,"boolean isIdentifier = t[0] == IDENTIFIER;"
name,"string name = t[1];"
colonPos,"Position colonPos = tok.currentStartPos();"
value,"Expr value = check parseExpr(tok);"
f,"Field f = { startPos, endPos, colonPos, name, value, isIdentifier };"
operand,"NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);"
expr,"SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };"
expr,"LiteralExpr expr = { startPos, endPos, value };"
endPos,"Position endPos = check tok.expectEnd(")");"
prefix,"var [prefix, name] = check parseOptQualIdentifier(tok, identifier);"
name,"var [prefix, name] = check parseOptQualIdentifier(tok, identifier);"
untypedLiteral,", var untypedLiteral"
typeSuffix,", var typeSuffix] => { Position"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits };"
:fromHexString,": int:fromHexString(digits);"
tok,"Tokenizer tok = new(self.tokState.file);"
tok,"Tokenizer tok = new (file);"
tok,"Tokenizer tok = scanned.tokenizer();"
defns,"ModuleLevelDefn[] defns = [];"
part,"ModulePart part = { file: scanned.sourceFile(), partIndex: scanned.partIndex, defns, importDecls: scanned.importDecls };"
imports,"ImportDecl[] imports = [];"
im,"ImportDecl im = check parseImportDecl(tok, partIndex);"
firstModuleName,"string firstModuleName = check validImportPart(tok);"
org,"string? org = ();"
names,"[string, string...] names = [firstModuleName];"
prefix,"string? prefix = check parseImportPrefix(tok);"
names,"string[] names = [];"
identifier,"string identifier = check tok.expectIdentifier();"
prevChar,"string? prevChar = ();"
vis,"Visibility vis;"
td,"SubsetBuiltinTypeDesc? td = ();"
tdStartPos,"Position tdStartPos = tok.currentStartPos();"
tdEndPos,"Position tdEndPos = tok.currentEndPos();"
params,"FunctionParam [] params = [];"
typeDesc,"FunctionTypeDesc typeDesc = check parseFunctionTypeDesc(tok, params);"
defn,"FunctionDefn defn = { startPos, endPos, params, typeDesc, name, vis, namePos, body, part };"
message,"string message = "parse error";"
str,"string str = "";"
fragCodeIndex,"int fragCodeIndex = self.fragCodeIndex;"
fragCodes,"FragCode[] fragCodes = self.fragCodes;"
fragCode,"FragCode fragCode = fragCodes[fragCodeIndex];"
fragment,"string fragment = self.getFragment();"
ch,"string|error ch = unicodeEscapeValue(fragment);"
number,"string number = self.getFragment();"
ft,"FixedToken? ft = fragTokens[<int>fragCode];"
fragCodes,"readonly & FragCode[] fragCodes = self.fragCodes;"
lineIndex,"int lineIndex = self.lineIndex;"
i,"int i = self.fragCodeIndex;"
nextFragCode,"FragCode nextFragCode = fragCodes[i];"
lineIndex,"var [lineIndex, codePointIndex] = unpackPosition(pos);"
codePointIndex,"var [lineIndex, codePointIndex] = unpackPosition(pos);"
fragIndex,"var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);"
fragmentIndex,"var [fragIndex, fragmentIndex] = scanLineFragIndex(self.file.scannedLine(lineIndex), codePointIndex);"
fragment,"string fragment = self.fragments[self.fragmentIndex];"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex];"
t,"Token? t = self.curTok;"
msg,"d:Message msg;"
pos,"Position pos = self.currentEndPos();"
pos,"Position pos = self.currentStartPos();"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex - 1];"
startPos,"Position startPos;"
endPos,"Position? endPos;"
startLineNum,"var [startLineNum, startColumnNum] = self.lineColumn(startPos);"
startColumnNum,"var [startLineNum, startColumnNum] = self.lineColumn(startPos);"
line,"ScannedLine line = self.scannedLine(startLineNum);"
lineFragments,"string[] lineFragments = scanLineFragments(line);"
lineContent,"string lineContent = "".'join(...lineFragments);"
endColumnNum,"int endColumnNum;"
endLineNum,"int endLineNum;"
lineNum,"var [lineNum, startColumnNum] = self.lineColumn(startPos);"
startColumnNum,"var [lineNum, startColumnNum] = self.lineColumn(startPos);"
line,"ScannedLine line = self.scannedLine(lineNum);"
endColumnNum,"int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);"
fragIndex,"var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);"
fragmentIndex,"var [fragIndex, fragmentIndex] = scanLineFragIndex(line, startCodePointIndex);"
fragments,"string[] fragments = line.fragments;"
fragCodes,"FragCode[] fragCodes = line.fragCodes;"
endCodePointIndex,"int endCodePointIndex = startCodePointIndex;"
fragmentIndex,"int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);"
nCodePoints,"int nCodePoints = 0;"
nFragments,"int nFragments = fragments.length();"
fragCode,"FragCode fragCode = fragCodes[fragmentIndex];"
file,"SourceFile file = createSourceFile([str], { filename: "<internal>" });"
tok,"Tokenizer tok = new(file);"
left,"Identifier|TypeProjection left = check parseTypeProjection(tok);"
op,"SubtypeTestOp op;"
right,"Identifier|TypeProjection right = check parseTypeProjection(tok);"
identifier,"Identifier identifier = check tok.expectIdentifier();"
index,"int|Identifier index;"
actualNode,"err:Syntax|SyntaxNode actualNode = syntaxNodeFromLines(k, rule, subject);"
normalizedActualNode,"SyntaxNode normalizedActualNode = normalizeSyntaxNode(actualNode);"
actualNodeLines,"string[] actualNodeLines = syntaxNodeToString(normalizedActualNode);"
node,"SyntaxNode node;"
file,"SourceFile file = createSourceFile(lines, { filename: k });"
t,"err:Syntax|Token? t = advance(tok, k, lines);"
lc,"d:LineColumn lc = file.lineColumn(tok.currentStartPos());"
src,"string src = lines[lc[0] - 1];"
tStart,"int tStart = lc[1];"
tStr,"string tStr = tokenToString(t);"
srcAtPos,"string srcAtPos = src.substring(tStart, tStart + tStr.length());"
e,"err:Syntax? e = tok.advance();"
all,"map<TokenizerTestCase> all = check invalidTokenSourceFragments();"
invalidCases,"int invalidCases = all.length();"
valid,"map<ParserTestCase> valid = check readParserTests();"
sources,"SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];"
tests,"map<TokenizerTestCase> tests = {};"
tests,"map<ParserTestCase> tests = {};"
testData,"ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();"
expected,"string[] expected;"
subject,"string subject = s[2];"
subjectLines,"string[] subjectLines = splitIntoLines(subject);"
rule,"string rule = s[1];"
testFiles,"var testFiles = check file:readDir("modules/front.syntax/tests/data");"
path,"string path = f.absPath;"
base,"string base = check file:basename(path);"
src,"string[] src = check readCase(path);"
parentDir,"string parentDir = check file:parentPath(path);"
canonFile,"string canonFile = check file:joinPath(parentDir, canonFileName(base));"
baseParts,"[Kind, string] baseParts = check splitTestName(base);"
rule,"string rule = baseParts[1];"
len,"int len = base.length();"
kindPos,"int kindPos = base.indexOf("-") ?: 0;"
kind,"string kind = base.substring(0, kindPos);"
afterKindPos,"int afterKindPos = min(kindPos + 1, len);"
rulePos,"int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;"
rule,"string rule = base.substring(afterKindPos, rulePos);"
caseLines,"string[] caseLines = [];"
inCase,"boolean inCase = false;"
indented,"int indented = 0;"
trimLine,"string trimLine = line.trim();"
sansExt,"string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());"
