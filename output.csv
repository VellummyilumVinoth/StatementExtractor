testDir,"foreach var testDir in check file:readDir(opts.transformedDir) { if testDir.dir { var [newSkipped, newUnchanged, newChanged] = check compareDir(opts.baseDir, opts.transformedDir, check pathEnd(testDir.absPath)); skipped.push(...newSkipped); changed.push(...newChanged); unchanged.push(...newUnchanged); } }"
test,"foreach var test in check file:readDir(transformedTestDir) { if !test.dir { var [newSkipped, newUnchanged, newChanged] = check compareTest(baseTestDir, transformedTestDir, check pathEnd(test.absPath)); skipped.push(...newSkipped); changed.push(...newChanged); unchanged.push(...newUnchanged); } }"
line,"foreach string line in lines { if line.startsWith("Test-Case:") { if content.length() != 0 { tests.push({ description, content, path }); } content = []; description = ""; s = CONTENT; } else if line.startsWith("Description:") { description = line; s = DESCRIPTION; } else if s is DESCRIPTION { if line.startsWith("Labels:") { s = CONTENT; } else { description += "\n" + line; } } content.push(line); }"
diff,"foreach TestDiffResult diff in diffs { string path = diff.base.path; if path != currentPath { if currentPath != "" { body.push("<hr>"); } body.push(string `<h3>${check file:basename(path)}</h3>`); currentPath = path; } body.push(string `<pre>${"<br>".'join(...diff.base.content)}</pre>`); body.push("<hr>"); }"
diff,"foreach TestDiffResult diff in diffs { string path = diff.base.path; if path != currentPath { currentPath = path; body.push("</table>"); body.push(string `<h3>${check file:basename(path)}</h3>`); body.push( "<table>", "<tr>", "<th>Base</th>", "<th>Transformed</th>", "</tr>" ); } body.push("<tr>"); body.push(string `<td><pre>${"<br>".'join(...diff.base.content)}</pre></td>`); body.push(string `<td><pre>${"<br>".'join(...(<TestCase>diff.transformed).content)}</pre></td>`); body.push("</tr>"); }"
path,"foreach string path in paths { BaltTestCase[] tests = check parseTest(path); total += tests.length(); string[] parts = check file:splitPath(path); string filename = parts[parts.length() - 1]; string dir = parts[parts.length() - 2]; skipped += check outputTest(tests, dir, filename, skipLabels); }"
line,"foreach string line in lines { if line.startsWith("Test-Case:") { if s != BOF { content = addImports(content, useIoLib); testCases.push({ header, labels, content }); header = []; labels = []; content = []; useIoLib = false; } s = HEADER; header.push(line); } else if line.startsWith("Labels:") { var [_, fBody] = parseField(line); labels = parseCharSeparatedList(fBody, ","); s = LABEL; } else if s is HEADER|LABEL && line.trim() == "" { s = CONTENT; } else { match s { HEADER => { header.push(line); } LABEL => { labels.push(...parseCharSeparatedList(line, ",")); } CONTENT => { var [contentLine, newLabels] = transformContent(line); useIoLib = useIoLib ? useIoLib : contentLine.indexOf("io:") != (); content.push(contentLine); foreach var label in newLabels { if labels.indexOf(label) == () { labels.push(label); } } } } } }"
label,"foreach var label in newLabels { if labels.indexOf(label) == () { labels.push(label); } }"
line,"return from string line in check io:fileReadLines(skipListPath) select parseCharSeparatedList(line, " ");"
:Char,"foreach string:Char c in s { if c == sep { labels.push("".'join(...content)); content = []; } else if c == " " { continue; } else { content.push(c); } }"
skipTest,"foreach BaltTestCase test in tests { index += 1; boolean skipTest = false; foreach int skipIndex in skipIndices { if skipIndex == index { skipTest = true; break; } } if skipTest || !testValid(test, skipLabels) { skipped += 1; continue; } body.push(...test.header); body.push("Labels: " + ", ".'join(...test.labels)); body.push(""); body.push(...test.content); }"
test,"foreach int skipIndex in skipIndices { if skipIndex == index { skipTest = true; break; } }"
skipIndex,"foreach string[] labelGroup in skipLabels { boolean invalid = true; foreach string label in labelGroup { if test.labels.indexOf(label, 0) == () { invalid = false; break; } } if invalid { return false; } }"
labelGroup,"foreach string label in labelGroup { if test.labels.indexOf(label, 0) == () { invalid = false; break; } }"
tc,"foreach BasicBlock b in code.blocks { check verifyBasicBlock(vc, b); }"
defn,"foreach int fid in cx.fwdInDegrees { if fid == 0 { Insn[] insns = cx.blocks[i].insns; if insns.length() > 0 { return cx.invalidErr(`unreachable block: ${i}`, insns[0].pos); } else { return cx.invalidErr(`unreachable and empty block: ${i}`); } } i += 1; }"
funcPos,"foreach var reg in regs { if reg is ParamRegister { if afterParams { return vc.invalidErr("param register is not at the beginning of the register list", reg.pos); } paramRegs.push(true); } else { paramRegs.push(false); afterParams = true; } }"
blocks,"foreach var insn in block.insns { if insn is TypeMergeInsn { check verifyTypeMergeFlow(cx, afterMerge, flows, insn); } else { afterMerge = true; } match insn { var { result } => { regs[result.number] = true; } var { operand } => { check verifyOperandInitialized(cx, operand, regs, insn.pos); } var { operands } | var { args: operands } => { foreach Operand op in <Operand[]>operands { check verifyOperandInitialized(cx, op, regs, insn.pos); } } } } Label? onPanic = block.onPanic; Insn term = check blockTerminator(cx, block, viaPos); Position termPos = term.pos; if onPanic != () { check verifyRegFlow(cx, onPanic, { origin: current, regs }, termPos); } if term is BranchInsn && !term.backward { check verifyRegFlow(cx, term.dest, { origin: current, regs }, termPos); } else if term is CondBranchInsn { check verifyRegFlow(cx, term.ifTrue, { origin: current, regs: regs.clone() }, termPos); check verifyRegFlow(cx, term.ifFalse, { origin: current, regs }, termPos); } else if term is TypeBranchInsn { RegSet trueRegs = regs.clone(); RegSet falseRegs = regs; trueRegs[term.ifTrueRegister.number] = true; falseRegs[term.ifFalseRegister.number] = true; check verifyRegFlow(cx, term.ifTrue, { origin: current, regs: trueRegs }, termPos); check verifyRegFlow(cx, term.ifFalse, { origin: current, regs: falseRegs }, termPos); } }"
fwdInDegrees,"foreach Operand op in <Operand[]>operands { check verifyOperandInitialized(cx, op, regs, insn.pos); }"
blocksFlows,"foreach Label pred in merge.predecessors { RegFlow? flow = flowOriginating(flows, pred); if flow!= () { check verifyOperandInitialized(cx, merge.operands[i], flow.regs, merge.pos); } else { return cx.invalidErr(`superfluous predecessor ${pred} in TypeMergeInsn`, merge.pos); } i += 1; }"
preds,"foreach RegFlow flow in flows { if flow.origin == origin { return flow; } }"
b,"foreach int i in 0 ..< numReg { boolean conj = true; foreach var { regs } in flow { if !regs[i] { conj = false; break; } } result.push(conj); }"
fid,"foreach Insn insn in bb.insns { check verifyInsn(vc, insn); }"
reg,"foreach Register r in insn.operands { if unnarrowedOp.number != unnarrow(r).number { return vc.invalidErr("underlying register of narrow register is incorrect", insn.pos); } union = t:union(union, r.semType); }"
insn,"foreach int i in 0 ..< nSuppliedArgs { check validOperandType(vc, insn.args[i], sig.paramTypes[i], `wrong argument type for parameter ${i + 1} in call to function ${vc.symbolToString(func.symbol)}`, vc.qNameRange(insn.pos)); }"
op,"foreach int i in 0 ..< operands.length() { check validOperandType(vc, operands[i], t:listAtomicTypeMemberAtInnerVal(lat, i), "type of list constructor member is not allowed by the list type", insn.pos); }"
pred,"foreach int i in 0 ..< insn.operands.length() { check validOperandType(vc, insn.operands[i], t:mappingAtomicTypeMemberAtInnerVal(mat, insn.fieldNames[i]), "type of mapping constructor member is not allowed by the mapping type", insn.pos); }"
NIL_OPERAND,"foreach Insn insn in block.insns { if isInsnPotentiallyPanicking(insn) { return true; } }"
,"foreach var word in body { words.push(word); }"
DataValue,"foreach int i in 0 ..< elements.length() { final Value element = elements[i]; if i > 0 { structBody.push(","); } structBody.push(typeToString(element.ty, self)); if element.operand is Unnamed { panic err:illegalArgument("All elements must be constants"); } else { structBody.push(<string>element.operand); } elemTypes.push(element.ty); }"
operand,"foreach int i in 0 ..< values.length() { final ConstValue element = values[i]; if i > 0 { body.push(","); } body.push(typeToString(element.ty, self), element.operand); }"
ty,"foreach var entry in self.namedStructTypes.entries() { var data = entry[1]; if data[1] { string[] words = [entry[0], "=", "type", typeToString(data[0], self, true)]; out.push(concat(...words)); } }"
class,"foreach var flagMetadata in self.moduleFlags { preambleWords.push(flagMetadata.ref(), ","); flagMetadata.resetPreamble(); }"
,"foreach var attr in attrs { fn.addEnumAttribute(attr); }"
class,"foreach var val in self.globalVariables { self.outputGlobalVar(val[0], val[1], out); }"
,"foreach var val in self.aliases { self.outputAlias(val[0], val[1], val[2], out); }"
class,"foreach var fn in self.functionDecls { fn.output(out); }"
,"foreach var fn in self.functionDefns { fn.output(out); }"
word,"foreach var data in self.metadata { if data.hasPreamble() { data.outputPreamble(out); } }"
POS_INF,"foreach var data in self.metadata { data.output(out); }"
NEG_INF,"foreach int i in 0 ..< functionType.paramTypes.length() { final Type paramType = functionType.paramTypes[i]; string register = "%" + i.toString(); Value arg = new (paramType, register); self.paramValues.push(arg); }"
NAN,"foreach var b in self.basicBlocks { b.updateUnnamed(); }"
Context,"foreach var b in self.basicBlocks { b.output(out, isFirst); isFirst = false; }"
i,"foreach var line in self.lines { out.push(line); }"
i,"foreach var line in self.preamble { out.push(line); }"
entry,"foreach int i in 0 ..< flags.length() { if i > 0 { words.push("|"); } words.push(flags[i]); }"
,"foreach int i in 0 ..< args.length() { final Value arg = args[i]; if i > 0 { insnWords.push(","); } insnWords.push(typeToString(arg.ty, self.context)); insnWords.push(arg.operand); }"
Module,"foreach var word in words{ if word is string{ currentChunk.push(word); } else { chunks.push(concat(...currentChunk)); currentChunk = []; chunks.push(word); } }"
flagMetadata,"foreach var line in self.lines { (string|Unnamed)[] newLine = []; foreach var name in line { newLine.push(self.func.updateUnnamed(name)); } newLines.push(newLine); }"
attr,"foreach var name in line { newLine.push(self.func.updateUnnamed(name)); }"
val,"foreach var line in self.lines { string[] newLine = []; foreach var name in line { newLine.push(self.func.updateBasicBlockRef(name)); } string outputLine = createLine([concat(...newLine)], INDENT); out.push(outputLine); }"
val,"foreach var name in line { newLine.push(self.func.updateBasicBlockRef(name)); }"
fn,"foreach int i in 0 ..< elementTypes.length() { final Type elementType = elementTypes[i]; if i > 0 { typeStringBody.push(","); } typeStringBody.push(typeToString(elementType, context)); }"
fn,"foreach int i in 0 ..< ty.paramTypes.length() { final Type paramType = ty.paramTypes[i]; if i > 0 { typeStringBody.push(","); } typeStringBody.push(typeToString(paramType, context)); }"
data,"foreach Type element in elementTypes { includeNamedType(element, context); }"
data,"foreach Type paramType in ty.paramTypes { includeNamedType(paramType, context); }"
,"foreach int i in 0 ..< fn.returnAttributes.length() { words.push(fn.returnAttributes[i]); }"
FunctionDecl,"foreach int i in 0 ..< fn.functionType.paramTypes.length() { final Type ty = fn.functionType.paramTypes[i]; if i > 0 { words.push(","); } words.push(typeToString(ty, fn.context)); foreach int j in 0 ..< fn.paramAttributes[i].length() { words.push(fn.paramAttributes[i][j]); } if fn is FunctionDefn { words.push(<string>fn.getParam(i).operand); } }"
,"foreach int j in 0 ..< fn.paramAttributes[i].length() { words.push(fn.paramAttributes[i][j]); }"
FunctionDefn,"foreach int i in 0 ..< fn.functionAttributes.length() { words.push(fn.functionAttributes[i]); }"
i,"foreach string word in words { string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : ""; if lastTail.length() > 0 { lastTail = lastTail.substring(lastTail.length() - 1); } string head = word.length() > 0 ? word.substring(0, 1) : ""; if !(omitSpaceBefore(word) || (head != "\"" && omitSpaceBefore(head))) && parts.length() > 0 && !(omitSpaceAfter(parts[parts.length() - 1]) || (lastTail != "\"" && omitSpaceAfter(lastTail))) { parts.push(" "); } parts.push(word); }"
b,"foreach var ch in name { escaped += escapeIdentChar(ch); }"
b,"foreach byte b in bytes { result += "\\" + b.toHexString().toUpperAscii(); }"
,"foreach var index in indices { words.push(","); words.push(typeToString(index.ty, context)); words.push(index.operand); if resultType is PointerType { resultAddressSpace = resultType.addressSpace; resultType = resultType.pointsTo; } else { if resultType is ArrayType { resultType = resultType.elementType; } else if resultType is StructType { int i; if index.operand is Unnamed { i = <Unnamed>index.operand; } else { i = checkpanic int:fromString(<string>index.operand); } Type indexTy = index.ty; if indexTy !is "i32" { panic err:illegalArgument("structures can be index only using i32 constants"); } else { resultType = getTypeAtIndex(resultType, i, context); } } else { panic err:illegalArgument(string `type ${typeToString(resultType, context)} can't be indexed`); } } }"
Metadata,"foreach var b in bytes { if b >= 0x20 && b < 0x7F && b != CP_DOUBLE_QUOTE && b != CP_BACKSLASH { result += checkpanic string:fromBytes([b]); } else { result += "\\"; string hex = b.toHexString().toUpperAscii(); if hex.length() == 1 { result += "0" + hex; } else { result += hex; } } }"
label,"foreach var ch in name { if !isIdentFollow(ch) { return false; } }"
name,"foreach var name in names { FunctionDecl f = m.getIntrinsicDeclaration(name); testLLVMOverflowArithmeticFunctionType(f.functionType); string functionName = "llvm." + name; test:assertEquals(f.functionName, functionName); }"
attribute,"foreach var attribute in attributes { fDecl.addEnumAttribute(attribute); test:assertNotExactEquals(fDecl.functionAttributes.indexOf(attribute), ()); }"
attribute,"foreach var attribute in attributes { fDefn.addEnumAttribute(attribute); test:assertNotExactEquals(fDefn.functionAttributes.indexOf(attribute), ()); }"
ty,"foreach var ty in intTypes { string out = typeToString(ty, context); test:assertEquals(out, ty); }"
ty,"foreach var ty in intTypes { PointerType pTy = pointerType(ty); string out = typeToString(pTy, context); test:assertEquals(out, string `ptr`); }"
i,"return from int i in 0 ..< patterns.length() select nonTerminalSyntaxNode(patterns[i], childNodes[i]);"
arg,"return nonTerminalSyntaxNode(expr, prefix != () ? [{ name: prefix, pos: expr.qNamePos }, { token: ":" }] : (), { name: expr.funcName, pos: prefix == () ? expr.qNamePos : () }, { token: "(", pos: expr.openParenPos }, (joinSyntaxNodesWithSeperator((from Expr arg in expr.args select syntaxNodeFromExpr(arg)), { token: "," })), { token: ")" });"
arg,"return nonTerminalSyntaxNode(expr, syntaxNodeFromExpr(expr.target), { token: ".", pos: expr.opPos }, { name: expr.methodName, pos: expr.namePos }, { token: "(", pos: expr.openParenPos }, (joinSyntaxNodesWithSeperator((from Expr arg in expr.args select syntaxNodeFromExpr(arg)), { token: "," })), { token: ")" });"
member,"return nonTerminalSyntaxNode(expr, { token: "[", pos: expr.startPos }, (joinSyntaxNodesWithSeperator((from Expr member in expr.members select syntaxNodeFromExpr(member)), { token: "," })), { token: "]" });"
f,"return nonTerminalSyntaxNode(expr, { token: "{", pos: expr.startPos }, (joinSyntaxNodesWithSeperator((from Field f in expr.fields select syntaxNodeFromField(f)), { token: "," })), { token: "}" });"
operand,"return nonTerminalSyntaxNode(td, joinSyntaxNodesWithSeperator(from TypeDesc operand in td.tds select syntaxNodeFromTypeDesc(operand), { token: td.op }));"
i,"foreach int i in 0 ..< nodes.length() { if i > 0 { newNodes.push(seperator); } newNodes.push(nodes[i]); }"
node,"foreach var node in arr { if node is SubSyntaxNode[] { foreach var child in node { nodes.push(child); } } else if node is SubSyntaxNode { nodes.push(node); } }"
child,"foreach var child in node { nodes.push(child); }"
child,"foreach var child in childNodes { if child is TerminalSyntaxNode { OutputFlags flags = terminalSyntaxNodeFlags(child, node); if (flags & CLING_PREV) != 0 { words.push(<Word>CLING); } if (flags & NEWLINE_BEFORE) != 0 { words.push(<Word>NEWLINE); } if (flags & SINGLE_LINE_START) != 0 { words.push(<Word>SINGLE_LINE_START); } words.push(terminalSyntaxNodeToString(child, flags)); if (flags & SINGLE_LINE_END) != 0 { words.push(<Word>SINGLE_LINE_END); } if (flags & CLING_NEXT) != 0 { words.push(<Word>CLING); } if (flags & NEWLINE_AFTER) != 0 { words.push(<Word>NEWLINE); } } else { syntaxNodeToWords(words, child); } }"
REVERSE_ESCAPES,"foreach var ch in str { string:Char? singleEscaped = REVERSE_ESCAPES[ch]; if singleEscaped == () { int cp = ch.toCodePointInt(); if 0x20 <= cp && cp < 0x7F { chunks.push(ch); } else { chunks.push("\\u{", cp.toHexString().toUpperAscii(), "}"); } } else { chunks.push("\\", singleEscaped); } }"
ch,"foreach int i in 0 ..< words.length() { Word token = words[i]; Word? nextToken = i < words.length() - 1 ? words[i + 1] : (); if token is string { if (token == "}" || token == "|}") { if !ignoreNewLine { indentSize -= 1; parts = addNewLine(parts, lines, indentSize); } else { parts.push(" "); } } if !skipSpace && !omitSpaceBefore(token) { parts.push(" "); } parts.push(token); skipSpace = omitSpaceAfter(token); if (token == "{" || token == "{|") { if !ignoreNewLine { indentSize += 1; parts = addNewLine(parts, lines, indentSize); } else if nextToken != "}" && nextToken != "|}" { parts.push(" "); } } if (token == "}" || token == "|}") && nextToken != ";" && !ignoreNewLine { parts = addNewLine(parts, lines, indentSize); } } else if token == CLING { skipSpace = true; } else if token is SINGLE_LINE_START{ ignoreNewLine = true; } else if token is SINGLE_LINE_END { ignoreNewLine = false; } else if token == NEWLINE && !ignoreNewLine { skipSpace = true; parts = addNewLine(parts, lines, indentSize); } }"
i,"foreach int i in 0 ..< indentSize { content.push(" "); }"
keywords,"foreach int i in 0 ..< keywords.length() { ft[FRAG_KEYWORD + i] = keywords[i]; }"
Char,"foreach int cp in 0x20 ..< 0x80 { string s = checkpanic string:fromCodePointInt(cp); if s is SingleCharDelim { ft[cp] = s; } }"
fragTokens,"foreach int fragCodeIndex in 0 ..< fragCodes.length() { FragCode code = fragCodes[fragCodeIndex]; if code <= VAR_FRAG_MAX { lineContent.push(line.fragments[fragmentIndex]); fragmentIndex += 1; } else if code >= FRAG_FIXED_TOKEN { lineContent.push(<string>fragTokens[<int>code]); } else { lineContent.push(<string>fragFixed[<int>code]); } }"
i,"foreach int i in 0 ..< fragCodes.length() { if fragCodes[i] <= VAR_FRAG_MAX { fragments[nVarFragments] = fragments[i]; nVarFragments += 1; } }"
cp,"foreach int index in endIndex { fragments.push(str.substring(startIndex, index)); startIndex = index; }"
fragCodeIndex,"foreach var ch in str { if ch == "\n" { if cr == () || cr + 1 != i { lines.push(str.substring(lineStartIndex, i)); } lineStartIndex = i + 1; } else if ch == "\r" { lines.push(str.substring(lineStartIndex, i)); cr = i; lineStartIndex = i + 1; } i += 1; }"
i,"foreach int i in 0 ..< keywords.length() { if keywords[i] == kw { return i; } }"
class,"foreach var ch in identifier { if ch == "_" { if prevChar == () { return tok.err("identifier in an import must not have leading underscores"); } else if prevChar == "_" { return tok.err("identifier in an import must not have consecutive underscores"); } } prevChar = ch; }"
ESCAPES,"foreach int fragmentIndex in startFragmentIndex ..< fragments.length() { endCodePointIndex += fragments[fragmentIndex].length(); FragCode fragCode = fragCodes[fragmentIndex]; if fragCode == FRAG_STRING_CLOSE { break; } }"
CASE_START_LENGTH,"foreach var s in sources { tests[s[1]] = [s[0], splitIntoLines(s[1])]; }"
s,"foreach var s in testData { if s is string[] { string[] expected; string subject = s[2]; string[] subjectLines = splitIntoLines(subject); if s.length() == 4 { expected = splitIntoLines(s[3]); } else { expected = subjectLines; } if tests.hasKey(subject) { test:assertFail("duplicate test: " + subject); } string rule = s[1]; if rule is ProductionRule { tests[subject] = [s[0], rule, subjectLines, expected]; } else { test:assertFail("invalid rule: " + rule); } } }"
s,"foreach var f in testFiles { string path = f.absPath; string base = check file:basename(path); if !base.endsWith(SOURCE_EXTENSION) { continue; } string[] src = check readCase(path); string parentDir = check file:parentPath(path); string canonFile = check file:joinPath(parentDir, canonFileName(base)); string[] expected; if check file:test(canonFile, file:EXISTS) { expected = check readCase(canonFile); } else { expected = src; } [Kind, string] baseParts = check splitTestName(base); string rule = baseParts[1]; if rule is ProductionRule { tests["file:" + base] = [baseParts[0], rule, src, expected]; } else { test:assertFail("invalid rule: " + rule); } }"
f,"foreach var line in lines { string trimLine = line.trim(); if trimLine == CASE_START && line.endsWith(CASE_START) { inCase = true; indented = line.length() - CASE_START_LENGTH; continue; } if trimLine == CASE_END { break; } if inCase { caseLines.push(line.substring(indented)); } }"
baseTestDir,"string baseTestDir = check file:joinPath(baseDir, testDir);"
transformedTestDir,"string transformedTestDir = check file:joinPath(transformedDir, testDir);"
skipped,"TestDiffResult[] skipped = [];"
changed,"TestDiffResult[] changed = [];"
unchanged,"TestDiffResult[] unchanged = [];"
baseTestFile,"string baseTestFile = check file:joinPath(baseTestDir, test);"
transformedTestFile,"string transformedTestFile = check file:joinPath(transformedTestDir, test);"
baseTests,"TestCase[] baseTests = check parseTests(baseTestFile);"
transformedTests,"TestCase[] transformedTests = check parseTests(transformedTestFile);"
lines,"string[] lines = check io:fileReadLines(path);"
content,"string[] content = [];"
description,"string description = "";"
tests,"TestCase[] tests = [];"
s,"State s = CONTENT;"
baseIndex,"int baseIndex = 0;"
transformedIndex,"int transformedIndex = 0;"
baseDescription,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
baseContent,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
transformedDescription,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
transformedContent,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
body,"string[] body = [];"
currentPath,"string currentPath = "";"
path,"string path = diff.base.path;"
parts,"string[] parts = check file:splitPath(absPath);"
newContent,"string[] newContent = ["import ballerina/io;"];"
newLabels,"string[] newLabels = [];"
initFunc,"string initFunc = "function init()";"
newLine,"string newLine;"
starIndex,"int? starIndex = line.indexOf("{");"
endIndex,"int? endIndex = line.indexOf("}");"
targetIndex,"int targetIndex = <int>line.indexOf("?;");"
i,"int? i = s.indexOf(":");"
fieldName,"string fieldName = s.substring(0, i);"
fieldValue,"string fieldValue = s.substring(i + 1);"
labels,"string[] labels = [];"
skipped,"int skipped = 0;"
index,"int index = 0;"
skipIndices,"int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];"
skipTest,"boolean skipTest = false;"
outputFileName,"string outputFileName = string `./tests/${dir}/${filename}`;"
invalid,"boolean invalid = true;"
aliasName,"string aliasName = self.escapeGlobalIdent(name);"
alias,"ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), "@" + aliasName);"
varName,"string varName = escapeIdent(name);"
out,"Output out = new;"
words,"string[] words = ["target", "triple", "=", "\"", <TargetTriple>self.target, "\""];"
line,"string[] line = [alias.operand, "="];"
words,"string[] words = [];"
initializer,"var initializer = prop.initializer;"
metadata,"Metadata metadata = new(self.genMetadataLabel());"
attrib,"ReturnEnumAttribute attrib = attribute[1];"
attrib,"ParamEnumAttribute attrib = attribute[1];"
paramIndex,"int paramIndex = attribute[0];"
paramType,"final Type paramType = functionType.paramTypes[i];"
register,"string register = "%" + i.toString();"
arg,"Value arg = new (paramType, register);"
isFirst,"boolean isFirst = true;"
bbName,"string|Unnamed bbName = self.genName(name);"
bb,"BasicBlock bb = new (self.context, bbName, self);"
varName,"string varName = name;"
count,"int count = self.variableNames.get(varName);"
newName,"string newName = varName + "." + count.toString();"
varName,"int varName = self.unnamedLabelCount;"
reg,"string|Unnamed reg = self.genName(name);"
newLabel,"string newLabel = self.nameCounter.toString();"
newName,"string newName = "%" + self.nameCounter.toString();"
newName,"string newName = self.nameTranslation[name];"
metadata,"Metadata metadata = self.m.addMetadata();"
body,"string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_pointer_type"];"
name,"string? name = props.name;"
alignInBits,"Alignment? alignInBits = props.alignInBits;"
body,"string[] body = [metadata.ref(), "=", "!", "DIDerivedType", "(", "tag", ":", "DW_TAG_typedef", ",", "name", ":", "\"", name, "\"", ",", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];"
encodingToString,"string encodingToString = "DW_ATE_" + props.encoding;"
align,"int? align = props.alignInBits;"
words,"(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.value", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];"
words,"(string|Unnamed)[] words = ["call", "void", "@llvm.dbg.declare", "(", "metadata", typeToString(props.value.ty, self.context), props.value.operand, ",", "metadata", props.varInfo.ref(), ",", "metadata", props.expr.ref(), ")"];"
scope,"Metadata? scope = props.scope;"
file,"Metadata? file = props.file;"
ty,"Metadata? ty = props.ty;"
flags,"string[] flags = [];"
retainedNodes,"Metadata retainedNodes = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), "=", "distinct", "!", "DILexicalBlock", "(", "scope", ":", scope.ref(), ",", "file", ":", file.ref()];"
typeNode,"Metadata typeNode = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), "=", "!", "DILocation", "("];"
bb,"BasicBlock bb = self.bb();"
reg,"string|Unnamed reg = bb.func.genReg(name);"
ptrTy,"PointerType ptrTy = pointerType(ty);"
ty,"Type ty = ptr.ty.pointsTo;"
ty,"IntType|FloatType ty = sameNumberType(lhs, rhs);"
ty,"IntegralType ty = sameIntegralType(lhs, rhs);"
words,"(string|Unnamed)[] words = [reg, "="];"
valueType,"Type valueType = val.ty;"
valTy,"Type valTy = val.ty;"
insnWords,"(string|Unnamed)[] insnWords;"
retType,"RetType retType;"
fnTy,"Type fnTy = fn.ty.pointsTo;"
fnName,"var fnName = fn.operand;"
functionName,"string functionName = "@" + fn.functionName;"
words,"(string|Unnamed)[] words = [reg];"
insnWords,"(string|Unnamed)[] insnWords = [];"
arg,"final Value arg = args[i];"
elementType,"Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);"
condTy,"Type condTy = condition.ty;"
words,"(string|Unnamed)[] words = [];"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);"
tem,"BasicBlock? tem = self.currentBlock;"
chunks,"(string|Unnamed)[] chunks = [];"
currentChunk,"string[] currentChunk = [];"
newLines,"(string|Unnamed)[][] newLines = [];"
newLine,"(string|Unnamed)[] newLine = [];"
newLine,"string[] newLine = [];"
outputLine,"string outputLine = createLine([concat(...newLine)], INDENT);"
ty1,"Type ty1 = v1.ty;"
ty2,"Type ty2 = v2.ty;"
tyName,"string? tyName = ty.name;"
elementTypes,"Type[] elementTypes = ty.elementTypes;"
typeStringBody,"string[] typeStringBody = [];"
elementType,"final Type elementType = elementTypes[i];"
paramType,"final Type paramType = ty.paramTypes[i];"
elementTypes,"Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);"
metadata,"Metadata? metadata = fn.metadata;"
ty,"final Type ty = fn.functionType.paramTypes[i];"
parts,"string[] parts = [];"
lastTail,"string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : "";"
head,"string head = word.length() > 0 ? word.substring(0, 1) : "";"
escaped,"string escaped = "\"";"
cp,"int cp = ch.toCodePointInt();"
bytes,"byte[] bytes = ch.toBytes();"
result,"string result = "";"
hex,"string hex = cp.toHexString().toUpperAscii();"
ptrTy,"Type ptrTy = ptr.ty;"
resultType,"Type resultType = ptr.ty;"
resultAddressSpace,"int resultAddressSpace = 0;"
i,"int i;"
indexTy,"Type indexTy = index.ty;"
result,"string result = "c\"";"
hex,"string hex = b.toHexString().toUpperAscii();"
endPos,"Position endPos = tok.previousEndPos();"
endPos,"Position endPos = tok.currentEndPos();"
valueExpr,"SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);"
td,"TypeDesc td = check parseTypeDesc(tok);"
startPos,"Position startPos = tok.currentStartPos();"
params,"FunctionTypeParam[] params = namedParams ?: [];"
paramStartPos,"Position paramStartPos = tok.currentStartPos();"
ret,"TypeDesc? ret = ();"
t,"Token? t = tok.current();"
namePos,"Position namePos = tok.currentStartPos();"
name,"string name = check tok.expectIdentifier();"
members,"TypeDesc[] members = [];"
rest,"TypeDesc? rest = ();"
fields,"FieldDesc[] fields = [];"
fieldStartPos,"Position fieldStartPos = tok.currentStartPos();"
ro,"boolean ro = false;"
endPos,"Position endPos = check tok.expectEnd(";");"
expr,"ListConstructorExpr expr = { startPos, endPos, opPos: startPos, members };"
fields,"Field[] fields = check parseFields(tok);"
expr,"MappingConstructorExpr expr = { startPos, endPos, opPos: startPos, fields };"
expr,"Expr expr = check parseLogicalAndExpr(tok);"
opPos,"Position opPos = tok.currentStartPos();"
right,"Expr right = check parseLogicalAndExpr(tok);"
bin,"BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "||", left: expr, right };"
expr,"Expr expr = check parseBitwiseOrExpr(tok);"
right,"Expr right = check parseBitwiseOrExpr(tok);"
bin,"BinaryLogicalExpr bin = { startPos, endPos, opPos, logicalOp: "&&", left: expr, right };"
expr,"Expr expr = check parseBitwiseXorExpr(tok);"
right,"Expr right = check parseBitwiseXorExpr(tok);"
bin,"BinaryBitwiseExpr bin = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };"
expr,"Expr expr = check parseBitwiseAndExpr(tok);"
right,"Expr right = check parseBitwiseAndExpr(tok);"
expr,"Expr expr = check parseEqualityExpr(tok);"
right,"Expr right = check parseEqualityExpr(tok);"
expr,"Expr expr = check parseRelationalExpr(tok);"
right,"Expr right = check parseRelationalExpr(tok);"
bin,"BinaryEqualityExpr bin = { startPos, endPos, opPos, equalityOp: t, left: expr, right };"
expr,"Expr expr = check parseShiftExpr(tok);"
right,"Expr right = check parseShiftExpr(tok);"
bin,"BinaryRelationalExpr bin = { startPos, endPos, opPos, relationalOp: t, left: expr, right };"
t2,"Token? t2 = tok.current();"
kwPos,"Position kwPos = tok.currentStartPos();"
lower,"Expr lower = check parseAdditiveExpr(tok);"
opPos,"Position opPos = check tok.expectStart("..<");"
upper,"Expr upper = check parseAdditiveExpr(tok);"
expr,"Expr expr = check parseAdditiveExpr(tok);"
right,"Expr right = check parseAdditiveExpr(tok);"
shift,"BinaryBitwiseExpr shift = { startPos, endPos, opPos, bitwiseOp: t, left: expr, right };"
expr,"Expr expr = check parseMultiplicativeExpr(tok);"
right,"Expr right = check parseMultiplicativeExpr(tok);"
bin,"BinaryArithmeticExpr bin = { startPos, endPos, opPos, arithmeticOp: t, left: expr, right };"
expr,"Expr expr = check parseUnaryExpr(tok);"
right,"Expr right = check parseUnaryExpr(tok);"
operand,"Expr operand = check parseUnaryExpr(tok);"
expr,"UnaryExpr expr = { startPos, endPos, opPos, op: t, operand };"
expr,"CheckingExpr expr = { startPos, endPos, kwPos, checkingKeyword: t, operand };"
expr,"TypeCastExpr expr = { startPos, endPos, opPos, td, operand };"
prefix,"string? prefix;"
name,"string name;"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };"
expr,"FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: () };"
innerExpr,"Expr innerExpr = check parseInnerExpr(tok);"
expr,"LiteralExpr expr = { startPos, endPos, value: t == "true" };"
message,"Expr message = check parseExpr(tok);"
index,"Expr index = check parseInnerExpr(tok);"
accessEndPos,"Position accessEndPos = check tok.expectEnd("]");"
accessExpr,"MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };"
qnamePos,"Position qnamePos = tok.currentStartPos();"
name,"string name = check parseIdentifierOrMethodName(tok);"
fieldAccessExpr,"FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };"
openParenPos,"Position openParenPos = tok.currentStartPos();"
exprs,"Expr[] exprs = [];"
expr,"Expr expr = check parseExpr(tok);"
closeTerminatorPos,"Position closeTerminatorPos = tok.currentStartPos();"
fields,"Field[] fields = [];"
f,"Field f = check parseField(tok);"
isIdentifier,"boolean isIdentifier = t[0] == IDENTIFIER;"
name,"string name = t[1];"
colonPos,"Position colonPos = tok.currentStartPos();"
value,"Expr value = check parseExpr(tok);"
f,"Field f = { startPos, endPos, colonPos, name, value, isIdentifier };"
operand,"NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);"
expr,"SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };"
expr,"LiteralExpr expr = { startPos, endPos, value };"
endPos,"Position endPos = check tok.expectEnd(")");"
untypedLiteral,", var untypedLiteral"
typeSuffix,", var typeSuffix] => { Position"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits };"
:fromHexString,": int:fromHexString(digits);"
fragment,"string fragment = self.fragments[self.fragmentIndex];"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex];"
t,"Token? t = self.curTok;"
msg,"d:Message msg;"
pos,"Position pos = self.currentEndPos();"
pos,"Position pos = self.currentStartPos();"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex - 1];"
startPos,"Position startPos;"
endPos,"Position? endPos;"
line,"ScannedLine line = self.scannedLine(startLineNum);"
lineFragments,"string[] lineFragments = scanLineFragments(line);"
lineContent,"string lineContent = "".'join(...lineFragments);"
endColumnNum,"int endColumnNum;"
endLineNum,"int endLineNum;"
line,"ScannedLine line = self.scannedLine(lineNum);"
endColumnNum,"int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);"
fragments,"string[] fragments = line.fragments;"
fragCodes,"FragCode[] fragCodes = line.fragCodes;"
endCodePointIndex,"int endCodePointIndex = startCodePointIndex;"
fragmentIndex,"int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);"
nCodePoints,"int nCodePoints = 0;"
fragmentIndex,"int fragmentIndex = 0;"
nFragments,"int nFragments = fragments.length();"
fragCode,"FragCode fragCode = fragCodes[fragmentIndex];"
sources,"SingleStringTokenizerTestCase[] sources = [ ["E", string`"`], ["E", "'"], ["E", "`"], ["E", string`"\"`], ["E", string`"\a"`], ["E", string`\`], ["E", string`"${ "\n" }"`], ["E", string`"${ "\r" }"`], ["E", string`"\\`], ["E", string`"\u{}"`], ["E", "\"\\" + "u{D800}\""], ["E", "\"\\" + "u{DFFF}\""], ["E", "\"\\" + "u{110000}\""], ["E", string`"\u{X}"`], ["E", string`"\u{-6A}"`], ["E", string`"\u"`], ["E", string`"\u{"`], ["E", string`"\u{0"`] ];"
tests,"map<TokenizerTestCase> tests = {};"
tests,"map<ParserTestCase> tests = {};"
testData,"ParserTestJson[] testData = check (check io:fileReadJson("modules/front.syntax/tests/data/testParser.json")).fromJsonWithType();"
expected,"string[] expected;"
subject,"string subject = s[2];"
subjectLines,"string[] subjectLines = splitIntoLines(subject);"
rule,"string rule = s[1];"
testFiles,"var testFiles = check file:readDir("modules/front.syntax/tests/data");"
path,"string path = f.absPath;"
base,"string base = check file:basename(path);"
src,"string[] src = check readCase(path);"
parentDir,"string parentDir = check file:parentPath(path);"
canonFile,"string canonFile = check file:joinPath(parentDir, canonFileName(base));"
baseParts,"[Kind, string] baseParts = check splitTestName(base);"
rule,"string rule = baseParts[1];"
len,"int len = base.length();"
kindPos,"int kindPos = base.indexOf("-") ?: 0;"
kind,"string kind = base.substring(0, kindPos);"
afterKindPos,"int afterKindPos = min(kindPos + 1, len);"
rulePos,"int rulePos = base.indexOf("-", afterKindPos) ?: afterKindPos;"
rule,"string rule = base.substring(afterKindPos, rulePos);"
caseLines,"string[] caseLines = [];"
inCase,"boolean inCase = false;"
indented,"int indented = 0;"
trimLine,"string trimLine = line.trim();"
sansExt,"string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());"
