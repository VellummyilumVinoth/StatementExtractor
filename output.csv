baseTestDir,"string baseTestDir = check file:joinPath(baseDir, testDir);"
transformedTestDir,"string transformedTestDir = check file:joinPath(transformedDir, testDir);"
skipped,"TestDiffResult[] skipped = [];"
changed,"TestDiffResult[] changed = [];"
unchanged,"TestDiffResult[] unchanged = [];"
baseTestFile,"string baseTestFile = check file:joinPath(baseTestDir, test);"
transformedTestFile,"string transformedTestFile = check file:joinPath(transformedTestDir, test);"
baseTests,"TestCase[] baseTests = check parseTests(baseTestFile);"
transformedTests,"TestCase[] transformedTests = check parseTests(transformedTestFile);"
lines,"string[] lines = check io:fileReadLines(path);"
content,"string[] content = [];"
description,"string description = \"\";"
tests,"TestCase[] tests = [];"
s,"State s = CONTENT;"
baseIndex,"int baseIndex = 0;"
transformedIndex,"int transformedIndex = 0;"
baseDescription,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
baseContent,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
transformedDescription,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
transformedContent,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
body,"string[] body = [];"
currentPath,"string currentPath = \"\";"
path,"string path = diff.base.path;"
parts,"string[] parts = check file:splitPath(absPath);"
newContent,"string[] newContent = [\"import ballerina/io;\"];"
newLabels,"string[] newLabels = [];"
initFunc,"string initFunc = \"function init()\";"
newLine,"string newLine;"
starIndex,"int? starIndex = line.indexOf(\"{\");"
endIndex,"int? endIndex = line.indexOf(\"}\");"
targetIndex,"int targetIndex = <int>line.indexOf(\"?;\");"
i,"int? i = s.indexOf(\":\");"
fieldName,"string fieldName = s.substring(0, i);"
fieldValue,"string fieldValue = s.substring(i + 1);"
labels,"string[] labels = [];"
skipped,"int skipped = 0;"
index,"int index = 0;"
skipIndices,"int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];"
skipTest,"boolean skipTest = false;"
outputFileName,"string outputFileName = string `./tests/${dir}/${filename}`;"
invalid,"boolean invalid = true;"
aliasName,"string aliasName = self.escapeGlobalIdent(name);"
alias,"ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), \"@\" + aliasName);"
varName,"string varName = escapeIdent(name);"
out,"Output out = new;"
words,"string[] words = [\"target\", \"triple\", \"=\", \"\\"\", <TargetTriple>self.target, \"\\"\"];"
line,"string[] line = [alias.operand, \"=\"];"
words,"string[] words = [];"
initializer,"var initializer = prop.initializer;"
metadata,"Metadata metadata = new(self.genMetadataLabel());"
attrib,"ReturnEnumAttribute attrib = attribute[1];"
attrib,"ParamEnumAttribute attrib = attribute[1];"
paramIndex,"int paramIndex = attribute[0];"
paramType,"final Type paramType = functionType.paramTypes[i];"
register,"string register = \"%\" + i.toString();"
arg,"Value arg = new (paramType, register);"
isFirst,"boolean isFirst = true;"
bbName,"string|Unnamed bbName = self.genName(name);"
bb,"BasicBlock bb = new (self.context, bbName, self);"
varName,"string varName = name;"
count,"int count = self.variableNames.get(varName);"
newName,"string newName = varName + \".\" + count.toString();"
varName,"int varName = self.unnamedLabelCount;"
reg,"string|Unnamed reg = self.genName(name);"
newLabel,"string newLabel = self.nameCounter.toString();"
newName,"string newName = \"%\" + self.nameCounter.toString();"
newName,"string newName = self.nameTranslation[name];"
metadata,"Metadata metadata = self.m.addMetadata();"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_pointer_type\"];"
name,"string? name = props.name;"
alignInBits,"Alignment? alignInBits = props.alignInBits;"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_typedef\", \",\", \"name\", \":\", \"\\"\", name, \"\\"\", \",\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
encodingToString,"string encodingToString = \"DW_ATE_\" + props.encoding;"
align,"int? align = props.alignInBits;"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.value\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.declare\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
scope,"Metadata? scope = props.scope;"
file,"Metadata? file = props.file;"
ty,"Metadata? ty = props.ty;"
flags,"string[] flags = [];"
retainedNodes,"Metadata retainedNodes = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"distinct\", \"!\", \"DILexicalBlock\", \"(\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
typeNode,"Metadata typeNode = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"!\", \"DILocation\", \"(\"];"
bb,"BasicBlock bb = self.bb();"
reg,"string|Unnamed reg = bb.func.genReg(name);"
ptrTy,"PointerType ptrTy = pointerType(ty);"
ty,"Type ty = ptr.ty.pointsTo;"
ty,"IntType|FloatType ty = sameNumberType(lhs, rhs);"
ty,"IntegralType ty = sameIntegralType(lhs, rhs);"
words,"(string|Unnamed)[] words = [reg, \"=\"];"
valueType,"Type valueType = val.ty;"
valTy,"Type valTy = val.ty;"
insnWords,"(string|Unnamed)[] insnWords;"
retType,"RetType retType;"
fnTy,"Type fnTy = fn.ty.pointsTo;"
fnName,"var fnName = fn.operand;"
functionName,"string functionName = \"@\" + fn.functionName;"
words,"(string|Unnamed)[] words = [reg];"
insnWords,"(string|Unnamed)[] insnWords = [];"
arg,"final Value arg = args[i];"
elementType,"Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);"
condTy,"Type condTy = condition.ty;"
words,"(string|Unnamed)[] words = [];"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);"
tem,"BasicBlock? tem = self.currentBlock;"
chunks,"(string|Unnamed)[] chunks = [];"
currentChunk,"string[] currentChunk = [];"
newLines,"(string|Unnamed)[][] newLines = [];"
newLine,"(string|Unnamed)[] newLine = [];"
newLine,"string[] newLine = [];"
outputLine,"string outputLine = createLine([concat(...newLine)], INDENT);"
ty1,"Type ty1 = v1.ty;"
ty2,"Type ty2 = v2.ty;"
tyName,"string? tyName = ty.name;"
elementTypes,"Type[] elementTypes = ty.elementTypes;"
typeStringBody,"string[] typeStringBody = [];"
elementType,"final Type elementType = elementTypes[i];"
paramType,"final Type paramType = ty.paramTypes[i];"
elementTypes,"Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);"
metadata,"Metadata? metadata = fn.metadata;"
ty,"final Type ty = fn.functionType.paramTypes[i];"
parts,"string[] parts = [];"
lastTail,"string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : \"\";"
head,"string head = word.length() > 0 ? word.substring(0, 1) : \"\";"
escaped,"string escaped = \"\\"\";"
cp,"int cp = ch.toCodePointInt();"
bytes,"byte[] bytes = ch.toBytes();"
result,"string result = \"\";"
hex,"string hex = cp.toHexString().toUpperAscii();"
ptrTy,"Type ptrTy = ptr.ty;"
resultType,"Type resultType = ptr.ty;"
resultAddressSpace,"int resultAddressSpace = 0;"
i,"int i;"
indexTy,"Type indexTy = index.ty;"
result,"string result = \"c\\"\";"
hex,"string hex = b.toHexString().toUpperAscii();"
endPos,"Position endPos = tok.previousEndPos();"
endPos,"Position endPos = tok.currentEndPos();"
valueExpr,"SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);"
td,"TypeDesc td = check parseTypeDesc(tok);"
startPos,"Position startPos = tok.currentStartPos();"
params,"FunctionTypeParam[] params = namedParams ?: [];"
paramStartPos,"Position paramStartPos = tok.currentStartPos();"
ret,"TypeDesc? ret = ();"
t,"Token? t = tok.current();"
namePos,"Position namePos = tok.currentStartPos();"
name,"string name = check tok.expectIdentifier();"
members,"TypeDesc[] members = [];"
rest,"TypeDesc? rest = ();"
fields,"FieldDesc[] fields = [];"
fieldStartPos,"Position fieldStartPos = tok.currentStartPos();"
ro,"boolean ro = false;"
endPos,"Position endPos = check tok.expectEnd(\";\");"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };"
expr,"FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: () };"
expr,"Expr expr = check parseExpr(tok);"
expr,"LiteralExpr expr = { startPos, endPos, value: t == \"true\" };"
kwPos,"Position kwPos = tok.currentStartPos();"
message,"Expr message = check parseExpr(tok);"
fields,"Field[] fields = check parseFields(tok);"
opPos,"Position opPos = tok.currentStartPos();"
index,"Expr index = check parseExpr(tok);"
accessEndPos,"Position accessEndPos = check tok.expectEnd(\"]\");"
accessExpr,"MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };"
qnamePos,"Position qnamePos = tok.currentStartPos();"
name,"string name = check parseIdentifierOrMethodName(tok);"
fieldAccessExpr,"FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };"
openParenPos,"Position openParenPos = tok.currentStartPos();"
exprs,"Expr[] exprs = [];"
closeTerminatorPos,"Position closeTerminatorPos = tok.currentStartPos();"
fields,"Field[] fields = [];"
f,"Field f = check parseField(tok);"
isIdentifier,"boolean isIdentifier = t[0] == IDENTIFIER;"
name,"string name = t[1];"
colonPos,"Position colonPos = tok.currentStartPos();"
value,"Expr value = check parseExpr(tok);"
f,"Field f = { startPos, endPos, colonPos, name, value, isIdentifier };"
operand,"NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);"
expr,"SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };"
expr,"LiteralExpr expr = { startPos, endPos, value };"
endPos,"Position endPos = check tok.expectEnd(\")\");"
untypedLiteral,", var untypedLiteral"
typeSuffix,", var typeSuffix] => { Position"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits };"
:fromHexString,": int:fromHexString(digits);"
fragment,"string fragment = self.fragments[self.fragmentIndex];"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex];"
t,"Token? t = self.curTok;"
msg,"d:Message msg;"
pos,"Position pos = self.currentEndPos();"
pos,"Position pos = self.currentStartPos();"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex - 1];"
startPos,"Position startPos;"
endPos,"Position? endPos;"
line,"ScannedLine line = self.scannedLine(startLineNum);"
lineFragments,"string[] lineFragments = scanLineFragments(line);"
lineContent,"string lineContent = \"\".'join(...lineFragments);"
endColumnNum,"int endColumnNum;"
endLineNum,"int endLineNum;"
line,"ScannedLine line = self.scannedLine(lineNum);"
endColumnNum,"int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);"
fragments,"string[] fragments = line.fragments;"
fragCodes,"FragCode[] fragCodes = line.fragCodes;"
endCodePointIndex,"int endCodePointIndex = startCodePointIndex;"
fragmentIndex,"int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);"
nCodePoints,"int nCodePoints = 0;"
fragmentIndex,"int fragmentIndex = 0;"
nFragments,"int nFragments = fragments.length();"
fragCode,"FragCode fragCode = fragCodes[fragmentIndex];"
sources,"SingleStringTokenizerTestCase[] sources = [ [\"E\", string`\"`], [\"E\", \"'\"], [\"E\", \"`\"], [\"E\", string`\"\\"`], [\"E\", string`\"\a\"`], [\"E\", string`\`], [\"E\", string`\"${ \"\n\" }\"`], [\"E\", string`\"${ \"\r\" }\"`], [\"E\", string`\"\\`], [\"E\", string`\"\u{}\"`], [\"E\", \"\\"\\\" + \"u{D800}\\"\"], [\"E\", \"\\"\\\" + \"u{DFFF}\\"\"], [\"E\", \"\\"\\\" + \"u{110000}\\"\"], [\"E\", string`\"\u{X}\"`], [\"E\", string`\"\u{-6A}\"`], [\"E\", string`\"\u\"`], [\"E\", string`\"\u{\"`], [\"E\", string`\"\u{0\"`] ];"
tests,"map<TokenizerTestCase> tests = {};"
tests,"map<ParserTestCase> tests = {};"
testData,"ParserTestJson[] testData = check (check io:fileReadJson(\"modules/front.syntax/tests/data/testParser.json\")).fromJsonWithType();"
expected,"string[] expected;"
subject,"string subject = s[2];"
subjectLines,"string[] subjectLines = splitIntoLines(subject);"
rule,"string rule = s[1];"
testFiles,"var testFiles = check file:readDir(\"modules/front.syntax/tests/data\");"
path,"string path = f.absPath;"
base,"string base = check file:basename(path);"
src,"string[] src = check readCase(path);"
parentDir,"string parentDir = check file:parentPath(path);"
canonFile,"string canonFile = check file:joinPath(parentDir, canonFileName(base));"
baseParts,"[Kind, string] baseParts = check splitTestName(base);"
rule,"string rule = baseParts[1];"
len,"int len = base.length();"
kindPos,"int kindPos = base.indexOf(\"-\") ?: 0;"
kind,"string kind = base.substring(0, kindPos);"
afterKindPos,"int afterKindPos = min(kindPos + 1, len);"
rulePos,"int rulePos = base.indexOf(\"-\", afterKindPos) ?: afterKindPos;"
rule,"string rule = base.substring(afterKindPos, rulePos);"
caseLines,"string[] caseLines = [];"
inCase,"boolean inCase = false;"
indented,"int indented = 0;"
trimLine,"string trimLine = line.trim();"
sansExt,"string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());"
